#   syntax: generator options definition grammar
#
#   Lapg (Lexical Analyzer and Parser Generator)
#   Copyright (C) 2002-10  Evgeny Gryaznov (inspirer@inbox.ru)
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

.lang        "java" 
.prefix      "Optdef"
.package	 "net.sf.lapg.gen.options"
.lexemend    "on"
.gentree	 "on"
.genast		 "on"
.astprefix	 "AstOpt"
.positions   "line,offset"
.endpositions "offset"

# Vocabulary

[0]

identifier(String): /[a-zA-Z_][a-zA-Z_0-9]*|'([^\n\\']|\\.)*'/ -1
			{ $lexem = current(); break; }

scon(String):	/"([^\n\\"]|\\.)*"/		{ $lexem = unescape(current(), 1, token.length()-1); break; }
icon(Integer):	/-?[0-9]+/				{ $lexem = Integer.parseInt(current()); break; }

_skip:         /[\n\t\r ]+/    		{ return false; }
_skip:  /#.*/

';':    /;/
',':	/,/
':':    /:/
'=':    /=/
'{':	/\{/
'}':	/\}/
'(':	/\(/
')':	/\)/
'[':	/\[/
']':	/\]/

Lset:		 /set/
Lchoice:	 /choice/
Luint:		 /uint/
Lidentifier: /identifier/
Lqualified:	 /qualified/
Lbool:		 /bool/

Lglobal:	 /global/
Ltitle:		 /title/
Ldefault:	 /default/
Lnotempty:	 /notempty/
Ltypes:		 /types/
Lstring:	 /string/

Lsymbol:	 /symbol/
Lrule:		 /rule/
Lref:		 /ref/
Larray:		 /array/
Lstruct:	 /struct/

# Grammar

input ::=
	groups ;

groups ::=
	groups group | group ;

group ::=
	Lglobal title=scon '{' declarations '}'
  | kind=anno_kind '{' declarations '}'
  | Ltypes '{' typedefs '}'
;

anno_kind ::=
	Lsymbol | Lrule | Lref ;

##### DECLARATIONS

declarations ::=
	declarations declaration | declaration ;

declaration ::=
	identifier ':' type modifiersopt defaultval optionslistopt ;

optionslist ::=
	optionslist ',' option | ';' option ;

option ::=
	Ltitle scon ;

defaultval ::=
	Ldefault expression ;

modifiers ::=
	modifiers modifier | modifier ;

modifier ::=
	Lnotempty ;

##### TYPES

typedefs ::=
	typedefs typedef | typedef ;

typedef ::=
	identifier '=' type ';' ;

type ::=
	identifier
  | Luint
  | Lstring
  | Lidentifier
  | Lqualified
  | Lsymbol
  | Lbool
  | Lbool '(' trueVal = string ',' falseVal = string ')'
  | Lset '(' strings ')'
  | Lchoice '(' strings ')'
  | Larray '(' type ')'
  | Lstruct '{' declarations '}'
;

strings ::=
	strings ',' string | string ;
	
string ::=
	identifier | scon ;	

##### EXPRESSIONS

expression ::=
	  scon
	| icon
	| '[' map_entries ']'
	| '[' expression_list ']'
;

expression_list ::=
	expression
	| expression_list ',' expression
;

map_entries ::=
	  identifier ':' expression
	| map_entries ',' identifier ':' expression
;

##################################################################################

%%

${template java_lexer.lexercode}
private String unescape(String s, int start, int end) {
	StringBuilder sb = new StringBuilder();
	end = Math.min(end, s.length());
	for(int i = start; i < end; i++) {
		char c = s.charAt(i);
		if(c == '\\') {
			if(++i == end) {
				break;
			}
			c = s.charAt(i);
			if(c == 'u' || c == 'x') {
				// FIXME process unicode
			} else if(c == 'n') {
				sb.append('\n');
			} else if(c == 'r') {
				sb.append('\r');
			} else if(c == 't') {
				sb.append('\t');
			} else {
				sb.append(c);
			}
		} else {
			sb.append(c);
		}
	} 
	return sb.toString();
}
${end}