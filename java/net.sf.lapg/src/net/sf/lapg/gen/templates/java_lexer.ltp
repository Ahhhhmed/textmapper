${template unit-}
package ${call java.package};

import java.io.InputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.text.MessageFormat;

public class ${opts.lexer} {
${call innerDeclarations-}

	final private InputStream stream;
	final private ErrorReporter reporter;
	final private String encoding;

	final private byte[] token = new byte[${opts.maxtoken}];
	private int len;
		
	final private byte[] data = new byte[512];
	private int datalen, l, chr;

	private int group = 0;
		
${switch opts.positioning}
${case 'line'}	private int lapg_current_line = 1;
${case 'full'}	private int lapg_current_line = 1, lapg_current_column = 1;
${case 'offset'}	private int lapg_current_line = 1, lapg_current_offset = 0;
${end-}

	public interface Lexems {
${for i : 0,parser.nterms-1 -}
		public static final int ${util.toIdentifier(parser.sym[i].name,i)} = ${i};
${end-}
	}

${util.shiftRight(self->input.lexercode(),1)-}

	public ${opts.lexer}(InputStream stream, ErrorReporter reporter, String encoding) throws IOException {
		this.stream = stream;
		this.reporter = reporter;
		this.encoding = encoding;
		this.datalen = stream.read(data);
		this.l = 0;
		chr = l < datalen ? data[l++] : 0;
	}

${util.shiftRight(self->lexerTables(),1)-}

	public String current() throws UnsupportedEncodingException {
		return new String(token,0,len,encoding);
	}

	public LapgSymbol next() throws IOException, UnsupportedEncodingException {
		LapgSymbol lapg_n = new LapgSymbol();
		int state;

		do {			
${switch opts.positioning}
${case 'line'}			lapg_n.pos = new LapgPlace( lapg_current_line );
${case 'full'}			lapg_n.pos = new LapgPlace( lapg_current_line, lapg_current_column );
${case 'offset'}			lapg_n.pos = new LapgPlace( lapg_current_line, lapg_current_offset );
${end-}
			for( len = 0, state = group; state >= 0; ) {
				if( len < ${opts.maxtoken-1} ) token[len++] = (byte)chr;
				state = lapg_lexem[state][lapg_char2no[(chr+256)%256]];
				if( state >= -1 && chr != 0 ) { 
${switch opts.positioning}
${case 'line'}					if( chr == '\n' ) {
						lapg_current_line++;
					}
${case 'full'}					lapg_current_column++;
					if( chr == '\n' ) {
						lapg_current_column = 1;
						lapg_current_line++;
					}
${case 'offset'}					lapg_current_offset++;
					if( chr == '\n' ) {
						lapg_current_line++;
					}
${end-}
					if( l >= datalen ) {
						this.datalen = stream.read(data);
						l = 0;
					}
					chr = l < datalen ? data[l++] : 0;
				}
			}
${if opts.lexemend == 'on'-}
${switch opts.positioning}
${case 'line'}			lapg_n.endpos = new LapgPlace( lapg_current_line );
${case 'full'}			lapg_n.endpos = new LapgPlace( lapg_current_line, lapg_current_column );
${case 'offset'}			lapg_n.endpos = new LapgPlace( lapg_current_line, lapg_current_offset );
${end-}
${end-}

			if( state == -1 ) {
				if( chr == 0 ) {
					reporter.error(${opts.errorprefix} "Unexpected end of file reached");
					break;
				}
${switch opts.positioning}
${case 'none'}				reporter.error(${opts.errorprefix} MessageFormat.format( "invalid lexem: `{0}`, skipped", current() ) );
${case 'line'}				reporter.error(${opts.errorprefix} MessageFormat.format( "invalid lexem at line {0}: `{1}`, skipped", lapg_n.pos.line, current() ) );
${case 'full'}				reporter.error(${opts.errorprefix} MessageFormat.format( "invalid lexem at line {0}, column {1}: `{2}`, skipped", lapg_n.pos.line, lapg_n.pos.column, current() ) );
${case 'offset'}				reporter.error(${opts.errorprefix} MessageFormat.format( "invalid lexem at line {0}: `{1}`, skipped", lapg_n.pos.line, current() ) );
${end-}
				lapg_n.lexem = -1;
				continue;
			}

			len--;
			lapg_n.lexem = -state-2;
			lapg_n.sym = null;

${if syntax.hasLexemActions()-}
		} while(lapg_n.lexem == -1 || !createToken(lapg_n));
${else-}
		} while(lapg_n.lexem == -1);
${end-}
		return lapg_n;
	}
${if syntax.hasLexemActions()}
	private boolean createToken(LapgSymbol lapg_n) throws UnsupportedEncodingException {
		switch( lapg_n.lexem ) {
${foreach lexem in syntax.lexems-}
${if lexem.action-}
			case ${lexem.symbol.index}:
				${call lexerAction('lapg_n.sym') for lexem-}
${end-}
${end-}
		}
		return true;
	} 
${end-}
}
${end}


${template lexerAction(lexem)-}
${eval action.contents, '[lexem action in '+getAction().getLocation()+']'}
${end}


${template lexerTables-}
private final short[] lapg_char2no = new short[] {
	${util.format(lex.char2no, 16, 1)}
};

${if opts.packLexems != 'true'-}
private static final short[][] lapg_lexem = new short[][] {
	${util.format(lex.change, 1, '{', '}')}
};
${else-}
private int lapg_lexem[][] = unpackFromString(${util.formatForJava(lex.change, 1)});
		
private int[][] unpackFromString(int size1, int size2, String st) {
	int colonIndex = -1;
	String lengthString;
	int sequenceLength = 0;
	int sequenceInteger = 0;
	
	int commaIndex;
	String workString;
	
	int res[][] = new int[size1][size2];
	for (int i = 0; i < size1; i++) {
		for (int j = 0; j < size2; j++) {
			if (sequenceLength != 0) {
				res[i][j] = sequenceInteger;
				sequenceLength--;
				continue;
			}
			commaIndex = st.indexOf(',');
			workString = (commaIndex == -1) ? st : st.substring(0, commaIndex);
			st = st.substring(commaIndex + 1);
			colonIndex = workString.indexOf(':');
			if (colonIndex == -1) {
				res[i][j] = Integer.parseInt(workString);
				continue;
			}
			lengthString = workString.substring(colonIndex + 1);
			sequenceLength = Integer.parseInt(lengthString);
			workString = workString.substring(0, colonIndex);
			sequenceInteger = Integer.parseInt(workString);
			res[i][j] = sequenceInteger;
			sequenceLength--;
		}
	}
	return res;
}
${end-}
${end}


${template innerDeclarations-}
${if opts.positioning != 'none'}
	public static class LapgPlace {
${switch opts.positioning}
${case 'line'}		public int line;
${case 'full'}		public int line, column;
${case 'offset'}		public int line, offset;
${end-}

${switch opts.positioning}
${case 'line'}		public LapgPlace( int line ) {
${case 'full'}		public LapgPlace( int line, int column ) {
${case 'offset'}		public LapgPlace( int line, int offset ) {
${end-}
			this.line = line;
${switch opts.positioning}
${case 'full'}			this.column = column;
${case 'offset'}			this.offset = offset;
${end-}
		}
	};
${end-}

	public static class LapgSymbol {
		public Object sym;
		public int  lexem, state;
${if opts.positioning != 'none'-}
		public LapgPlace pos;
${if opts.lexemend == 'on'-}
		public LapgPlace endpos;
${end-}
${end-}
	};
	
	public interface ErrorReporter {
		void error(String s);
	};
${end}
