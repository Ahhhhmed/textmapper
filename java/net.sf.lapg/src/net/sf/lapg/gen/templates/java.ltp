${template main-}
${file opts.class+'.java'}${call unit}${end-}
${file opts.lexer+'.java'-}${call java_lexer.unit}${end-}
${end}

${template unit-}
package ${call package};

import java.io.IOException;
import ${call package}.${opts.lexer}.Lexems;
import ${call package}.${opts.lexer}.LapgSymbol;
${call input.imports}

public class ${opts.class} implements ${opts.lexer}.ErrorReporter {
${util.shiftRight($input.classcode(),1)-}
${call parserTables-}

	private static final String[] lapg_syms = new String[] {
${foreach s in parser.sym-}
		"${s.name}",
${end-}
	};

	public interface Tokens extends Lexems {
		// non-terminals
${for i : parser.nterms, parser.nsyms-1 -}
		public static final int ${util.toIdentifier(parser.sym[i].name,i)} = ${i};
${end-}
	}

	private static int lapg_next( int state, int symbol ) {
${if parser.nactions > 0-}
		int p;
		if( lapg_action[state] < -2 ) {
			for( p = - lapg_action[state] - 3; lapg_lalr[p] >= 0; p += 2 )
				if( lapg_lalr[p] == symbol ) break;
			return lapg_lalr[p+1];
		}
${end-}
		return lapg_action[state];
	}

	private static int lapg_state_sym( int state, int symbol ) {
		int min = lapg_sym_goto[symbol], max = lapg_sym_goto[symbol+1]-1;
		int i, e;

		while( min <= max ) {
			e = (min + max) >> 1;
			i = lapg_sym_from[e];
			if( i == state )
				return lapg_sym_to[e];
			else if( i < state )
				min = e + 1;
			else
				max = e - 1;
		}
		return -1;
	}

	private int lapg_head;
	private LapgSymbol[] lapg_m;
	private LapgSymbol lapg_n;

	public boolean parse(${opts.lexer} lexer) throws IOException {

		lapg_m = new LapgSymbol[${opts.stack}];
		lapg_head = 0;
${if syntax.error!=-1}		int lapg_symbols_ok = 4;
${end-}

		lapg_m[0] = new LapgSymbol();
		lapg_m[0].state = 0;
		lapg_n = lexer.next(); 

		while( lapg_m[lapg_head].state != ${parser.nstates-1} ) {
			int lapg_i = lapg_next( lapg_m[lapg_head].state, lapg_n.lexem );

			if( lapg_i >= 0 ) {
				reduce(lapg_i);
			} else if( lapg_i == -1 ) {
				shift(lexer);
${if syntax.error!=-1}				lapg_symbols_ok++;
${end-}
			}

			if( lapg_i == -2 || lapg_m[lapg_head].state == -1 ) {
${if syntax.error!=-1-}
				if (lapg_n.lexem == 0) {
					break;
				}
				while (lapg_head >= 0 && lapg_state_sym( lapg_m[lapg_head].state, ${syntax.error} ) == -1) {
					lapg_m[lapg_head] = null; // TODO dispose?
					lapg_head--;
				}
				if (lapg_head >= 0) {
					lapg_m[++lapg_head] = new LapgSymbol();
					lapg_m[lapg_head].lexem = ${syntax.error};
					lapg_m[lapg_head].sym = null;
					lapg_m[lapg_head].state = lapg_state_sym( lapg_m[lapg_head-1].state, ${syntax.error} );
${if opts.positioning != 'none'-}
					lapg_m[lapg_head].pos = lapg_n.pos; // TODO endpos?
${end-}
					if( lapg_symbols_ok >= 4 ) {
${switch opts.positioning}
${case 'none'}						error(${opts.errorprefix} "syntax error" );
${case 'line'}						error(${opts.errorprefix} MessageFormat.format( "syntax error before line {0}", lapg_n.pos.line ) );
${case 'full'}						error(${opts.errorprefix} MessageFormat.format( "syntax error before line {0}, column {1}", lapg_n.pos.line, lapg_n.pos.column ) );
${case 'offset'}						error(${opts.errorprefix} MessageFormat.format( "syntax error before line {0}", lapg_n.pos.line ) );
${end-}
					}
					if( lapg_symbols_ok <= 1 ) {
						lapg_n = lexer.next();
					}
					lapg_symbols_ok = 0;
					continue;
				} else {
					lapg_head = 0;
					lapg_m[0] = new LapgSymbol();
					lapg_m[0].state = 0;
				}
${end-}
				break;
			}
		}

${if syntax.error!=-1-}
		if( lapg_m[lapg_head].state != ${parser.nstates-1} && lapg_symbols_ok >= 4 ) {
${else-}
		if( lapg_m[lapg_head].state != ${parser.nstates-1} ) {
${end-}
${switch opts.positioning}
${case 'none'}			error(${opts.errorprefix} "syntax error" );
${case 'line'}			error(${opts.errorprefix} MessageFormat.format( "syntax error before line {0}", lapg_n.pos.line ) );
${case 'full'}			error(${opts.errorprefix} MessageFormat.format( "syntax error before line {0}, column {1}", lapg_n.pos.line, lapg_n.pos.column ) );
${case 'offset'}			error(${opts.errorprefix} MessageFormat.format( "syntax error before line {0}", lapg_n.pos.line ) );
${end-}
			return false;
		};
		return true;
	}

	private void shift(${opts.lexer} lexer) throws IOException {
		lapg_m[++lapg_head] = lapg_n;
		lapg_m[lapg_head].state = lapg_state_sym( lapg_m[lapg_head-1].state, lapg_n.lexem );
		if( DEBUG_SYNTAX ) {
			System.out.println( MessageFormat.format( "shift: {0} ({1})", lapg_syms[lapg_n.lexem], lexer.current() ) );
		}
		if( lapg_m[lapg_head].state != -1 ) {
			lapg_n = lexer.next();
		}
	}

	@SuppressWarnings("unchecked")
	private void reduce(int rule) {
		LapgSymbol lapg_gg = new LapgSymbol();
		lapg_gg.sym = (lapg_rlen[rule]!=0)?lapg_m[lapg_head+1-lapg_rlen[rule]].sym:null;
		lapg_gg.lexem = lapg_rlex[rule];
		lapg_gg.state = 0;
		if( DEBUG_SYNTAX ) {
			System.out.println( "reduce to " + lapg_syms[lapg_rlex[rule]] );
		}
${if opts.positioning != 'none'-}
		lapg_gg.pos = (lapg_rlen[rule]!=0)?lapg_m[lapg_head+1-lapg_rlen[rule]].pos:lapg_n.pos;
${if opts.lexemend == 'on'-}
		lapg_gg.endpos = (lapg_rlen[rule]!=0)?lapg_m[lapg_head].endpos:lapg_n.pos;
${end-}
${end-}
${if syntax.hasActions()-}
		switch( rule ) {
${foreach rule in syntax.rules-}
${if rule.getAction()-}
			case ${rule.getIndex()}:
				${call parserAction for rule-}
${if opts.breaks == 'on'}				break;$/
${end-}
${end-}
		}
${end-}
		for( int e = lapg_rlen[rule]; e > 0; e-- ) { 
			lapg_m[lapg_head--] = null;
		}
		lapg_m[++lapg_head] = lapg_gg;
		lapg_m[lapg_head].state = lapg_state_sym(lapg_m[lapg_head-1].state, lapg_gg.lexem);
	}
}
${end} 

${template parserTables-}
	private static final int[] lapg_action = new int[] {
		${util.format(parser.action_index, 16, 2)}
	};

${if parser.nactions > 0}
	private static final short[] lapg_lalr = new short[] {
		${util.format(parser.action_table, 16, 2)}
	};
${end}

	private static final short[] lapg_sym_goto = new short[] {
		${util.format(parser.sym_goto, 16, 2)}
	};

	private static final short[] lapg_sym_from = new short[] {
		${util.format(parser.sym_from, 16, 2)}
	};

	private static final short[] lapg_sym_to = new short[] {
		${util.format(parser.sym_to, 16, 2)}
	};

	private static final short[] lapg_rlen = new short[] {
		${util.format(parser.ruleLength, 16, 2)}
	};

	private static final short[] lapg_rlex = new short[] {
		${util.format(parser.rleft, 16, 2)}
	};
${end}

${template parserAction-}
${eval getAction(), '[action in '+getAction().getLocation()+']'}
${end}

${template getsym-}
${if this.isLeft}lapg_gg${else}lapg_m[lapg_head-${this.rightOffset}]${end-}
${end}

${template symbol-}
${if symbol.type-}
((${symbol.type})${call getsym-}.sym)${else-}
${call getsym-}.sym${end-}
${end}

${template sym_line-}
${call getsym}.pos.line${end}

${template sym_column-}
${call getsym}.pos.column${end}

${template sym_offset-}
${call getsym}.pos.offset${end}

${template sym_endline-}
${call getsym}.endpos.line${end}

${template sym_endcolumn-}
${call getsym}.endpos.column${end}

${template sym_endoffset-}
${call getsym}.endpos.offset${end}

${template package-}
${if opts.package-}
${opts.package-}
${else}com.test${end-}
${end}
