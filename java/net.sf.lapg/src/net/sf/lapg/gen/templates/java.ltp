${template main-}
${file opts.prefix+'Parser.java'}${call unit}${end-}
${file opts.prefix+'Lexer.java'}${call java_lexer.unit}${end-}
${if opts.gentree == 'on'-}
${file opts.prefix+'Tree.java'}${call java_tree.unit}${end-}
${end-}
${if opts.genast == 'on'-}
${call java_ast.unit-}
${end-}
${end}

${template options-}
${call java_options.options-}
${end}

${template unit-}
package ${call package};

${call imports-}
import ${call package}.${opts.prefix}Lexer.LapgSymbol;

public class ${opts.prefix}Parser {

${call parseException-}

	private final ${call package}.${opts.prefix}Lexer.@ErrorReporter reporter;

	public ${opts.prefix}Parser(${call package}.${opts.prefix}Lexer.@ErrorReporter reporter) {
		this.reporter = reporter;
	}

${util.shiftRight(self->classcode(),1)-}
${call parserTables-}

	private static final String[] lapg_syms = new String[] {
${foreach s in parser.sym-}
		"${s.name}",
${end-}
	};

	public interface Tokens extends ${call package}.${opts.prefix}Lexer.@Lexems {
		// non-terminals
${for i in [parser.nterms, parser.nsyms-1]-}
		public static final int ${parser.sym[i].id->escapeJavaReserved()} = ${i};
${end-}
	}

	private static int lapg_next( int state, int symbol ) {
${if parser.nactions > 0-}
		int p;
		if( lapg_action[state] < -2 ) {
			for( p = - lapg_action[state] - 3; lapg_lalr[p] >= 0; p += 2 )
				if( lapg_lalr[p] == symbol ) break;
			return lapg_lalr[p+1];
		}
${end-}
		return lapg_action[state];
	}

	private static int lapg_state_sym( int state, int symbol ) {
		int min = lapg_sym_goto[symbol], max = lapg_sym_goto[symbol+1]-1;
		int i, e;

		while( min <= max ) {
			e = (min + max) >> 1;
			i = lapg_sym_from[e];
			if( i == state )
				return lapg_sym_to[e];
			else if( i < state )
				min = e + 1;
			else
				max = e - 1;
		}
		return -1;
	}

	private int lapg_head;
	private LapgSymbol[] lapg_m;
	private LapgSymbol lapg_n;

	${if syntax.input.length > 1}private Object${else}public ${if syntax.input.first()->type()}${syntax.input.first()->type()}${else}Object${end}${end} parse(${opts.prefix}Lexer lexer${if syntax.input.length > 1}, int state${end}) throws java.io.@IOException, ParseException {

		lapg_m = new LapgSymbol[${opts.stack}];
		lapg_head = 0;
${if syntax.error}		int lapg_symbols_ok = 4;
${end-}

		lapg_m[0] = new LapgSymbol();
		lapg_m[0].state = ${syntax.input.length > 1 ? 'state' : 0};
		lapg_n = lexer.next();

		while( lapg_m[lapg_head].state != ${syntax.input.length > 1 ? (parser.nstates - syntax.input.length) + '+state' : parser.nstates-1} ) {
			int lapg_i = lapg_next( lapg_m[lapg_head].state, lapg_n.lexem );

			if( lapg_i >= 0 ) {
				reduce(lapg_i);
			} else if( lapg_i == -1 ) {
				shift(lexer);
${if syntax.error}				lapg_symbols_ok++;
${end-}
			}

			if( lapg_i == -2 || lapg_m[lapg_head].state == -1 ) {
${if syntax.error-}
				if (lapg_n.lexem == 0) {
					break;
				}
				while (lapg_head >= 0 && lapg_state_sym( lapg_m[lapg_head].state, ${syntax.error.index} ) == -1) {
					lapg_m[lapg_head] = null; // TODO dispose?
					lapg_head--;
				}
				if (lapg_head >= 0) {
					lapg_m[++lapg_head] = new LapgSymbol();
					lapg_m[lapg_head].lexem = ${syntax.error.index};
					lapg_m[lapg_head].sym = null;
					lapg_m[lapg_head].state = lapg_state_sym( lapg_m[lapg_head-1].state, ${syntax.error.index} );
${if opts.positions.contains('line')-}
					lapg_m[lapg_head].line = lapg_n.line;
${end-}
${if opts.positions.contains('column')-}
					lapg_m[lapg_head].column = lapg_n.column;
${end-}
${if opts.positions.contains('offset')-}
					lapg_m[lapg_head].offset = lapg_n.offset;
${end-}
${if opts.endpositions.contains('line')-}
					lapg_m[lapg_head].endline = lapg_n.endline;
${end-}
${if opts.endpositions.contains('column')-}
					lapg_m[lapg_head].endcolumn = lapg_n.endcolumn;
${end-}
${if opts.endpositions.contains('offset')-}
					lapg_m[lapg_head].endoffset = lapg_n.endoffset;
${end-}
					if( lapg_symbols_ok >= 4 ) {
${if opts.positions.contains('column')-}
						reporter.error(${call err_location('lapg_n')}lexer.getTokenLine(), java.text.@MessageFormat.format("syntax error before line {0}, column {1}", lexer.getTokenLine(), lapg_n.column));
${else-}
						reporter.error(${call err_location('lapg_n')}lexer.getTokenLine(), java.text.@MessageFormat.format("syntax error before line {0}", lexer.getTokenLine()));
${end-}
					}
					if( lapg_symbols_ok <= 1 ) {
						lapg_n = lexer.next();
					}
					lapg_symbols_ok = 0;
					continue;
				} else {
					lapg_head = 0;
					lapg_m[0] = new LapgSymbol();
					lapg_m[0].state = ${syntax.input.length > 1 ? 'state' : 0};
				}
${end-}
				break;
			}
		}

		if( lapg_m[lapg_head].state != ${syntax.input.length > 1 ? (parser.nstates - syntax.input.length) + '+state' : parser.nstates-1} ) {
${if syntax.error-}
			if(lapg_symbols_ok >= 4) {
	${else-}
${end}			reporter.error(${call err_location('lapg_n')}lexer.getTokenLine(), java.text.@MessageFormat.format("syntax error before line {0}${if opts.positions.contains('column')}, column {1}${end}", lexer.getTokenLine()${if opts.positions.contains('column')}, lapg_n.column${end}));
${if syntax.error-}
			}
${end-}
			throw new ParseException();
		};
		return ${if syntax.input.length == 1 && syntax.input.first()->type()}(${syntax.input.first()->type()})${end}lapg_m[lapg_head-1].sym;
	}

	private void shift(${opts.prefix}Lexer lexer) throws java.io.@IOException {
		lapg_m[++lapg_head] = lapg_n;
		lapg_m[lapg_head].state = lapg_state_sym( lapg_m[lapg_head-1].state, lapg_n.lexem );
		if( DEBUG_SYNTAX ) {
			System.out.println(java.text.@MessageFormat.format( "shift: {0} ({1})", lapg_syms[lapg_n.lexem], lexer.current()));
		}
		if( lapg_m[lapg_head].state != -1 && lapg_n.lexem != 0 ) {
			lapg_n = lexer.next();
		}
	}

	@SuppressWarnings("unchecked")
	private void reduce(int rule) {
		LapgSymbol lapg_gg = new LapgSymbol();
		lapg_gg.sym = (lapg_rlen[rule]!=0)?lapg_m[lapg_head+1-lapg_rlen[rule]].sym:null;
		lapg_gg.lexem = lapg_rlex[rule];
		lapg_gg.state = 0;
		if( DEBUG_SYNTAX ) {
			System.out.println( "reduce to " + lapg_syms[lapg_rlex[rule]] );
		}
${if opts.positions.contains('line') || opts.positions.contains('offset') || opts.positions.contains('column')-}
		LapgSymbol startsym = (lapg_rlen[rule]!=0)?lapg_m[lapg_head+1-lapg_rlen[rule]]:lapg_n;
${if opts.positions.contains('line')-}
		lapg_gg.line = startsym.line;
${end-}
${if opts.positions.contains('column')-}
		lapg_gg.column = startsym.column;
${end-}
${if opts.positions.contains('offset')-}
		lapg_gg.offset = startsym.offset;
${end-}
${end-}
${if opts.endpositions.contains('line')-}
		lapg_gg.endline = (lapg_rlen[rule]!=0)?lapg_m[lapg_head].endline:lapg_n.line;
${end-}
${if opts.endpositions.contains('column')-}
		lapg_gg.endcolumn = (lapg_rlen[rule]!=0)?lapg_m[lapg_head].endcolumn:lapg_n.column;
${end-}
${if opts.endpositions.contains('offset')-}
		lapg_gg.endoffset = (lapg_rlen[rule]!=0)?lapg_m[lapg_head].endoffset:lapg_n.offset;
${end-}
${if syntax.hasActions() || opts.genast == 'on'-}
		switch( rule ) {
${foreach rule in syntax.rules-}
${if rule.getAction() || opts.genast == 'on' && self->java_ast.astcode(rule)-}
			case ${rule.getIndex()}:  // ${rule}
${if rule.getAction()-}			
				${call parserAction for rule-}
${if opts.breaks == 'on'}				break;$/
${else-}
				${call astAction(self->java_ast.astcode(rule)) for rule-}
				break;
${end-}
${end-}
${end-}
		}
${end-}
		for( int e = lapg_rlen[rule]; e > 0; e-- ) { 
			lapg_m[lapg_head--] = null;
		}
		lapg_m[++lapg_head] = lapg_gg;
		lapg_m[lapg_head].state = lapg_state_sym(lapg_m[lapg_head-1].state, lapg_gg.lexem);
	}
${if syntax.input.length > 1-}
${foreach inp in syntax.input}
	public ${if inp->type()}${inp->type()}${else}Object${end} parse${util.toFirstUpper(inp.id)}(${opts.prefix}Lexer lexer) throws java.io.@IOException, ParseException {
		return ${if inp->type()}(${inp->type()}) ${end}parse(lexer, ${index});
	}
${end-}
${end-}
}
${end} 

${template parserTables-}
${call parserTable(parser.action_index,'int','lapg_action','LapgAction')-}

${if parser.nactions > 0-}
${call parserTable(parser.action_table,'short','lapg_lalr','LapgLalr')}
${end-}
${call parserTable(parser.sym_goto,'short','lapg_sym_goto','LapgSymGoto')-}

${call parserTable(parser.sym_from,'short','lapg_sym_from','LapgSymFrom')-}

${call parserTable(parser.sym_to,'short','lapg_sym_to','LapgSymTo')-}

${call parserTable(parser.ruleLength,'short','lapg_rlen','LapgRLen')-}

${call parserTable(parser.rleft,'short','lapg_rlex','LapgRLex')-}
${end}


${template parserTable(arr,atype,name,cname)-}
${if opts.packTables == 'true'-}
	public interface ${cname} {
		public static final ${atype} ${name}[] = {
			${util.format(arr, 16, 3)}
		};
	};
	private static final ${atype}[] ${name} = ${cname}.${name};
${else-}
	private static final ${atype} ${name}[] = {
		${util.format(arr, 16, 2)}
	};
${end-}
${end}

${template parserAction-}
${eval getAction(), '[action in '+getAction().getLocation()+']'}
${end}

${template astAction(code)-}
${eval code, '[generated action for '+self+']'-}
${end}

${template getsym-}
${if self.isLeft}lapg_gg${else}lapg_m[lapg_head-${self.rightOffset}]${end-}
${end}

${template symbol-}
${if symbol->type()-}
((${symbol->type()})${call getsym-}.sym)${else-}
${call getsym-}.sym${end-}
${end}

${template sym_line-}
${call getsym}.line${end}

${template sym_column-}
${call getsym}.column${end}

${template sym_offset-}
${call getsym}.offset${end}

${template sym_endline-}
${call getsym}.endline${end}

${template sym_endcolumn-}
${call getsym}.endcolumn${end}

${template sym_endoffset-}
${call getsym}.endoffset${end}

${template err_location(var)-}
${if opts.positions.contains('offset')}${var}.offset, ${end-} 
${if opts.endpositions.contains('offset')}${var}.endoffset, ${end-} 
${end}

${template err_parameters(fqn)-}
${if opts.positions.contains('offset')}int start, ${end-} 
${if opts.endpositions.contains('offset')}int end, ${end-} 
int line, ${end}

${template imports-}
${end}

${template classcode-}
private static final boolean DEBUG_SYNTAX = false;
${end}

${template parseException-}
	public static class ParseException extends Exception {
		private static final long serialVersionUID = 1L;

		public ParseException() {
		}
	}
${end}

${query package() = opts.package ? opts.package : 'com.test' }

${cached query type() = context.opts.genast == 'on' ? context->ast.getType(self) : self.type }


${query escapeJavaReserved() =
	['String', 'Integer', 'Long', 'Boolean', 'LinkedHashMap', 'HashMap', 'Map',
	 'List', 'ArrayList', 'LinkedList', 'TextSource'].contains(self) ? '_' + self : self }
