${template main-}
// @target

package ${opts.namespace};

@nativecode

public class ${opts.class} {
	@nativecodeall

${if opts.positioning != 'none'}
	public class lapg_place {
${switch opts.positioning}
${case 'line'}		public int line;
${case 'full'}		public int line, column;
${case 'offset'}		public int line, offset;
${end-}

${switch opts.positioning}
${case 'line'}		public lapg_place( int line ) {
${case 'full'}		public lapg_place( int line, int column ) {
${case 'offset'}		public lapg_place( int line, int offset ) {
${end-}
			this.line = line;
${switch opts.positioning}
${case 'full'}			this.column = column;
${case 'offset'}			this.offset = offset;
${end-}
		}
	};
${end}

	public class lapg_symbol {
		public Object sym;
		public int  lexem, state;
${if opts.positioning != 'none'}		public lapg_place pos;$/
${if opts.lexemend == 'on'}		public lapg_place endpos;$/
	};

	private static final short[] lapg_char2no = new short[] {
		@char2no
	};

	private static final short[][] lapg_lexem = new short[][] {
		@lexem
	};

	private static final int[] lapg_action = new int[] {
		@action
	};

${if parser.nactions > 0}
	private static final short[] lapg_lalr = new short[] {
		${format(parser.action_table, 16, 2)}
	};
${end}

	private static final short[] lapg_sym_goto = new short[] {
		@sym_goto
	};

	private static final short[] lapg_sym_from = new short[] {
		@sym_from
	};

	private static final short[] lapg_sym_to = new short[] {
		@sym_to
	};

	private static final short[] lapg_rlen = new short[] {
		@rlen
	};

	private static final short[] lapg_rlex = new short[] {
		@rlex
	};

	private static final String[] lapg_syms = new String[] {
		@syms
	};

	public enum Tokens {
		@tokenenum
	}

	private static int lapg_next( int state, int symbol ) {
${if parser.nactions > 0-}
		int p;
		if( lapg_action[state] < -2 ) {
			for( p = - lapg_action[state] - 3; lapg_lalr[p] >= 0; p += 2 )
				if( lapg_lalr[p] == symbol ) break;
			return lapg_lalr[p+1];
		}
${end-}
		return lapg_action[state];
	}

	private static int lapg_state_sym( int state, int symbol ) {
		int min = lapg_sym_goto[symbol], max = lapg_sym_goto[symbol+1]-1;
		int i, e;

		while( min <= max ) {
			e = (min + max) >> 1;
			i = lapg_sym_from[e];
			if( i == state )
				return lapg_sym_to[e];
			else if( i < state )
				min = e + 1;
			else
				max = e - 1;
		}
		return -1;
	}

	public boolean parse() {

		byte[]        token = new byte[@maxtoken];
		int           lapg_head = 0, group = 0, lapg_i, lapg_size, chr;
		lapg_symbol[] lapg_m = new lapg_symbol[@maxstack];
		lapg_symbol   lapg_n;
${switch opts.positioning}
${case 'line'}		int           lapg_current_line = 1;
${case 'full'}		int           lapg_current_line = 1, lapg_current_column = 1;
${case 'offset'}		int           lapg_current_line = 1, lapg_current_offset = 0;
${end-}
${if parser.hasError()}		int           lapg_symbols_ok = 4;$/

		lapg_m[0] = new lapg_symbol();
		lapg_m[0].state = 0;
		${opts.getsym};

${if parser.hasError()}		NEXTTOKEN:$/
		do {
			lapg_n = new lapg_symbol();
${switch opts.positioning}
${case 'line'}			lapg_n.pos = new lapg_place( lapg_current_line );
${case 'full'}			lapg_n.pos = new lapg_place( lapg_current_line, lapg_current_column );
${case 'offset'}			lapg_n.pos = new lapg_place( lapg_current_line, lapg_current_offset );
${end-}
			for( lapg_size = 0, lapg_i = group; lapg_i >= 0; ) {
				if( lapg_size < @maxtoken-1 ) token[lapg_size++] = (byte)chr;
				lapg_i = lapg_lexem[lapg_i][lapg_char2no[(chr+256)%256]];
				if( lapg_i >= -1 && chr != 0 ) { 
${switch opts.positioning}
${case 'line'}					if( chr == '\n' ) lapg_current_line++;
${case 'full'}					lapg_current_column++;
${case 'full'}					if( chr == '\n' ) { lapg_current_column = 1; lapg_current_line++; }
${case 'offset'}					lapg_current_offset++;
${case 'offset'}					if( chr == '\n' ) lapg_current_line++;
${end-}
					${opts.getsym};
				}
			}
${if opts.lexemend == 'on'-}
${switch opts.positioning}
${case 'line'}			lapg_n.endpos = new lapg_place( lapg_current_line );
${case 'full'}			lapg_n.endpos = new lapg_place( lapg_current_line, lapg_current_column );
${case 'offset'}			lapg_n.endpos = new lapg_place( lapg_current_line, lapg_current_offset );
${end-}
${end-}

			if( lapg_i == -1 ) {
				if( chr == 0 ) {
					error(@errprefix "Unexpected end of file reached");
					break;
				}
${switch opts.positioning}
${case 'none'}				error(@errprefix MessageFormat.format( "invalid lexem: `{0}`, skipped", new String(token,0,lapg_size) ) );
${case 'line'}				error(@errprefix MessageFormat.format( "invalid lexem at line {0}: `{1}`, skipped", lapg_n.pos.line, new String(token,0,lapg_size) ) );
${case 'full'}				error(@errprefix MessageFormat.format( "invalid lexem at line {0}, column {1}: `{2}`, skipped", lapg_n.pos.line, lapg_n.pos.column, new String(token,0,lapg_size) ) );
${case 'offset'}				error(@errprefix MessageFormat.format( "invalid lexem at line {0}: `{1}`, skipped", lapg_n.pos.line, new String(token,0,lapg_size) ) );
${end-}
				lapg_n.lexem = -1;
				continue;
			}

			lapg_size--;
			lapg_n.lexem = -lapg_i-2;
			lapg_n.sym = null;

${if lex.hasActions()-}
			switch( lapg_n.lexem ) {
${foreach action in lex.actions-}
${if action-}
				case $index:
					$action
${end-}
${end-}
			}
${end-}

${if parser.hasError()}			SKIPNEXTTOKEN: for(;;) {$/

			do {
				lapg_i = lapg_next( lapg_m[lapg_head].state, lapg_n.lexem );

				if( lapg_i >= 0 ) {
					lapg_symbol lapg_gg = new lapg_symbol();
					lapg_gg.sym = (lapg_rlen[lapg_i]!=0)?lapg_m[lapg_head+1-lapg_rlen[lapg_i]].sym:null;
					lapg_gg.lexem = lapg_rlex[lapg_i];
					lapg_gg.state = 0;
					if( DEBUG_SYNTAX )
						System.out.println( "reduce to " + lapg_syms[lapg_rlex[lapg_i]] );
${if opts.positioning != 'none'}					lapg_gg.pos = (lapg_rlen[lapg_i]!=0)?lapg_m[lapg_head+1-lapg_rlen[lapg_i]].pos:lapg_n.pos;$/
${if opts.lexemend == 'on'}					lapg_gg.endpos = (lapg_rlen[lapg_i]!=0)?lapg_m[lapg_head].endpos:lapg_n.pos;$/
${if parser.hasActions()-}
					switch( lapg_i ) {
${foreach action in parser.raction-}
${if action-}
						case $index:
							$action
${if opts.breaks == 'on'}							break;$/
${end-}
${end-}
					}
${end-}
					for( int e = lapg_rlen[lapg_i]; e > 0; e-- ) 
						lapg_m[lapg_head--] = null;
					lapg_m[++lapg_head] = lapg_gg;
					lapg_m[lapg_head].state = lapg_state_sym( lapg_m[lapg_head-1].state, lapg_gg.lexem );
				} else if( lapg_i == -1 ) {
					lapg_m[++lapg_head] = lapg_n;
					lapg_m[lapg_head].state = lapg_state_sym( lapg_m[lapg_head-1].state, lapg_n.lexem );
${if parser.hasError()}					lapg_symbols_ok++;$/
					if( DEBUG_SYNTAX )
						System.out.println( MessageFormat.format( "shift: {0} ({1})", lapg_syms[lapg_n.lexem], new String(token,0,lapg_size) ) );
				}

			} while( lapg_i >= 0 && lapg_m[lapg_head].state != -1 );

			if( (lapg_i == -2 || lapg_m[lapg_head].state == -1) && lapg_n.lexem != 0 ) {
${if parser.hasError()-}
				while( lapg_head >= 0 && lapg_state_sym( lapg_m[lapg_head].state, @error ) == -1 ) {
					lapg_m[lapg_head] = null;
					lapg_head--;
				}
				if( lapg_head >= 0 ) {
					lapg_m[++lapg_head] = new lapg_symbol();
					lapg_m[lapg_head].lexem = @error;
					lapg_m[lapg_head].sym = null;
					lapg_m[lapg_head].state = lapg_state_sym( lapg_m[lapg_head-1].state, @error );
${if opts.positioning != 'none'-}
					lapg_m[lapg_head].pos = lapg_n.pos;
${end-}
					if( lapg_symbols_ok >= 4 )
${switch opts.positioning}
${case 'none'}						error(@errprefix "syntax error" );
${case 'line'}						error(@errprefix MessageFormat.format( "syntax error before line {0}", lapg_n.pos.line ) );
${case 'full'}						error(@errprefix MessageFormat.format( "syntax error before line {0}, column {1}", lapg_n.pos.line, lapg_n.pos.column ) );
${case 'offset'}						error(@errprefix MessageFormat.format( "syntax error before line {0}", lapg_n.pos.line ) );
${end}
					lapg_i = lapg_symbols_ok;
					lapg_symbols_ok = 0;
					if( lapg_i > 1 )
						continue SKIPNEXTTOKEN;
					else
						continue NEXTTOKEN;
				} else {
					lapg_head = 0;
					lapg_m[0] = new lapg_symbol();
					lapg_m[0].state = 0;
				}
${end-}
				break;
			}
${if parser.hasError()-}
			break;
			}
${end-}

		} while( lapg_n.lexem != 0 );

${if parser.hasError()-}
		if( lapg_m[lapg_head].state != @nstates-1 && lapg_symbols_ok >= 4 ) {
${else-}
		if( lapg_m[lapg_head].state != @nstates-1 ) {
${end-}
${switch opts.positioning}
${case 'none'}			error(@errprefix "syntax error" );
${case 'line'}			error(@errprefix MessageFormat.format( "syntax error before line {0}", lapg_n.pos.line ) );
${case 'full'}			error(@errprefix MessageFormat.format( "syntax error before line {0}, column {1}", lapg_n.pos.line, lapg_n.pos.column ) );
${case 'offset'}			error(@errprefix MessageFormat.format( "syntax error before line {0}", lapg_n.pos.line ) );
${end-}
			return false;
		};
		return true;
	}
}

${end} 
