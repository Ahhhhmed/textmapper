
${template unit-}
${call astBaseInterface-}
${call astBaseClass-}
${foreach psym in syntax.symbols.select(x|!x.isTerm() && !self->isOptional(x))-}
${switch self->symbolKind(psym)-}
${case 'enum'}${call astEnum(psym)-}
${case 'interface'}${call astInterface(psym)-}
${else}${call astClass(psym)-}
${end-}
${end-}
${end}


${template astInterface(psym)-}
${file 'ast/' + psym->interfaceName() + '.java'-}
package ${call java.package}.ast;

public interface ${psym->interfaceName()} {

${foreach rule in self->interfaceRules()-}
// $rule (${self->intListRuleKind(rule)})
${end-}
	
}
${end-}
${end}


${template astClass(psym)-}
${file 'ast/' + psym->className() + '.java'-}
package ${call java.package}.ast;

public class ${psym->className()} {

${foreach rule in self->rules(psym)-}
// $rule (${self->intListRuleKind(rule)})
${end-}
	
}
${end-}
${end}


${template astEnum(psym)-}
${file 'ast/' + psym->className() + '.java'-}
package ${call java.package}.ast;

public enum ${psym->className()} {	
${foreach rule in self->rules(psym)-}
	${rule.getRight().first().target.name.toUpperCase()},
${end-}
}
${end-}
${end}


${template astBaseInterface-}
${file 'ast/I' + opts.astprefix + 'Node.java'-}
package ${call java.package}.ast;

public interface I${opts.astprefix}Node {
	int getOffset();
	int getEndOffset();
	${call java.package}.${opts.prefix}Tree.@TextSource getInput();
	//void accept(Visitor v);
}
${end-}
${end}


${template astBaseClass-}
${file 'ast/' + opts.astprefix + 'Node.java'-}
package ${call java.package}.ast;

public abstract class ${opts.astprefix}Node implements I${opts.astprefix}Node {
	
	protected ${call java.package}.${opts.prefix}Tree.@TextSource fInput;
	protected int fStart;
	protected int fEnd;

	public ${opts.astprefix}Node(${call java.package}.${opts.prefix}Tree.@TextSource input, int start, int end) {
		this.fStart = start;
		this.fEnd = end;
		this.fInput = input;
	}

	public int getOffset() {
		return fStart;
	}

	public int getEndOffset() {
		return fEnd;
	}

	public ${call java.package}.${opts.prefix}Tree.@TextSource getInput() {
		return fInput;
	}

	public String toString() {
		return fInput == null ? "" : fInput.getText(fStart, fEnd);
	}

	//public abstract void accept(Visitor v);
}

${end-}
${end}



${cached query symbolKind(sym) =
	self->isEnum(sym) ? 'enum' :
	self->isLeftList(sym) ? 'leftlist' :
	self->isRightList(sym) ? 'rightlist' :
	self->isInterface(sym) ? 'interface' : 'class'}

${cached query symrules = syntax.rulesBySymbol}

${cached query rules(sym) = self->symrules()[sym].select(x|x.getLeft() == sym) }

${cached query isInterface(sym) = self->rules(sym).
	forAll(x|x.getRight().length == 1 && !x.getRight().first().target.isTerm())}

${cached query isEnum(sym) = self->rules(sym).
	forAll(x|x.getRight().length == 1 && x.getRight().first().target->isSimpleTerm())}
	
${query isSimpleTerm() = self.isTerm() && !self.type}

${cached query isOptional(sym) = self->rules(sym).size() == 2 &&
	self->rules(sym).collect(x|x.getRight().length)->containsBothOnly(0,1)}

${cached query isLeftList(sym) = self->rules(sym).
	collect(x|self->intListRuleKind(x))->containsBothOnly('leftrec', 'normal')}

${cached query isRightList(sym) = self->rules(sym).
	collect(x|self->intListRuleKind(x))->containsBothOnly('rightrec', 'normal')}
	
${cached query className() = 
	util.uniqueId(util.toCamelCase(self.name, true)->escapeJavaReserved(), '__classes__')}

${cached query interfaceName() = 
	util.uniqueId('I' + util.toCamelCase(self.name, true)->escapeJavaReserved(), '__classes__')}

${cached query intListRuleKind(rule) = 
	rule.getRight().length == 0 
		? 'empty'
		: (rule.getRight().select(x|x.target == rule.getLeft()).size() == 1
			? (rule.getRight().first().target == rule.getLeft() 
				? 'leftrec'
				: (rule.getRight().last().target == rule.getLeft()
					? 'rightrec'
					: 'unknown'
				  )
			  )
			: (rule.getRight().select(x|x.target == rule.getLeft()).size() == 0
				? 'normal'
				: 'unknown'
			  )	
		  )
}

${query containsBothOnly(x,y) = 
	self.contains(x) && self.contains(y) && self.forAll(q|q==x || q==y)}

${query escapeJavaReserved() = 
	['String', 'Integer', 'Long', 'Boolean', 'LinkedHashMap', 'HashMap', 'Map',
	 'List', 'ArrayList', 'LinkedList', 'TextSource'].contains(self) ? '_' + self : self }

${cached query interfaceRules() = syntax.rules.select(x|self->isInterface(x.getLeft()))}

