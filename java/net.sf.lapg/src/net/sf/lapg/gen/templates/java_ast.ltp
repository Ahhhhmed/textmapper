${template unit-}
${call astBaseInterface-}
${call astBaseClass-}
${foreach cl in self->ast.allClasses()-}
${self->('ast_' + cl.kind)(cl)} 
${end-}
${end}


${query escapeJavaReserved() = 
	['String', 'Integer', 'Long', 'Boolean', 'LinkedHashMap', 'HashMap', 'Map',
	 'List', 'ArrayList', 'LinkedList', 'TextSource'].contains(self) ? '_' + self : self }


${template implementedInterfaces(cl, prefix)-}
${if cl.implements.length > 0-}
${prefix}${foreach impl in cl.implements.collect(x|self->ast.getClasses(x))}${if index > 0}, ${end}${self->objectType(impl)}${end-}
${end-}
${end}




${cached query interfaceName() = 
	util.uniqueId('I' + util.toCamelCase(self.name, true)->escapeJavaReserved(), '__classes__')}
	
${template ast_interface(cl)-}
${file 'ast/' + cl->interfaceName() + '.java'-}
package ${call java.package}.ast;

public interface ${cl->interfaceName()}${call implementedInterfaces(cl,' extends ')} {
}
${end-}
${end}




${cached query className() = 
	util.uniqueId(util.toCamelCase(self.name, true)->escapeJavaReserved(), '__classes__')}

${cached query propertyName() = 
	util.uniqueId(util.toCamelCase(self.name, false)->escapeJavaReserved(), '__prop__' + self.container.name)}

${template ast_class(cl)-}
${file 'ast/' + cl->className() + '.java'-}
package ${call java.package}.ast;

public class ${cl->className()} extends ${opts.astprefix}Node${call implementedInterfaces(cl,' implements ')} {

${foreach prop in self->ast.getProperties(cl)-}
	private ${prop.type} ${prop->propertyName()};
${end-}

	public ${cl->className()}(${foreach prop in self->ast.getProperties(cl)}${prop.type} ${prop->propertyName()}, ${end}${call java.package}.${opts.prefix}Tree.@TextSource input, int start, int end) {
		super(input, start, end);
${foreach prop in self->ast.getProperties(cl)-}
		this.${prop->propertyName()} = ${prop->propertyName()};
${end-}
	}

${foreach prop in self->ast.getProperties(cl)-}
	public ${prop.type} get${util.toCamelCase(prop->propertyName(), true)}() {
		return ${prop->propertyName()};
	}
${end-}	
}
${end-}
${end}




${cached query enumLiteralName(enumname) = 
	util.uniqueId((alias ? alias : target.name).toUpperCase()->escapeJavaReserved(), '__classes__'+enumname)}

${template ast_enum(cl)-}
${file 'ast/' + cl->className() + '.java'-}
package ${call java.package}.ast;

public enum ${cl->className()} {	
${foreach const in cl.literals-}
	${const->enumLiteralName(cl->className())},
${end-}
}
${end-}
${end}




${template astBaseInterface-}
${file 'ast/I' + opts.astprefix + 'Node.java'-}
package ${call java.package}.ast;

public interface I${opts.astprefix}Node {
	int getOffset();
	int getEndOffset();
	${call java.package}.${opts.prefix}Tree.@TextSource getInput();
	//void accept(Visitor v);
}
${end-}
${end}




${template astBaseClass-}
${file 'ast/' + opts.astprefix + 'Node.java'-}
package ${call java.package}.ast;

public abstract class ${opts.astprefix}Node implements I${opts.astprefix}Node {
	
	protected ${call java.package}.${opts.prefix}Tree.@TextSource fInput;
	protected int fStart;
	protected int fEnd;

	public ${opts.astprefix}Node(${call java.package}.${opts.prefix}Tree.@TextSource input, int start, int end) {
		this.fStart = start;
		this.fEnd = end;
		this.fInput = input;
	}

	public int getOffset() {
		return fStart;
	}

	public int getEndOffset() {
		return fEnd;
	}

	public ${call java.package}.${opts.prefix}Tree.@TextSource getInput() {
		return fInput;
	}

	public String toString() {
		return fInput == null ? "" : fInput.getText(fStart, fEnd);
	}

	//public abstract void accept(Visitor v);
}

${end-}
${end}


${query getClass(rule) = self->ast.getClasses(rule.getLeft())}

${template createEnum(rule)-}
${'$$'} = ${call java.package}.ast.@${self->getClass(rule)->className()}.${rule.getRight().first()->enumLiteralName(self->getClass(rule)->className())};
${end}

${template call_ctor(rule,props,cl)-}
${'$$'} = new ${call java.package}.ast.@${cl->className()}(
${foreach prop in props-}
${if self->ast.getPropertyIndex(prop,rule,cl) >= 0 -}
${'$'+ self->ast.getPropertyIndex(prop,rule,cl)} /* ${prop->propertyName()} */,
${else-}
null /* ${prop->propertyName()} */,
${end-}
${end-}
null /* input */, ${if rule.getRight().length == 0}${'$'}{left().offset}, ${'$'}{left().endoffset}${else}${'$'}{first().offset}, ${'$'}{last().endoffset}${end});
${end}

${template createClass(rule)-}
${call call_ctor(rule, self->ast.getProperties(self->getClass(rule)), self->getClass(rule))-} 
${end}

${cached query astcode(rule) =
	self->ast.isEnum(rule.getLeft()) ? self->createEnum(rule) :
	self->ast.isOptional(rule.getLeft()) ? null :
	self->ast.symbolKind(rule.getLeft()) == 'class' ? self->createClass(rule) : 
	null 
}


${query objectType(cl) = 
	self->java.package() + '.ast.@' + (
		cl.kind == 'interface' 
			? cl->interfaceName()
			: cl->className() 
	)}

${query listType(type) = 'java.util.@List<' + type + '>'}
