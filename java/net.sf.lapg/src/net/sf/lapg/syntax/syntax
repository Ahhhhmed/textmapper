#   syntax: lalr1 generator source grammar
#
#   Lapg (Lexical Analyzer and Parser Generator)
#   Copyright (C) 2002-06  Evgeny Gryaznov (inspirer@inbox.ru)
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

.lang        "java" 
.getsym      "chr = buff[l++];if( l == end ) fillb()"
.positioning "full"
.class       "Parser"
.namespace	 "net.sf.lapg.syntax"
.maxtoken    4096
.stack       512

# Vocabulary

id(String):     /[a-zA-Z_][a-zA-Z_0-9]*|'[^']+'/  { @ = new String(token,0,lapg_size); break; }
regexp(String): /\/([^\/\\]|\\.)*\//              { @ = new String(token,1,lapg_size-2); break; }
cmd1(String):   /\\.*/           { @ = new String(token,1,lapg_size-1); break; }
cmd2(String):   /\n\t\t.*/       { @ = new String(token,3,lapg_size-3); break; }
cmd3(String):   /{[^{}\n]*}/     { @ = new String(token,1,lapg_size-2); break; }
str(String):    /"[^"\n]*"/      { @ = new String(token,1,lapg_size-2); break; }
type(String):   /\([^\)]+\)/     { @ = new String(token,1,lapg_size-2); break; }
Int(Integer):      /-?[0-9]+/       { @ = Integer.parseInt(new String(token,0,lapg_size)); break; }
eoi:           /\n%%.*/
'%':           /\n%/
_skip:         /\n|[\t\r ]+/    { continue; }
_skip:         /\n\t/
_skip:  /#.*/
'=':    /=/
'::=':  /::=/
'|':    /\|/
';':    /;/
'.':    /\./
':':    /:/
'::':   /::/
'->':   /->/
',':    /,/
'[':    /\[/
']':    /\]/
'<<':   /<</

# Attributes

[ idlist ]

# Grammar

input ::= 
	directives lexical_part magazine_def grammar_part ;

cmdx(String) ::= cmd1 | cmd2 { @$.line++; } | cmd3 ;

cmd (String) ::
  = cmdx
		$$ = concat( null, $cmdx, sourcename, @0.line );
  = cmd cmdx
		$$ = concat( $cmd, $cmdx, sourcename, (@0.line+1!=@1.line)?@1.line:-1 );
		@$ = @1;
;

directives ::= directives directive | directive ;

directive ::
  = '.' id str
		dc.process_directive( $id, $str, @0.line, @0.column );

  = '.' id Int
		dc.process_directive( $id, $Int, @0.line, @0.column );
;

lexical_part ::= newtypelexemopt lexemdef | lexical_part newtypelexemopt lexemdef ;

int32(Integer) ::= Int { if( $Int < 0 || $Int >= BITS ) $$ = 0; else $$ = 1 << $Int; } ;
int32_list(Integer) ::= int32 | int32_list int32 { $$ = $int32_list | $int32; } ;
newtypelexem ::= '[' int32_list ']' { dc.currentgroups = $int32_list; } ;

lexemdef ::
  = id ':'
		dc.terminal($id, null);

  = id type ':'
		dc.terminal($id,$type);

  = id ':' regexp Intopt cmd
		dc.lexem( dc.terminal($id, null), $regexp, $id, $cmd, $Intopt );

  = id ':' regexp Intopt
		dc.lexem( dc.terminal($id, null), $regexp, $id, null, $Intopt );

  = id type ':' regexp Intopt cmd
		dc.lexem( dc.terminal($id, $type), $regexp, $id, $cmd, $Intopt );

  = id type ':' regexp Intopt
		dc.lexem( dc.terminal($id, $type), $regexp, $id, null, $Intopt );
;

magazine_def ::= '[' magazine_def_listopt ']' ;
magazine_def_list ::= magazine_def_list ',' attrib | attrib ;

attrib ::
  = id '->' id
		dc.nonterm( $id#1, 0, null, dc.nonterm( $id#0, 0 ) );
  = id
		dc.nonterm( $id, 0, null, -1 );
;

grammar_part ::= ruledef | grammar_part ruledef ;
ruledef ::= 
	def_rule_for '::=' rules_or ';' | 
	def_rule_for '::' rules_eq ';'  | 
	def_rule_for '[' rules_eq ']'   | 
	prioritydef ;

rules_or ::= 
	rules_or '|' stdrule | 
	stdrule ;

rules_eq ::= 
	rules_eq '=' stdrule | 
	'=' stdrule ;

prioritydef ::=
	'%' id
		if( $id.equals("left")) $$ = 1;
		else if( $id.equals("right")) $$ = 2;
		else if( $id.equals("nonassoc")) $$ = 3;
		else { error("wrong priority declaration: %" + $id);$$ = 0; }
	idlist ';' ;

idlist(Integer) ::= id { dc.addprio($id,$#,false); } | idlist id { dc.addprio($id,$#,true); } ;

rule_priority(Integer) ::=
	'<<' id { $$ = dc.nonterm( $id, 0 ); } |
	{ $$ = -1; } ;

stdrule ::
  = ids rule_priority cmd
		dc.rule( length, $rule_priority, $cmd, rule, @$.line );

  = ids rule_priority
		dc.rule( length, $rule_priority, null, rule, @$.line );

  = cmd rule_priority
		dc.rule( 0, $rule_priority, $cmd, rule, @$.line );

  = rule_priority
		dc.rule( 0, $rule_priority, null, rule, @$.line );
;

ids ::
  = ids rule_priority cmdopt id          # rule_priority must not be here
		if( $cmdopt != null ) {
			length += 2;
			rule[length] = dc.nonterm( $id, 0 );
			rule[length-1] = dc.nonterm( $id, 2, null, rule[length] );
			dc.rule( 0, -1, $cmdopt, new int[]{ rule[length-1] }, @1.line );
		} else rule[++length] = dc.nonterm( $id, 0 );

  = cmdopt id
		length = 0;
		if( $cmdopt != null) {
			length += 2;
			rule[length] = dc.nonterm( $id, 0 );
			rule[length-1] = dc.nonterm( $id, 2, null, rule[length] );
			dc.rule( 0, -1, $cmdopt, new int[]{ rule[length-1] }, @0.line );
		} else rule[++length] = dc.nonterm( $id, 0 );
;

def_rule_for ::
  = id
		rule[0] = dc.nonterm( $id, 1 );

  = id type
		rule[0] = dc.nonterm( $id, 1, $type, -2 );
;

# EOF

%%
import java.io.IOException;
import java.io.InputStream;
import java.text.MessageFormat;

import net.sf.lapg.IError;
%%

private static final boolean DEBUG_SYNTAX = false;
private static final int BITS = 32;

byte[] buff = new byte[1025];
int l, end;
InputStream input;
IError err;
DescriptionCollector dc;

int length;
int[] rule = new int[128];

String sourcename;

private Parser( InputStream is, String sourceName, DescriptionCollector dc, IError err) {
	this.input = is;
	this.sourcename = sourceName;
	this.dc = dc;
	this.err = err;
}

static boolean parse( InputStream is, String sourceName, DescriptionCollector dc, IError err) {
	Parser p = new Parser(is, sourceName, dc, err);
	p.fillb();
	return p.parse();
}

String concat( String s1, String s2, String file, int line ) {
	if( s1 != null ) {
		if( line != -1 )
			return s1 + "\n#line "+line+" \""+file+"\"\n" + s2;
		else 
			return s1 + "\n" + s2;
	} else {
		return "#line "+line+" \""+file+"\"\n" + s2;
	}
}

void fillb() {
	l = 0;
	try {
		end = input.read( buff, 0, 1024 );
		if( end == -1 )
			end = 0;
	} catch( IOException ex ) {
		end = 0;
	}
	buff[end] = 0;
}

void error( String s ) {
	err.error(s);
}
