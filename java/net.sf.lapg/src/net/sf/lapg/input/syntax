#   syntax: lalr1 generator source grammar
#
#   Lapg (Lexical Analyzer and Parser Generator)
#   Copyright (C) 2002-06  Evgeny Gryaznov (inspirer@inbox.ru)
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

.lang        "java" 
.getsym      "chr = l < buff.length ? buff[l++] : 0"
.class       "Parser"
.namespace	 "net.sf.lapg.input"
.maxtoken    4096
.breaks		 "on"
.lexemend    "on"
.positioning "offset"

# Vocabulary

[0]

identifier(String):     /[a-zA-Z_][a-zA-Z_0-9]*|'[^'\n]+'/  { @ = new String(token,0,lapg_size); break; }
regexp(String):	/\/([^\/\\]|\\.)*\//	{ @ = new String(token,1,lapg_size-2); break; }
scon(String):	/"[^"\n\\]*"/			{ @ = new String(token,1,lapg_size-2); break; }
type(String):	/\([^\)\n]+\)/			{ @ = new String(token,1,lapg_size-2); break; }
icon(Integer):	/-?[0-9]+/				{ @ = Integer.parseInt(new String(token,0,lapg_size)); break; }
eoi:           /\n%%.*/
'%':           /\n%/
_skip:         /\n|[\t\r ]+/    		{ continue; }
_skip:  /#.*/
'::=':  /::=/
'|':    /\|/
';':    /;/
'.':    /\./
':':    /:/
'[':    /\[/
']':    /\]/
'<<':   /<</

'{':	/{/		{ deep = 1; group = @1; break; }

[1]

_skip:	/'([^\n\\']|\\(['"?\\abfnrtv]|x[0-9a-fA-F]+|[0-7]([0-7][0-7]?)?))*'/
_skip:	/"([^\n\\"]|\\(['"?\\abfnrtv]|x[0-9a-fA-F]+|[0-7]([0-7][0-7]?)?))*"/
_skip:	/[^'"{}]+/
'i{':	/{/				{ deep++; break; }
'}':	/}/				{ if( --deep == 0 ) group = @0; break; }

# Attributes

[]

# Grammar

input ::=
	directives
	lexical_definitions
	grammar_definitions ;

directives ::= 
	directives directive | directive ;

directive ::=
	'.' identifier scon 								{ options.add(new COption($identifier, $scon, @1.line)); }
	| '.' identifier icon								{ options.add(new COption($identifier, $icon, @1.line)); }
;

lexical_definitions ::= 
	lexical_definitions lexical_definition 
	| lexical_definition 
;

lexical_definition ::=
	'[' iconlist_in_bits ']'							{ currentgroups = $iconlist_in_bits; }
	| symbol typeopt ':'
	| symbol typeopt ':' regexp iconopt commandopt
;

iconlist_in_bits(Integer) ::=
	icon 												{ if( $icon < 0 || $icon >= BITS ) $$ = 0; else $$ = 1 << $icon; } 
	| iconlist_in_bits icon  							{ $$ = $iconlist_in_bits | $icon; }
;

grammar_definitions ::=
	grammar_definition | grammar_definitions grammar_definition ;

grammar_definition ::= 
	symbol typeopt '::=' rule_right_part ';'
	| '%' identifier symbol_list ';' 
; 

rule_right_part (List<CRule>) ::= 
	rule_right_part '|' rule_def
	| rule_def
;

symbol_list (List<CSymbol>) ::= 
	symbol_list symbol									{ $symbol_list.add($symbol); }
	| symbol 											{ $$ = new ArrayList<CSymbol>(); $symbol_list.add($symbol); }
;

rule_def (CRule) ::=
	rule_symbols commandopt rule_priorityopt
	| commandopt rule_priorityopt 
;

rule_symbols (List<CSymbol>) ::=
	rule_symbols commandopt symbol						{ buildRule($rule_symbols,$commandopt,$symbol); } 
	| commandopt symbol									{ $$ = new ArrayList<CSymbol>(); buildRule($rule_symbols,$commandopt,$symbol); }
;

rule_priority (CSymbol) ::=
	'<<' symbol											{ $$ = $symbol; } 
;

command (CAction) ::=
	'{' command_tokensopt '}'							{ $$ = new CAction(@0.line, rawData(@1.offset,@~1.offset)); }  
;
	
command_tokens ::=
	command_tokens command_token | command_token ;

command_token ::=
	'i{' command_tokensopt '}' 
;

symbol (CSymbol) ::=
	identifier											{ $$ = getSymbol($identifier); }
;

##################################################################################

%%
import java.io.UnsupportedEncodingException;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
%%

private Parser() {
}

private static final boolean DEBUG_SYNTAX = false;
private static final int BITS = 32;

private Map<String,CSymbol> symCash = new HashMap<String,CSymbol>();

private List<CSymbol> symbols = new ArrayList<CSymbol>();
private List<CRule> rules = new ArrayList<CRule>();
private List<CPrio> prios = new ArrayList<CPrio>();
private List<COption> options = new ArrayList<COption>();

private byte[] buff;
private int l;

private int currentgroups = 1;
private int deep = 0;

private String rawData(int start, int end) {
	return new String(buff, start, end-start);
}

private CSymbol getSymbol(String name) {
	CSymbol res = symCash.get(name);
	if( res == null ) {
		res = new CSymbol(name);
		symbols.add(res);
		symCash.put(name,res);
	}
	return res;
}

private void buildRule(List<CSymbol> list, CAction cmdopt, CSymbol symbol) {
	if( cmdopt != null ) {
		CSymbol sym = new CSymbol(null);
		symbols.add(sym);
		sym.addRules(Collections.singletonList(new CRule(null, cmdopt, null)));
		sym.setDefined(null, cmdopt.getLine());
		list.add(sym);
	}
	list.add(symbol);
}

void error( String s ) {
	System.err.println(s);
}

private CSyntax doParse(String s) {
	l = 0;
	try {
		buff = s.getBytes("utf-8");
	} catch( UnsupportedEncodingException ex ) {
		return null;
	}
	if( !parse() ) {
		return null;
	}
	
	return new CSyntax(symbols,rules,prios,options);
}

public static CSyntax process(String data) {
	Parser p = new Parser();
	return p.doParse(data);
}