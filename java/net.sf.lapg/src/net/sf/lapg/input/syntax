#   syntax: lalr1 generator source grammar
#
#   Lapg (Lexical Analyzer and Parser Generator)
#   Copyright (C) 2002-06  Evgeny Gryaznov (inspirer@inbox.ru)
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

.lang        "java" 
.getsym      "chr = buff[l++];if( l == end ) fillb()"
.positioning "full"
.class       "Parser"
.namespace	 "net.sf.lapg.input"
.maxtoken    4096
.stack       512

# Vocabulary

[0]

identifier(String):     /[a-zA-Z_][a-zA-Z_0-9]*|'[^'\n]+'/  { @ = new String(token,0,lapg_size); break; }
regexp(String):	/\/([^\/\\]|\\.)*\//	{ @ = new String(token,1,lapg_size-2); break; }
scon(String):	/"[^"\n\\]*"/			{ @ = new String(token,1,lapg_size-2); break; }
type(String):	/\([^\)\n]+\)/			{ @ = new String(token,1,lapg_size-2); break; }
icon(Integer):	/-?[0-9]+/				{ @ = Integer.parseInt(new String(token,0,lapg_size)); break; }
eoi:           /\n%%.*/
'%':           /\n%/
_skip:         /\n|[\t\r ]+/    		{ continue; }
_skip:  /#.*/
'::=':  /::=/
'|':    /\|/
';':    /;/
'.':    /\./
':':    /:/
'->':   /->/
',':    /,/
'[':    /\[/
']':    /\]/
'<<':   /<</

'{':	/{/		{ deep = 1; group = @1; break; }

[1]

any:	/[^'"{}]+/
ccon(String):	/'([^\n\\']|\\(['"?\\abfnrtv]|x[0-9a-fA-F]+|[0-7]([0-7][0-7]?)?))*'/
scon(String):	/"([^\n\\"]|\\(['"?\\abfnrtv]|x[0-9a-fA-F]+|[0-7]([0-7][0-7]?)?))*"/
'i{':	/{/		{ deep++; break; }
'}':	/}/		{ if( --deep == 0 ) group = @0; break; }

# Attributes

[]

# Grammar

input ::= 
	directives lexical_part magazine_def grammar_part ;

command (String) ::=
	'{' command_tokens '}' ;
	
command_tokens ::=
	command_tokens command_token | command_token ;
	
command_token ::=
	any
	| ccon
	| scon
	| 'i{' command_tokens '}'
;

directives ::= 
	directives directive | directive ;

directive ::=
	'.' identifier scon | '.' identifier icon ;

lexical_part ::= 
	newtypelexemopt lexemdef | lexical_part newtypelexemopt lexemdef ;

int32(Integer) ::= icon ;

int32_list(Integer) ::= int32 | int32_list int32 ;

newtypelexem ::= '[' int32_list ']';

lexemdef ::
  = identifier ':'
  = identifier type ':'
  = identifier ':' regexp iconopt command
  = identifier ':' regexp iconopt
  = identifier type ':' regexp iconopt command
  = identifier type ':' regexp iconopt
;

magazine_def ::= '[' magazine_def_listopt ']' ;
magazine_def_list ::= magazine_def_list ',' attrib | attrib ;

attrib ::
  = identifier '->' identifier
  = identifier
;

grammar_part ::=
	ruledef | grammar_part ruledef ;

ruledef ::= 
	def_rule_for '::=' rules_or ';' | 
	prioritydef ;

rules_or ::= 
	rules_or '|' stdrule | 
	stdrule ;

prioritydef ::=
	'%' identifier idlist ';' ;

idlist(Integer) ::= 
	identifier | idlist identifier ;

rule_priority(Integer) ::=
	'<<' identifier | ;

stdrule ::
  = ids rule_priority command
  = ids rule_priority
  = command rule_priority
  = rule_priority
;

ids ::
  = ids rule_priority commandopt identifier          # rule_priority must not be here
  = commandopt identifier
;

def_rule_for ::
  = identifier
  = identifier type
;

# EOF

%%
import java.io.IOException;
import java.io.InputStream;
import java.text.MessageFormat;

import net.sf.lapg.IError;
%%

private static final boolean DEBUG_SYNTAX = false;
private static final int BITS = 32;

byte[] buff = new byte[1025];
int l, end;
InputStream input;
IError err;

int length;
int[] rule = new int[128];
int deep = 0;

String sourcename;

private Parser( InputStream is, String sourceName, IError err) {
	this.input = is;
	this.sourcename = sourceName;
	this.err = err;
}

static boolean parse( InputStream is, String sourceName, IError err) {
	Parser p = new Parser(is, sourceName, err);
	p.fillb();
	return p.parse();
}

void fillb() {
	l = 0;
	try {
		end = input.read( buff, 0, 1024 );
		if( end == -1 )
			end = 0;
	} catch( IOException ex ) {
		end = 0;
	}
	buff[end] = 0;
}

void error( String s ) {
	err.error(s);
}
