#   Automatically generated grammar

.lang        "java" 
.getsym      "chr = l < buff.length ? buff[l++] : 0"
.positioning "offset"
.class       "Parser"
.namespace	 "net.sf.lapg.templates.parser"
.breaks		 "on"
.lexemend    "on"

# Vocabulary

[0]

any:	/[^$]+/
any:	/$$/

escid(String):	/$[a-zA-Z_][A-Za-z_0-9]*/		{ @ = new String(token,1,lapg_size-1); break; }

'${':	/${/		{ group = @1; break; }

[1]

identifier(String):	/[a-zA-Z_][A-Za-z_0-9]*/ -1		{ @ = new String(token,0,lapg_size); break; }

icon(Integer):	/[0-9]+/							{ @ = Integer.parseInt(new String(token,0,lapg_size)); break; }
ccon(String):	/'([^\n\\']|\\(['"?\\abfnrtv]|x[0-9a-fA-F]+|[0-7]([0-7][0-7]?)?))*'/	{ @ = new String(token,1,lapg_size-2); break; }

Lcall:		/call/
Lend:		/end/
Lfalse:		/false/
Lfor:		/for/
Lforeach:	/foreach/
Lif:		/if/
Lin:		/in/
Lnot:		/not/
Ltemplate:  /template/
Ltrue:		/true/
Lthis:		/this/

'}':		/}/			{ group = @0; break; }
'-':		/-/
'[':		/\[/
']':		/\]/
'(':		/\(/
')':		/\)/
'.':		/\./
',':		/,/
'&&':		/&&/
'||':		/\|\|/
'==':		/==/
'!=':		/!=/
'<=':		/<=/
'>=':		/>=/
'<':		/</
'>':		/>/

_skip:      /[\t\r\n ]+/    \ continue;

# Attributes

[]

# Grammar

input ::=
	templates 
;

templates ::=
	templates template_declaration_or_space 
	| template_declaration_or_space 
;

template_declaration_or_space ::=
	template_start instructions template_end		{ $template_start.setInstructions($instructions); templates.add($template_start); }
	| any
;

template_start (TemplateNode) ::=
	'${' Ltemplate identifier skip_spaces '}'		{ $$ = new TemplateNode($identifier); } ;

template_end ::=
	'${' Lend '}' ;

instructions (ArrayList<Node>) ::=
	instructions instruction						{ $instructions.add($instruction); }
	| instruction 									{ $$ = new ArrayList<Node>(); $instructions.add($instruction); }
;

skip_spaces(Boolean) ::= 
	'-' { $$ = Boolean.TRUE; } 
	| { $$ = Boolean.FALSE; } 
;

instruction (Node) ::=
	  control_instruction
	| simple_instruction
	| escid											{ $$ = new SelectNode(null, $escid); }
	| any											{ $$ = new TextNode(rawText(@0.offset,@~0.offset)); }
;

simple_instruction (Node) ::=
	'${' sentence skip_spaces '}' 					{ $$ = $1; if( $skip_spaces ) skipSpaces(@3.offset); } 
;

sentence (Node) ::=
	  expression
	| Lcall template_id template_argumentsopt template_for_expropt	{ $$ = new CallTemplateNode($template_id,$template_argumentsopt,$template_for_expropt); }
;

template_id (String) ::=
	identifier
	| template_id '.' identifier					{ $$ = $template_id + "." + $identifier; }
;

template_for_expr (ExpressionNode) ::=
	Lfor expression									{ $$ = $1; }
;

template_arguments (ArrayList) ::=
	'(' expression_listopt ')'						{ $$ = $1; } 
;

control_instruction (CompoundNode) ::=
	control_start instructions control_end 			{ $control_instruction.setInstructions($instructions); }
;

control_start (CompoundNode) ::=
	'${' control_sentence skip_spaces '}' 			{ $$ = $1; if( $skip_spaces ) skipSpaces(@3.offset); } ;

control_sentence (CompoundNode) ::=
	  Lforeach identifier Lin expression			{ $$ = new ForeachNode($identifier, $expression); }
	| Lif Lnotopt expression						{ $$ = new IfNode($expression); }
;

control_end ::=
	'${' Lend skip_spaces '}'						{ if( $skip_spaces ) skipSpaces(@3.offset); }
;

primary_expression (ExpressionNode) ::=
  	  identifier									{ $$ = new SelectNode(null, $identifier); } 
    | '(' expression ')'							{ $$ = $1; }
	| icon 											{ $$ = new LiteralNode($0); }
	| bcon                                          { $$ = new LiteralNode($0); }
	| ccon 											{ $$ = new LiteralNode($0); }
  	| Lthis											{ $$ = new ThisNode(); }
    | identifier '(' expression_listopt ')'         { $$ = new MethodCallNode(null, $identifier, $expression_listopt); }
    | primary_expression '.' identifier				{ $$ = new SelectNode($primary_expression#1, $identifier); }
    | primary_expression '.' identifier '(' expression_listopt ')'   { $$ = new MethodCallNode($primary_expression#1, $identifier, $expression_listopt); }
    | primary_expression '[' expression ']'			{ $$ = new IndexNode($primary_expression#1, $expression); }
;

bcon (Boolean) ::= 
	Ltrue 											{ $$ = Boolean.TRUE; }
	| Lfalse										{ $$ = Boolean.FALSE; }
;

relational_expression (ExpressionNode) ::=
      primary_expression
    | relational_expression '<' primary_expression	{ $$ = new ConditionalNode(ConditionalNode.LT, $relational_expression, $primary_expression); }
    | relational_expression '>' primary_expression	{ $$ = new ConditionalNode(ConditionalNode.GT, $relational_expression, $primary_expression); }
    | relational_expression '<=' primary_expression { $$ = new ConditionalNode(ConditionalNode.LE, $relational_expression, $primary_expression); }
    | relational_expression '>=' primary_expression { $$ = new ConditionalNode(ConditionalNode.GE, $relational_expression, $primary_expression); }
;

equality_expression (ExpressionNode) ::=
      relational_expression
    | equality_expression '==' relational_expression { $$ = new ConditionalNode(ConditionalNode.EQ, $equality_expression, $relational_expression); }
    | equality_expression '!=' relational_expression { $$ = new ConditionalNode(ConditionalNode.NE, $equality_expression, $relational_expression); }
;

conditional_and_expression (ExpressionNode) ::=
      equality_expression
    | conditional_and_expression '&&' equality_expression { $$ = new ConditionalNode(ConditionalNode.AND, $conditional_and_expression, $equality_expression); }
;

expression (ExpressionNode) ::=
      conditional_and_expression
    | expression '||' conditional_and_expression	{ $$ = new ConditionalNode(ConditionalNode.OR, $expression, $conditional_and_expression); }
;

expression_list (ArrayList) ::=
	expression										{ $$ = new ArrayList(); $expression_list.add($expression); }	
	| expression_list ',' expression				{ $expression_list.add($expression); }
;

##################################################################################

%%
import java.io.UnsupportedEncodingException;
import java.text.MessageFormat;
import java.util.ArrayList;

import net.sf.lapg.templates.ITemplate;
import net.sf.lapg.templates.ast.CallTemplateNode;
import net.sf.lapg.templates.ast.CompoundNode;
import net.sf.lapg.templates.ast.ConditionalNode;
import net.sf.lapg.templates.ast.ExpressionNode;
import net.sf.lapg.templates.ast.ForeachNode;
import net.sf.lapg.templates.ast.IfNode;
import net.sf.lapg.templates.ast.IndexNode;
import net.sf.lapg.templates.ast.LiteralNode;
import net.sf.lapg.templates.ast.MethodCallNode;
import net.sf.lapg.templates.ast.Node;
import net.sf.lapg.templates.ast.SelectNode;
import net.sf.lapg.templates.ast.TemplateNode;
import net.sf.lapg.templates.ast.TextNode;
import net.sf.lapg.templates.ast.ThisNode;
%%

private ArrayList<ITemplate> templates;

public Parser() {
}

private static final boolean DEBUG_SYNTAX = false;

int killEnds = -1;
byte[] buff;
int l;

private String rawText(int start, int end) {
	if( killEnds == start ) {
		while( start < end && (buff[start] == '\t' || buff[start] == ' ') )
			start++;

		if( start < end && buff[start] == '\r' )
			start++;

		if( start < end && buff[start] == '\n' )
			start++;
	}
	try {
		return new String(buff, start, end-start, "utf-8");
	} catch(UnsupportedEncodingException ex) {
		return "";
	}
}

private void skipSpaces(int offset) {
	killEnds = offset+1;
}

void error( String s ) {
	System.err.println(s);
}

public boolean parse(String s) {
	l = 0;
	templates = new ArrayList<ITemplate>();
	try {
		buff = s.getBytes("utf-8");
	} catch( UnsupportedEncodingException ex ) {
		return false;
	}
	return parse();
}

public ITemplate[] getResult() {
	return templates.toArray(new ITemplate[templates.size()]);
}
