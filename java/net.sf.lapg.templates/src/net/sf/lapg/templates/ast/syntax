#   Automatically generated grammar

.lang        "java" 
.getsym      "chr = l < buff.length ? buff[l++] : 0"
.positioning "offset"
.class       "AstParser"
.lexer		 "AstLexer"
.package	 "net.sf.lapg.templates.ast"
.breaks		 "on"
.lexemend    "on"
.packLexems  "true"

# Vocabulary

[0]

any:	/[^$]+/

escdollar:		/$$/
escid(String):	/$[a-zA-Z_][A-Za-z_0-9]*(#[0-9]+)?/	{ $lexem = new String(token,1,len-1); break; }
escint(Integer):/$[0-9]+/							{ $lexem = Integer.parseInt(new String(token,1,len-1)); break; }

'${':	/${/		{ group = 1; break; }
'$/':   /$\//

[1]

identifier(String):	/[a-zA-Z_][A-Za-z_0-9]*/ -1		{ $lexem = new String(token,0,len); break; }

icon(Integer):	/[0-9]+/							{ $lexem = Integer.parseInt(new String(token,0,len)); break; }
ccon(String):	/'([^\n\\']|\\(['"?\\abfnrtv]|x[0-9a-fA-F]+|[0-7]([0-7][0-7]?)?))*'/	{ $lexem = new String(token,1,len-2); break; }

Lcall:		/call/
Lcase:		/case/
Lend:		/end/
Lelse:		/else/
Leval:		/eval/
Lfalse:		/false/
Lfor:		/for/
Lfile:		/file/
Lforeach:	/foreach/
Lgrep:		/grep/
Lif:		/if/
Lin:		/in/
Limport:	/import/
Lis:		/is/
Lmap:		/map/
Lnull:		/null/
Lswitch:	/switch/
Ltemplate:  /template/
Ltrue:		/true/
Lself:		/self/
Lassert:	/assert/

'}':		/}/			{ group = 0; break; }
'-}':		/-}/		{ group = 0; break; }
'+':		/+/
'-':		/-/
'*':		/*/
'/':		/\//
'%':		/%/
'!':		/!/
'|':		/\|/
'[':		/\[/
']':		/\]/
'(':		/\(/
')':		/\)/
'.':		/\./
',':		/,/
'&&':		/&&/
'||':		/\|\|/
'==':		/==/
'!=':		/!=/
'->':		/->/
'<=':		/<=/
'>=':		/>=/
'<':		/</
'>':		/>/
':':		/:/
'?':		/?/
'`':		/`/
'$':		/$/

_skip:      /[\t\r\n ]+/    { return false; }

# Grammar

input ::=
	templatesopt 
;

templates ::=
	templates template_declaration_or_space 
	| template_declaration_or_space 
;

template_declaration_or_space ::=
	template_start instructions template_end		{ $template_start.setInstructions($instructions); templates.add($template_start); }
	| template_start template_end					{ templates.add($template_start); }
	| any
;

template_start (TemplateNode) ::=
	'${' Ltemplate identifier template_parametersopt template_overridesopt '[-]}'
                                                    { $$ = new TemplateNode($identifier, $template_parametersopt, templatePackage, $template_overridesopt, inputName, ${self[0].line}); }
;

template_overrides (String) ::=
	':' template_id 								{ $$ = $1; }
;
 

template_parameters (ArrayList) ::=
	'(' identifier_listopt ')' 						{ $$ = $1; }
;

identifier_list (ArrayList) ::=
	  identifier                                    { $$ = new ArrayList(); $identifier_list.add($identifier); }
	| identifier_list ',' identifier                { $identifier_list#0.add($identifier); }
;

template_end ::=
	'${' Lend '}' ;

instructions (ArrayList<Node>) ::=
	instructions instruction						{ $instructions#0.add($instruction); }
	| instruction 									{ $$ = new ArrayList<Node>(); $instructions.add($instruction); }
;

'[-]}' ::=
	'-}'											{ skipSpaces(${self[0].offset}+1); }
	| '}'
;

instruction (Node) ::=
	  control_instruction
	| switch_instruction
	| simple_instruction
	| escid											{ $$ = createEscapedId($escid, ${self[0].line}); }
	| escint										{ $$ = new IndexNode(null, new LiteralNode($escint,inputName, ${self[0].line}), inputName, ${self[0].line}); }
	| escdollar										{ $$ = new DollarNode(inputName, ${self[0].line}); }
	| any											{ $$ = new TextNode(rawText(${self[0].offset},${self[0].endoffset}),inputName, ${self[0].line}); }
;

simple_instruction (Node) ::=
	'${' sentence '[-]}' 							{ $$ = $1; } 
;

sentence (Node) ::=
	  expression
	| Lcall template_id template_argumentsopt template_for_expropt	{ $$ = new CallTemplateNode($template_id,$template_argumentsopt,$template_for_expropt,templatePackage,true,inputName, ${self[0].line}); }
	| Leval expression comma_expropt				{ $$ = new EvalNode($expression,$comma_expropt,inputName,${self[0].line}); }
	| Lassert expression							{ $$ = new AssertNode($expression,inputName,${self[0].line}); }
;

comma_expr (ExpressionNode) ::=
	',' expression									{ $$ = $expression; }
;

template_id (String) ::=
	identifier
	| template_id '.' identifier					{ $$ = $template_id#0 + "." + $identifier; }
;

template_for_expr (ExpressionNode) ::=
	Lfor expression									{ $$ = $1; }
;

template_arguments (ArrayList) ::=
	'(' expression_listopt ')'						{ $$ = $1; } 
;

control_instruction (CompoundNode) ::=
	control_start instructions control_end 			{ $control_instruction.setInstructions($instructions); }
	| control_start instructions else_node instructions control_end
                  									{ $control_instruction.setInstructions($instructions#0); applyElse($control_instruction,$instructions#1); }
;

else_node (ElseNode) ::=
	'${' Lelse '[-]}'
;

switch_instruction (CompoundNode) ::=
	'${' Lswitch expression '[-]}' anyopt 
           case_list control_end            		{ $$ = new SwitchNode($expression, $case_list,inputName, ${self[0].line}); checkIsSpace(${self[4].offset},${self[4].endoffset}); }
;

case_list (ArrayList) ::=
	one_case										{ $$ = new ArrayList(); $case_list.add($one_case); }	
	| case_list one_case                            { $case_list#0.add($one_case); }
	| case_list instruction                         { CaseNode.add($case_list#0, $instruction); }
;

one_case (CaseNode) ::=
	'${' Lcase expression '[-]}' 					{ $$ = new CaseNode($expression,inputName, ${self[0].line}); } 
;

control_start (CompoundNode) ::=
	'${' control_sentence '[-]}' 					{ $$ = $1; } ;

control_sentence (CompoundNode) ::=
	  Lforeach identifier Lin expression			{ $$ = new ForeachNode($identifier, $expression,inputName, ${self[0].line}); }
	| Lfor identifier ':' expression ',' expression { $$ = new ForeachNode($identifier, $expression#0, $expression#1,inputName, ${self[0].line}); }
	| Lif expression								{ $$ = new IfNode($expression,inputName, ${self[0].line}); }
	| Lfile expression								{ $$ = new FileNode($expression,inputName, ${self[0].line}); }
;

control_end ::=
	'${' Lend '[-]}'
	| '$/'
;

primary_expression (ExpressionNode) ::=
  	  identifier									{ $$ = new SelectNode(null, $identifier,inputName, ${self[0].line}); }
    | '(' expression ')'							{ $$ = $1; }
	| icon 											{ $$ = new LiteralNode($0,inputName, ${self[0].line}); }
	| bcon                                          { $$ = new LiteralNode($0,inputName, ${self[0].line}); }
	| ccon 											{ $$ = new LiteralNode($0,inputName, ${self[0].line}); }
  	| Lself											{ $$ = new ThisNode(inputName, ${self[0].line}); }
  	| Lnull											{ $$ = new LiteralNode(null, inputName, ${self[0].line}); }
    | identifier '(' expression_listopt ')'         { $$ = new MethodCallNode(null, $identifier, $expression_listopt,inputName, ${self[0].line}); }
    | primary_expression '.' identifier				{ $$ = new SelectNode($primary_expression#1, $identifier,inputName, ${self[0].line}); }
    | primary_expression '.' identifier '(' expression_listopt ')'   
    												{ $$ = new MethodCallNode($primary_expression#1, $identifier, $expression_listopt,inputName, ${self[0].line}); }
    | primary_expression '.' identifier '(' identifier '|' expression ')'
    												{ $$ = createCollectionProcessor($primary_expression#1, $identifier#0, $identifier#1, $expression, inputName, ${self[0].line}); }
    | primary_expression '->' template_id '(' expression_listopt ')'
    												{ $$ = new CallTemplateNode($template_id,$expression_listopt,$primary_expression#1,templatePackage,false,inputName, ${self[0].line}); }
    | primary_expression '->' '(' expression ')' '(' expression_listopt ')'  
    												{ $$ = new CallTemplateNode($expression,$expression_listopt,$primary_expression#1,templatePackage,inputName, ${self[0].line}); }
    | primary_expression '[' expression ']'			{ $$ = new IndexNode($primary_expression#1, $expression,inputName, ${self[0].line}); }
    | complex_data
;

complex_data (ExpressionNode) ::=
	'[' expression_listopt ']'						{ $$ = new ListNode($expression_listopt,inputName, ${self[0].line}); }
    | '[' map_entries ']'							{ $$ = new ConcreteMapNode($map_entries,inputName, ${self[0].line}); }
 ;

map_entries (HashMap<String,ExpressionNode>) ::=
	identifier ':' expression						{ $$ = new HashMap(); $map_entries.put($identifier, $expression); }
	| map_entries ',' identifier ':' expression		{ $map_entries#0.put($identifier, $expression); }
;

bcon (Boolean) ::= 
	Ltrue 											{ $$ = Boolean.TRUE; }
	| Lfalse										{ $$ = Boolean.FALSE; }
;

unary_expression (ExpressionNode) ::=
	primary_expression
	| '!' unary_expression							{ $$ = new UnaryExpression(UnaryExpression.NOT, $unary_expression#1,inputName, ${self[0].line}); }
	| '-' unary_expression							{ $$ = new UnaryExpression(UnaryExpression.MINUS, $unary_expression#1,inputName, ${self[0].line}); }
;

mult_expression (ExpressionNode) ::=
	unary_expression
	| mult_expression '*' unary_expression			{ $$ = new ArithmeticNode(ArithmeticNode.MULT, $mult_expression#0, $unary_expression,inputName, ${self[0].line}); }
	| mult_expression '/' unary_expression			{ $$ = new ArithmeticNode(ArithmeticNode.DIV, $mult_expression#0, $unary_expression,inputName, ${self[0].line}); }
	| mult_expression '%' unary_expression			{ $$ = new ArithmeticNode(ArithmeticNode.REM, $mult_expression#0, $unary_expression,inputName, ${self[0].line}); }
;

additive_expression (ExpressionNode) ::=
	mult_expression
	| additive_expression '+' mult_expression		{ $$ = new ArithmeticNode(ArithmeticNode.PLUS, $additive_expression#0, $mult_expression,inputName, ${self[0].line}); }
	| additive_expression '-' mult_expression		{ $$ = new ArithmeticNode(ArithmeticNode.MINUS, $additive_expression#0, $mult_expression,inputName, ${self[0].line}); }
;


relational_expression (ExpressionNode) ::=
      additive_expression
    | relational_expression '<' additive_expression	{ $$ = new ConditionalNode(ConditionalNode.LT, $relational_expression#0, $additive_expression,inputName, ${self[0].line}); }
    | relational_expression '>' additive_expression	{ $$ = new ConditionalNode(ConditionalNode.GT, $relational_expression#0, $additive_expression,inputName, ${self[0].line}); }
    | relational_expression '<=' additive_expression { $$ = new ConditionalNode(ConditionalNode.LE, $relational_expression#0, $additive_expression,inputName, ${self[0].line}); }
    | relational_expression '>=' additive_expression { $$ = new ConditionalNode(ConditionalNode.GE, $relational_expression#0, $additive_expression,inputName, ${self[0].line}); }
;

equality_expression (ExpressionNode) ::=
      relational_expression
    | equality_expression '==' relational_expression { $$ = new ConditionalNode(ConditionalNode.EQ, $equality_expression#0, $relational_expression,inputName, ${self[0].line}); }
    | equality_expression '!=' relational_expression { $$ = new ConditionalNode(ConditionalNode.NE, $equality_expression#0, $relational_expression,inputName, ${self[0].line}); }
;

conditional_and_expression (ExpressionNode) ::=
      equality_expression
    | conditional_and_expression '&&' equality_expression { $$ = new ConditionalNode(ConditionalNode.AND, $conditional_and_expression#0, $equality_expression,inputName, ${self[0].line}); }
;

conditional_or_expression (ExpressionNode) ::=
      conditional_and_expression
    | conditional_or_expression '||' conditional_and_expression	{ $$ = new ConditionalNode(ConditionalNode.OR, $conditional_or_expression#0, $conditional_and_expression,inputName, ${self[0].line}); }
;

expression (ExpressionNode) ::=
    conditional_or_expression
  | conditional_or_expression '?' expression ':' expression		{ $$ = new TriplexNode($conditional_or_expression, $expression#1, $expression#2, inputName, ${self[0].line}); }
;


expression_list (ArrayList) ::=
	expression										{ $$ = new ArrayList(); $expression_list.add($expression); }
	| expression_list ',' expression				{ $expression_list#0.add($expression); }
;

##################################################################################
%%
${template imports}
import java.io.ByteArrayInputStream;
import java.io.UnsupportedEncodingException;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.HashMap;

import net.sf.lapg.templates.api.ITemplate;
${end}

${template lexercode-}
${end}

${template classcode}
private ArrayList<ITemplate> templates;
private String templatePackage;

public AstParser() {
}

private static final boolean DEBUG_SYNTAX = false;

private String inputName;
private int killEnds = -1;
private byte[] buff;

private String rawText(int start, int end) {
	if( killEnds == start ) {
		while( start < end && (buff[start] == '\t' || buff[start] == ' ') )
			start++;

		if( start < end && buff[start] == '\r' )
			start++;

		if( start < end && buff[start] == '\n' )
			start++;
	}
	try {
		return new String(buff, start, end-start, "utf-8");
	} catch(UnsupportedEncodingException ex) {
		return "";
	}
}

private void checkIsSpace(int start, int end) {
	String val = rawText(start,end).trim();
	if( val.length() > 0 )
		error("Unknown text ignored: `"+val+"`");
}

private void applyElse(CompoundNode node, ArrayList<Node> instructions) {
	if( node instanceof IfNode ) {
		((IfNode)node).setElseInstructions(instructions);
	} else {
		error("Unknown else node, instructions skipped");
	}
}

private ExpressionNode createCollectionProcessor(ExpressionNode forExpr, String instruction, String varName, ExpressionNode foreachExpr, String input, int line) {
	char first = instruction.charAt(0);
	int kind = 0;
	switch(first) {
	case 'c':
		if(instruction.equals("collect")) {
			kind = CollectionProcessorNode.COLLECT;
		}
		break;
	case 'r':
		if(instruction.equals("reject")) {
			kind = CollectionProcessorNode.REJECT;
		}
		break;
	case 's':
		if(instruction.equals("select")) {
			kind = CollectionProcessorNode.SELECT;
		}
		break;
	case 'f':
		if(instruction.equals("forAll")) {
			kind = CollectionProcessorNode.FORALL;
		}
		break;
	case 'e':
		if(instruction.equals("exists")) {
			kind = CollectionProcessorNode.EXISTS;
		}
		break;
	}
	if(kind == 0) {
		error("unknown collection processing instruction: " + instruction);
		return new ErrorNode(input,line);
	}
	return new CollectionProcessorNode(forExpr,kind,varName,foreachExpr,input,line);
}

private Node createEscapedId(String escid, int line) {
	int sharp = escid.indexOf('#');
	if( sharp >= 0 ) {
		Integer index = new Integer(escid.substring(sharp+1));
		escid = escid.substring(0, sharp);
		return new IndexNode(new SelectNode(null,escid,inputName,line), new LiteralNode(index,inputName,line),inputName,line);
	
	} else {
		return new SelectNode(null,escid,inputName,line);
	}
}

private void skipSpaces(int offset) {
	killEnds = offset+1;
}

public void error( String s ) {
	System.err.println(inputName + ":" + s);
}

public boolean parse(String s, String templatePackage, String inputName) {
	this.templatePackage = templatePackage;
	this.inputName = inputName;
	templates = new ArrayList<ITemplate>();
	try {
		buff = s.getBytes("utf-8");
		AstLexer lexer = new AstLexer(new ByteArrayInputStream(buff), this, "utf-8");
		return parse(lexer);
	} catch( IOException ex ) {
		return false;
	}
}

public ITemplate[] getResult() {
	return templates.toArray(new ITemplate[templates.size()]);
}
${end}
