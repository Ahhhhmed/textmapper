#   Automatically generated grammar

.lang        "java" 
.getsym      "chr = l < buff.length ? buff[l++] : 0"
.positioning "offset"
.class       "XmlParser"
.lexer	     "XmlLexer"
.package	 "net.sf.lapg.templates.model.xml"
.breaks		 "on"
.lexemend    "on"

# Vocabulary

[0]

any:	/[^<]+/

'<':	/</         { group = 1; break; }

_skipcomment:   /<!--([^-]|-[^-]|--[^>])*-->/		{ return false; }

[1]

identifier(String):	/[a-zA-Z_][A-Za-z_0-9-]*/		{ $lexem = new String(token,0,len); break; }
ccon(String):	/"[^\n"]*"/							{ $lexem = new String(token,1,len-2); break; }
ccon:		/'[^\n']*'/

'>':	    />/          { group = 0; break; }
'=':		/=/
':':		/:/
'/':		/\//

_skip:      /[\t\r\n ]+/    { return false; }

# Grammar

input ::=
	xml_tags										{ result = $xml_tags; } 
;

xml_tags (List<XmlElement>) ::=
	xml_tags xml_tag_or_space 						{ $xml_tags#0.add($xml_tag_or_space); }
	| xml_tag_or_space 								{ $$ = new ArrayList<XmlElement>(); $xml_tags.add($xml_tag_or_space); }
;

xml_tag_or_space (XmlElement) ::=
	tag_start tag_end								{ checkTag($tag_start,$tag_end,${self[1].line}); }
	| tag_start xml_tags tag_end					{ checkTag($tag_start,$tag_end,${self[2].line}); $tag_start.setData($xml_tags); }
	| no_body_tag
	| any											{ $$ = getData(${self[0].offset},${self[0].endoffset}); }
;

tag_name (String) ::=
	identifier										{ $$ = $identifier; }
	| identifier ':' identifier						{ $$ = $identifier#0 + ":" + $identifier#1; }
;

tag_start (XmlNode) ::=
	'<' tag_name attributesopt '>'		            { $$ = new XmlNode($tag_name, $attributesopt, ${self[0].line}); }
;

no_body_tag (XmlNode) ::=
	'<' tag_name attributesopt '/' '>'		        { $$ = new XmlNode($tag_name, $attributesopt, ${self[0].line}); }
;

tag_end (String) ::=
	'<' '/' tag_name '>'		                    { $$ = $tag_name; }
;

attributes (List<XmlAttribute>) ::=
	attributes attribute							{ $attributes#0.add($attribute); }
	| attribute 									{ $$ = new ArrayList<XmlAttribute>(); $attributes.add($attribute); }
;

attribute (XmlAttribute) ::=
	identifier '=' ccon								{ $$ = new XmlAttribute($identifier,$ccon); }
;


##################################################################################

%%
${template imports}
import java.io.ByteArrayInputStream;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.List;
${end}

${template lexercode-}
${end}

${template classcode}
public XmlParser() {
}

private static final boolean DEBUG_SYNTAX = false;

private List<XmlElement> result;

byte[] buff;

private XmlData getData(int start, int end) {
	return new XmlData(buff, start, end-start);
}

public void error(String s) {
	System.err.println(s);
}

public List<XmlElement> parse(String s) {
	result = null;
	try {
		buff = s.getBytes("utf-8");
		XmlLexer lexer = new XmlLexer(new ByteArrayInputStream(buff), this, "utf-8");
		parse(lexer);
	} catch( IOException ex ) {
	}
	return result;
}

private void checkTag(XmlNode node, String endTag, int line) {
	if( !node.getTagName().equals(endTag) )
		error("Tag " + node.getTagName() + " is closed with " + endTag + " at line " + line);
}
${end}
