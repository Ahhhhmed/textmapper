#   Automatically generated grammar

.lang        "java" 
.getsym      "chr = l < buff.length ? buff[l++] : 0"
.positioning "offset"
.class       "Parser"
.namespace	 "net.sf.lapg.templates.model.xml"
.breaks		 "on"
.lexemend    "on"

# Vocabulary

[0]

any:	/[^<]+/

'<':	/</         { group = @1; break; }

_skipcomment:   /<!--([^-]|-[^-]|--[^>])*-->/		\ continue;

[1]

identifier(String):	/[a-zA-Z_][A-Za-z_0-9-]*/		{ @ = new String(token,0,lapg_size); break; }
ccon(String):	/"[^\n"]*"/							{ @ = new String(token,1,lapg_size-2); break; }
ccon:		/'[^\n']*'/

'>':	    />/          { group = @0; break; }
'=':		/=/
':':		/:/
'/':		/\//

_skip:      /[\t\r\n ]+/    \ continue;

# Attributes

[]

# Grammar

input ::=
	xml_tags										{ result = $xml_tags; } 
;

xml_tags (List<XmlElement>) ::=
	xml_tags xml_tag_or_space 						{ $xml_tags.add($xml_tag_or_space); }
	| xml_tag_or_space 								{ $$ = new ArrayList<XmlElement>(); $xml_tags.add($xml_tag_or_space); }
;

xml_tag_or_space (XmlElement) ::=
	tag_start tag_end								{ checkTag($tag_start,$tag_end,@1.line); }
	| tag_start xml_tags tag_end					{ checkTag($tag_start,$tag_end,@2.line); $tag_start.setData($xml_tags); }
	| no_body_tag
	| any											{ $$ = getData(@0.offset,@~0.offset); }
;

tag_name (String) ::=
	identifier										{ $$ = $identifier; }
	| identifier ':' identifier						{ $$ = $identifier#0 + ":" + $identifier#1; }
;

tag_start (XmlNode) ::=
	'<' tag_name attributesopt '>'		            { $$ = new XmlNode($tag_name, $attributesopt, @0.line); }
;

no_body_tag (XmlNode) ::=
	'<' tag_name attributesopt '/' '>'		        { $$ = new XmlNode($tag_name, $attributesopt, @0.line); }
;

tag_end (String) ::=
	'<' '/' tag_name '>'		                    { $$ = $tag_name; }
;

attributes (List<XmlAttribute>) ::=
	attributes attribute							{ $attributes.add($attribute); }
	| attribute 									{ $$ = new ArrayList<XmlAttribute>(); $attributes.add($attribute); }
;

attribute (XmlAttribute) ::=
	identifier '=' ccon								{ $$ = new XmlAttribute($identifier,$ccon); }
;


##################################################################################

%%
import java.io.UnsupportedEncodingException;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.List;
%%

public Parser() {
}

private static final boolean DEBUG_SYNTAX = false;

private List<XmlElement> result;

byte[] buff;
int l;

private XmlData getData(int start, int end) {
	return new XmlData(buff, start, end-start);
}

void error( String s ) {
	System.err.println(s);
}

public List<XmlElement> parse(String s) {
	l = 0;
	result = null;
	try {
		buff = s.getBytes("utf-8");
	} catch( UnsupportedEncodingException ex ) {
		return null;
	}
	parse();
	return result;
}

private void checkTag(XmlNode node, String endTag, int line) {
	if( !node.getTagName().equals(endTag) )
		error("Tag " + node.getTagName() + " is closed with " + endTag + " at line " + line);
}