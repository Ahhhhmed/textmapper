// generated by Textmapper; DO NOT EDIT

package filter

import (
	"github.com/inspirer/textmapper/tm-parsers/js"
)

type NodeFilter func(nt js.NodeType) bool

var (
	AdditiveExpression       = func(t js.NodeType) bool { return t == js.AdditiveExpression }
	Arguments                = func(t js.NodeType) bool { return t == js.Arguments }
	ArrayLiteral             = func(t js.NodeType) bool { return t == js.ArrayLiteral }
	ArrayPattern             = func(t js.NodeType) bool { return t == js.ArrayPattern }
	ArrowFunction            = func(t js.NodeType) bool { return t == js.ArrowFunction }
	AssignmentExpression     = func(t js.NodeType) bool { return t == js.AssignmentExpression }
	AssignmentOperator       = func(t js.NodeType) bool { return t == js.AssignmentOperator }
	BindingIdentifier        = func(t js.NodeType) bool { return t == js.BindingIdentifier }
	BindingRestElement       = func(t js.NodeType) bool { return t == js.BindingRestElement }
	BitwiseANDExpression     = func(t js.NodeType) bool { return t == js.BitwiseANDExpression }
	BitwiseORExpression      = func(t js.NodeType) bool { return t == js.BitwiseORExpression }
	BitwiseXORExpression     = func(t js.NodeType) bool { return t == js.BitwiseXORExpression }
	Block                    = func(t js.NodeType) bool { return t == js.Block }
	Body                     = func(t js.NodeType) bool { return t == js.Body }
	BreakStatement           = func(t js.NodeType) bool { return t == js.BreakStatement }
	CallExpression           = func(t js.NodeType) bool { return t == js.CallExpression }
	Case                     = func(t js.NodeType) bool { return t == js.Case }
	Catch                    = func(t js.NodeType) bool { return t == js.Catch }
	Class                    = func(t js.NodeType) bool { return t == js.Class }
	ClassBody                = func(t js.NodeType) bool { return t == js.ClassBody }
	ClassExpr                = func(t js.NodeType) bool { return t == js.ClassExpr }
	CommaExpression          = func(t js.NodeType) bool { return t == js.CommaExpression }
	ComputedPropertyName     = func(t js.NodeType) bool { return t == js.ComputedPropertyName }
	ConciseBody              = func(t js.NodeType) bool { return t == js.ConciseBody }
	ConditionalExpression    = func(t js.NodeType) bool { return t == js.ConditionalExpression }
	ContinueStatement        = func(t js.NodeType) bool { return t == js.ContinueStatement }
	DebuggerStatement        = func(t js.NodeType) bool { return t == js.DebuggerStatement }
	Default                  = func(t js.NodeType) bool { return t == js.Default }
	DoWhileStatement         = func(t js.NodeType) bool { return t == js.DoWhileStatement }
	ElementBinding           = func(t js.NodeType) bool { return t == js.ElementBinding }
	EmptyDecl                = func(t js.NodeType) bool { return t == js.EmptyDecl }
	EmptyStatement           = func(t js.NodeType) bool { return t == js.EmptyStatement }
	EqualityExpression       = func(t js.NodeType) bool { return t == js.EqualityExpression }
	ExponentiationExpression = func(t js.NodeType) bool { return t == js.ExponentiationExpression }
	ExportClause             = func(t js.NodeType) bool { return t == js.ExportClause }
	ExportDeclaration        = func(t js.NodeType) bool { return t == js.ExportDeclaration }
	ExportDefault            = func(t js.NodeType) bool { return t == js.ExportDefault }
	ExportSpecifier          = func(t js.NodeType) bool { return t == js.ExportSpecifier }
	ExpressionStatement      = func(t js.NodeType) bool { return t == js.ExpressionStatement }
	Extends                  = func(t js.NodeType) bool { return t == js.Extends }
	Finally                  = func(t js.NodeType) bool { return t == js.Finally }
	ForBinding               = func(t js.NodeType) bool { return t == js.ForBinding }
	ForCondition             = func(t js.NodeType) bool { return t == js.ForCondition }
	ForFinalExpression       = func(t js.NodeType) bool { return t == js.ForFinalExpression }
	ForInStatement           = func(t js.NodeType) bool { return t == js.ForInStatement }
	ForInStatementWithVar    = func(t js.NodeType) bool { return t == js.ForInStatementWithVar }
	ForOfStatement           = func(t js.NodeType) bool { return t == js.ForOfStatement }
	ForOfStatementWithVar    = func(t js.NodeType) bool { return t == js.ForOfStatementWithVar }
	ForStatement             = func(t js.NodeType) bool { return t == js.ForStatement }
	ForStatementWithVar      = func(t js.NodeType) bool { return t == js.ForStatementWithVar }
	Function                 = func(t js.NodeType) bool { return t == js.Function }
	FunctionExpression       = func(t js.NodeType) bool { return t == js.FunctionExpression }
	Generator                = func(t js.NodeType) bool { return t == js.Generator }
	GeneratorExpression      = func(t js.NodeType) bool { return t == js.GeneratorExpression }
	GeneratorMethod          = func(t js.NodeType) bool { return t == js.GeneratorMethod }
	Getter                   = func(t js.NodeType) bool { return t == js.Getter }
	IdentifierReference      = func(t js.NodeType) bool { return t == js.IdentifierReference }
	IfStatement              = func(t js.NodeType) bool { return t == js.IfStatement }
	ImportDeclaration        = func(t js.NodeType) bool { return t == js.ImportDeclaration }
	ImportSpecifier          = func(t js.NodeType) bool { return t == js.ImportSpecifier }
	IndexAccess              = func(t js.NodeType) bool { return t == js.IndexAccess }
	Initializer              = func(t js.NodeType) bool { return t == js.Initializer }
	JSXAttributeName         = func(t js.NodeType) bool { return t == js.JSXAttributeName }
	JSXClosingElement        = func(t js.NodeType) bool { return t == js.JSXClosingElement }
	JSXElement               = func(t js.NodeType) bool { return t == js.JSXElement }
	JSXElementName           = func(t js.NodeType) bool { return t == js.JSXElementName }
	JSXExpression            = func(t js.NodeType) bool { return t == js.JSXExpression }
	JSXLiteral               = func(t js.NodeType) bool { return t == js.JSXLiteral }
	JSXNormalAttribute       = func(t js.NodeType) bool { return t == js.JSXNormalAttribute }
	JSXOpeningElement        = func(t js.NodeType) bool { return t == js.JSXOpeningElement }
	JSXSelfClosingElement    = func(t js.NodeType) bool { return t == js.JSXSelfClosingElement }
	JSXSpreadAttribute       = func(t js.NodeType) bool { return t == js.JSXSpreadAttribute }
	JSXText                  = func(t js.NodeType) bool { return t == js.JSXText }
	LabelIdentifier          = func(t js.NodeType) bool { return t == js.LabelIdentifier }
	LabelledStatement        = func(t js.NodeType) bool { return t == js.LabelledStatement }
	LexicalBinding           = func(t js.NodeType) bool { return t == js.LexicalBinding }
	LexicalDeclaration       = func(t js.NodeType) bool { return t == js.LexicalDeclaration }
	Literal                  = func(t js.NodeType) bool { return t == js.Literal }
	LiteralPropertyName      = func(t js.NodeType) bool { return t == js.LiteralPropertyName }
	LogicalANDExpression     = func(t js.NodeType) bool { return t == js.LogicalANDExpression }
	LogicalORExpression      = func(t js.NodeType) bool { return t == js.LogicalORExpression }
	Method                   = func(t js.NodeType) bool { return t == js.Method }
	Module                   = func(t js.NodeType) bool { return t == js.Module }
	ModuleSpecifier          = func(t js.NodeType) bool { return t == js.ModuleSpecifier }
	MultiplicativeExpression = func(t js.NodeType) bool { return t == js.MultiplicativeExpression }
	NameSpaceImport          = func(t js.NodeType) bool { return t == js.NameSpaceImport }
	NamedImports             = func(t js.NodeType) bool { return t == js.NamedImports }
	NewExpression            = func(t js.NodeType) bool { return t == js.NewExpression }
	NewTarget                = func(t js.NodeType) bool { return t == js.NewTarget }
	ObjectLiteral            = func(t js.NodeType) bool { return t == js.ObjectLiteral }
	ObjectPattern            = func(t js.NodeType) bool { return t == js.ObjectPattern }
	Parameter                = func(t js.NodeType) bool { return t == js.Parameter }
	Parameters               = func(t js.NodeType) bool { return t == js.Parameters }
	Parenthesized            = func(t js.NodeType) bool { return t == js.Parenthesized }
	PostDec                  = func(t js.NodeType) bool { return t == js.PostDec }
	PostInc                  = func(t js.NodeType) bool { return t == js.PostInc }
	PreDec                   = func(t js.NodeType) bool { return t == js.PreDec }
	PreInc                   = func(t js.NodeType) bool { return t == js.PreInc }
	Property                 = func(t js.NodeType) bool { return t == js.Property }
	PropertyAccess           = func(t js.NodeType) bool { return t == js.PropertyAccess }
	PropertyBinding          = func(t js.NodeType) bool { return t == js.PropertyBinding }
	Regexp                   = func(t js.NodeType) bool { return t == js.Regexp }
	RelationalExpression     = func(t js.NodeType) bool { return t == js.RelationalExpression }
	RestParameter            = func(t js.NodeType) bool { return t == js.RestParameter }
	ReturnStatement          = func(t js.NodeType) bool { return t == js.ReturnStatement }
	Setter                   = func(t js.NodeType) bool { return t == js.Setter }
	ShiftExpression          = func(t js.NodeType) bool { return t == js.ShiftExpression }
	ShorthandProperty        = func(t js.NodeType) bool { return t == js.ShorthandProperty }
	SingleNameBinding        = func(t js.NodeType) bool { return t == js.SingleNameBinding }
	SpreadElement            = func(t js.NodeType) bool { return t == js.SpreadElement }
	StaticMethod             = func(t js.NodeType) bool { return t == js.StaticMethod }
	SuperExpression          = func(t js.NodeType) bool { return t == js.SuperExpression }
	SwitchStatement          = func(t js.NodeType) bool { return t == js.SwitchStatement }
	SyntaxError              = func(t js.NodeType) bool { return t == js.SyntaxError }
	TaggedTemplate           = func(t js.NodeType) bool { return t == js.TaggedTemplate }
	TemplateLiteral          = func(t js.NodeType) bool { return t == js.TemplateLiteral }
	This                     = func(t js.NodeType) bool { return t == js.This }
	ThrowStatement           = func(t js.NodeType) bool { return t == js.ThrowStatement }
	TryStatement             = func(t js.NodeType) bool { return t == js.TryStatement }
	UnaryExpression          = func(t js.NodeType) bool { return t == js.UnaryExpression }
	VariableDeclaration      = func(t js.NodeType) bool { return t == js.VariableDeclaration }
	VariableStatement        = func(t js.NodeType) bool { return t == js.VariableStatement }
	WhileStatement           = func(t js.NodeType) bool { return t == js.WhileStatement }
	WithStatement            = func(t js.NodeType) bool { return t == js.WithStatement }
	Yield                    = func(t js.NodeType) bool { return t == js.Yield }
	NoSubstitutionTemplate   = func(t js.NodeType) bool { return t == js.NoSubstitutionTemplate }
	TemplateHead             = func(t js.NodeType) bool { return t == js.TemplateHead }
	TemplateMiddle           = func(t js.NodeType) bool { return t == js.TemplateMiddle }
	TemplateTail             = func(t js.NodeType) bool { return t == js.TemplateTail }
	BindingPattern           = OneOf(js.BindingPattern...)
	CaseClause               = OneOf(js.CaseClause...)
	ClassElement             = OneOf(js.ClassElement...)
	Declaration              = OneOf(js.Declaration...)
	ElementPattern           = OneOf(js.ElementPattern...)
	ExportElement            = OneOf(js.ExportElement...)
	Expression               = OneOf(js.Expression...)
	JSXAttribute             = OneOf(js.JSXAttribute...)
	JSXAttributeValue        = OneOf(js.JSXAttributeValue...)
	JSXChild                 = OneOf(js.JSXChild...)
	MethodDefinition         = OneOf(js.MethodDefinition...)
	ModuleItem               = OneOf(js.ModuleItem...)
	NamedImport              = OneOf(js.NamedImport...)
	PropertyDefinition       = OneOf(js.PropertyDefinition...)
	PropertyName             = OneOf(js.PropertyName...)
	PropertyPattern          = OneOf(js.PropertyPattern...)
	Statement                = OneOf(js.Statement...)
	StatementListItem        = OneOf(js.StatementListItem...)
	TokenSet                 = OneOf(js.TokenSet...)
)

func OneOf(types ...js.NodeType) NodeFilter {
	if len(types) == 0 {
		return func(js.NodeType) bool { return false }
	}
	const bits = 32
	size := (int(types[len(types)-1]) + bits - 1) / bits
	bitarr := make([]int32, size)
	for _, t := range types {
		bitarr[uint(t)/bits] |= 1 << (uint(t) % bits)
	}
	return func(t js.NodeType) bool {
		return bitarr[uint(t)/bits]&(1<<(uint(t)%bits)) != 0
	}
}
