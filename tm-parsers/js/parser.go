// generated by Textmapper; DO NOT EDIT

package js

func (p *Parser) Parse(lexer *Lexer) error {
	return p.parse(0, 4039, lexer)
}

func (p *Parser) applyRule(rule int32, lhs *stackEntry, rhs []stackEntry) {
	switch rule {
	case 2227: // IterationStatement : 'for' '(' 'async' 'of' AssignmentExpression_In ')' Statement
		p.listener(IdentifierReference, rhs[2].sym.offset, rhs[2].sym.endoffset)
	case 2241: // IterationStatement_Await_Return : 'for' '(' 'async' 'of' AssignmentExpression_Await_In ')' Statement_Await_Return
		p.listener(IdentifierReference, rhs[2].sym.offset, rhs[2].sym.endoffset)
	case 2255: // IterationStatement_Return : 'for' '(' 'async' 'of' AssignmentExpression_In ')' Statement_Return
		p.listener(IdentifierReference, rhs[2].sym.offset, rhs[2].sym.endoffset)
	case 2269: // IterationStatement_Return_Yield : 'for' '(' 'async' 'of' AssignmentExpression_In_Yield ')' Statement_Return_Yield
		p.listener(IdentifierReference, rhs[2].sym.offset, rhs[2].sym.endoffset)
	}
	nt := ruleNodeType[rule]
	if nt == 0 {
		return
	}
	p.listener(nt, lhs.sym.offset, lhs.sym.endoffset)
}

const errSymbol = 2
