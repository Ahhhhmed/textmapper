// generated by Textmapper; DO NOT EDIT

package ast

import (
	"github.com/inspirer/textmapper/tm-parsers/js"
	"github.com/inspirer/textmapper/tm-parsers/js/selector"
)

type Node interface {
	Type() js.NodeType
	// Child returns the first child node that matches the selector.
	Child(sel selector.Selector) Node
	Children(sel selector.Selector) []Node
	// Next returns the first element among the following siblings that matches the selector.
	Next(sel selector.Selector) Node
	// NextAll returns all following siblings of the node that match the selector.
	NextAll(sel selector.Selector) []Node
	Text() string
}

// Interfaces.

type JsNode interface {
	Node
	jsNodeNode()
}

type Token struct {
	Node
}

// All types implement JsNode.
func (AdditiveExpression) jsNodeNode()       {}
func (Arguments) jsNodeNode()                {}
func (ArrayLiteral) jsNodeNode()             {}
func (ArrayPattern) jsNodeNode()             {}
func (ArrowFunction) jsNodeNode()            {}
func (AssignmentExpression) jsNodeNode()     {}
func (AssignmentOperator) jsNodeNode()       {}
func (BindingIdentifier) jsNodeNode()        {}
func (BindingRestElement) jsNodeNode()       {}
func (BitwiseANDExpression) jsNodeNode()     {}
func (BitwiseORExpression) jsNodeNode()      {}
func (BitwiseXORExpression) jsNodeNode()     {}
func (Block) jsNodeNode()                    {}
func (Body) jsNodeNode()                     {}
func (BreakStatement) jsNodeNode()           {}
func (CallExpression) jsNodeNode()           {}
func (Case) jsNodeNode()                     {}
func (Catch) jsNodeNode()                    {}
func (Class) jsNodeNode()                    {}
func (ClassBody) jsNodeNode()                {}
func (ClassExpr) jsNodeNode()                {}
func (CommaExpression) jsNodeNode()          {}
func (ComputedPropertyName) jsNodeNode()     {}
func (ConciseBody) jsNodeNode()              {}
func (ConditionalExpression) jsNodeNode()    {}
func (ContinueStatement) jsNodeNode()        {}
func (DebuggerStatement) jsNodeNode()        {}
func (Default) jsNodeNode()                  {}
func (DoWhileStatement) jsNodeNode()         {}
func (ElementBinding) jsNodeNode()           {}
func (EmptyDecl) jsNodeNode()                {}
func (EmptyStatement) jsNodeNode()           {}
func (EqualityExpression) jsNodeNode()       {}
func (ExponentiationExpression) jsNodeNode() {}
func (ExportClause) jsNodeNode()             {}
func (ExportDeclaration) jsNodeNode()        {}
func (ExportDefault) jsNodeNode()            {}
func (ExportSpecifier) jsNodeNode()          {}
func (ExpressionStatement) jsNodeNode()      {}
func (Extends) jsNodeNode()                  {}
func (Finally) jsNodeNode()                  {}
func (ForBinding) jsNodeNode()               {}
func (ForCondition) jsNodeNode()             {}
func (ForFinalExpression) jsNodeNode()       {}
func (ForInStatement) jsNodeNode()           {}
func (ForInStatementWithVar) jsNodeNode()    {}
func (ForOfStatement) jsNodeNode()           {}
func (ForOfStatementWithVar) jsNodeNode()    {}
func (ForStatement) jsNodeNode()             {}
func (ForStatementWithVar) jsNodeNode()      {}
func (Function) jsNodeNode()                 {}
func (FunctionExpression) jsNodeNode()       {}
func (Generator) jsNodeNode()                {}
func (GeneratorExpression) jsNodeNode()      {}
func (GeneratorMethod) jsNodeNode()          {}
func (Getter) jsNodeNode()                   {}
func (IdentifierReference) jsNodeNode()      {}
func (IfStatement) jsNodeNode()              {}
func (ImportDeclaration) jsNodeNode()        {}
func (ImportSpecifier) jsNodeNode()          {}
func (IndexAccess) jsNodeNode()              {}
func (Initializer) jsNodeNode()              {}
func (JSXAttributeName) jsNodeNode()         {}
func (JSXClosingElement) jsNodeNode()        {}
func (JSXElement) jsNodeNode()               {}
func (JSXElementName) jsNodeNode()           {}
func (JSXExpression) jsNodeNode()            {}
func (JSXLiteral) jsNodeNode()               {}
func (JSXNormalAttribute) jsNodeNode()       {}
func (JSXOpeningElement) jsNodeNode()        {}
func (JSXSelfClosingElement) jsNodeNode()    {}
func (JSXSpreadAttribute) jsNodeNode()       {}
func (JSXText) jsNodeNode()                  {}
func (LabelIdentifier) jsNodeNode()          {}
func (LabelledStatement) jsNodeNode()        {}
func (LexicalBinding) jsNodeNode()           {}
func (LexicalDeclaration) jsNodeNode()       {}
func (Literal) jsNodeNode()                  {}
func (LiteralPropertyName) jsNodeNode()      {}
func (LogicalANDExpression) jsNodeNode()     {}
func (LogicalORExpression) jsNodeNode()      {}
func (Method) jsNodeNode()                   {}
func (Module) jsNodeNode()                   {}
func (ModuleSpecifier) jsNodeNode()          {}
func (MultiplicativeExpression) jsNodeNode() {}
func (NameSpaceImport) jsNodeNode()          {}
func (NamedImports) jsNodeNode()             {}
func (NewExpression) jsNodeNode()            {}
func (NewTarget) jsNodeNode()                {}
func (ObjectLiteral) jsNodeNode()            {}
func (ObjectPattern) jsNodeNode()            {}
func (Parameter) jsNodeNode()                {}
func (Parameters) jsNodeNode()               {}
func (Parenthesized) jsNodeNode()            {}
func (PostDec) jsNodeNode()                  {}
func (PostInc) jsNodeNode()                  {}
func (PreDec) jsNodeNode()                   {}
func (PreInc) jsNodeNode()                   {}
func (Property) jsNodeNode()                 {}
func (PropertyAccess) jsNodeNode()           {}
func (PropertyBinding) jsNodeNode()          {}
func (Regexp) jsNodeNode()                   {}
func (RelationalExpression) jsNodeNode()     {}
func (RestParameter) jsNodeNode()            {}
func (ReturnStatement) jsNodeNode()          {}
func (Setter) jsNodeNode()                   {}
func (ShiftExpression) jsNodeNode()          {}
func (ShorthandProperty) jsNodeNode()        {}
func (SingleNameBinding) jsNodeNode()        {}
func (SpreadElement) jsNodeNode()            {}
func (StaticMethod) jsNodeNode()             {}
func (SuperExpression) jsNodeNode()          {}
func (SwitchStatement) jsNodeNode()          {}
func (SyntaxError) jsNodeNode()              {}
func (TaggedTemplate) jsNodeNode()           {}
func (TemplateLiteral) jsNodeNode()          {}
func (This) jsNodeNode()                     {}
func (ThrowStatement) jsNodeNode()           {}
func (TryStatement) jsNodeNode()             {}
func (UnaryExpression) jsNodeNode()          {}
func (VariableDeclaration) jsNodeNode()      {}
func (VariableStatement) jsNodeNode()        {}
func (WhileStatement) jsNodeNode()           {}
func (WithStatement) jsNodeNode()            {}
func (Yield) jsNodeNode()                    {}
func (Token) jsNodeNode()                    {}

type BindingPattern interface {
	JsNode
	bindingPatternNode()
}

// bindingPatternNode() ensures that only the following types can be
// assigned to BindingPattern.
//
func (ArrayPattern) bindingPatternNode()  {}
func (ObjectPattern) bindingPatternNode() {}

type CaseClause interface {
	JsNode
	caseClauseNode()
}

// caseClauseNode() ensures that only the following types can be
// assigned to CaseClause.
//
func (Case) caseClauseNode()    {}
func (Default) caseClauseNode() {}

type ClassElement interface {
	JsNode
	classElementNode()
}

// classElementNode() ensures that only the following types can be
// assigned to ClassElement.
//
func (EmptyDecl) classElementNode()       {}
func (GeneratorMethod) classElementNode() {}
func (Getter) classElementNode()          {}
func (Method) classElementNode()          {}
func (Setter) classElementNode()          {}
func (StaticMethod) classElementNode()    {}

type Declaration interface {
	JsNode
	declarationNode()
}

// declarationNode() ensures that only the following types can be
// assigned to Declaration.
//
func (Class) declarationNode()              {}
func (Function) declarationNode()           {}
func (Generator) declarationNode()          {}
func (LexicalDeclaration) declarationNode() {}

type ElementPattern interface {
	JsNode
	elementPatternNode()
}

// elementPatternNode() ensures that only the following types can be
// assigned to ElementPattern.
//
func (ElementBinding) elementPatternNode()    {}
func (SingleNameBinding) elementPatternNode() {}
func (SyntaxError) elementPatternNode()       {}

type ExportElement interface {
	JsNode
	exportElementNode()
}

// exportElementNode() ensures that only the following types can be
// assigned to ExportElement.
//
func (ExportSpecifier) exportElementNode() {}
func (SyntaxError) exportElementNode()     {}

type Expression interface {
	JsNode
	expressionNode()
}

// expressionNode() ensures that only the following types can be
// assigned to Expression.
//
func (AdditiveExpression) expressionNode()       {}
func (ArrayLiteral) expressionNode()             {}
func (ArrowFunction) expressionNode()            {}
func (AssignmentExpression) expressionNode()     {}
func (BitwiseANDExpression) expressionNode()     {}
func (BitwiseORExpression) expressionNode()      {}
func (BitwiseXORExpression) expressionNode()     {}
func (CallExpression) expressionNode()           {}
func (ClassExpr) expressionNode()                {}
func (CommaExpression) expressionNode()          {}
func (ConditionalExpression) expressionNode()    {}
func (EqualityExpression) expressionNode()       {}
func (ExponentiationExpression) expressionNode() {}
func (FunctionExpression) expressionNode()       {}
func (GeneratorExpression) expressionNode()      {}
func (IdentifierReference) expressionNode()      {}
func (IndexAccess) expressionNode()              {}
func (JSXElement) expressionNode()               {}
func (Literal) expressionNode()                  {}
func (LogicalANDExpression) expressionNode()     {}
func (LogicalORExpression) expressionNode()      {}
func (MultiplicativeExpression) expressionNode() {}
func (NewExpression) expressionNode()            {}
func (NewTarget) expressionNode()                {}
func (ObjectLiteral) expressionNode()            {}
func (Parenthesized) expressionNode()            {}
func (PostDec) expressionNode()                  {}
func (PostInc) expressionNode()                  {}
func (PreDec) expressionNode()                   {}
func (PreInc) expressionNode()                   {}
func (PropertyAccess) expressionNode()           {}
func (Regexp) expressionNode()                   {}
func (RelationalExpression) expressionNode()     {}
func (ShiftExpression) expressionNode()          {}
func (SpreadElement) expressionNode()            {}
func (SuperExpression) expressionNode()          {}
func (TaggedTemplate) expressionNode()           {}
func (TemplateLiteral) expressionNode()          {}
func (This) expressionNode()                     {}
func (UnaryExpression) expressionNode()          {}
func (Yield) expressionNode()                    {}

type JSXAttribute interface {
	JsNode
	jSXAttributeNode()
}

// jSXAttributeNode() ensures that only the following types can be
// assigned to JSXAttribute.
//
func (JSXNormalAttribute) jSXAttributeNode() {}
func (JSXSpreadAttribute) jSXAttributeNode() {}

type JSXAttributeValue interface {
	JsNode
	jSXAttributeValueNode()
}

// jSXAttributeValueNode() ensures that only the following types can be
// assigned to JSXAttributeValue.
//
func (JSXElement) jSXAttributeValueNode()    {}
func (JSXExpression) jSXAttributeValueNode() {}
func (JSXLiteral) jSXAttributeValueNode()    {}

type JSXChild interface {
	JsNode
	jSXChildNode()
}

// jSXChildNode() ensures that only the following types can be
// assigned to JSXChild.
//
func (JSXElement) jSXChildNode()    {}
func (JSXExpression) jSXChildNode() {}
func (JSXText) jSXChildNode()       {}

type MethodDefinition interface {
	JsNode
	methodDefinitionNode()
}

// methodDefinitionNode() ensures that only the following types can be
// assigned to MethodDefinition.
//
func (GeneratorMethod) methodDefinitionNode() {}
func (Getter) methodDefinitionNode()          {}
func (Method) methodDefinitionNode()          {}
func (Setter) methodDefinitionNode()          {}

type ModuleItem interface {
	JsNode
	moduleItemNode()
}

// moduleItemNode() ensures that only the following types can be
// assigned to ModuleItem.
//
func (Block) moduleItemNode()                 {}
func (BreakStatement) moduleItemNode()        {}
func (Class) moduleItemNode()                 {}
func (ContinueStatement) moduleItemNode()     {}
func (DebuggerStatement) moduleItemNode()     {}
func (DoWhileStatement) moduleItemNode()      {}
func (EmptyStatement) moduleItemNode()        {}
func (ExportDeclaration) moduleItemNode()     {}
func (ExportDefault) moduleItemNode()         {}
func (ExpressionStatement) moduleItemNode()   {}
func (ForInStatement) moduleItemNode()        {}
func (ForInStatementWithVar) moduleItemNode() {}
func (ForOfStatement) moduleItemNode()        {}
func (ForOfStatementWithVar) moduleItemNode() {}
func (ForStatement) moduleItemNode()          {}
func (ForStatementWithVar) moduleItemNode()   {}
func (Function) moduleItemNode()              {}
func (Generator) moduleItemNode()             {}
func (IfStatement) moduleItemNode()           {}
func (ImportDeclaration) moduleItemNode()     {}
func (LabelledStatement) moduleItemNode()     {}
func (LexicalDeclaration) moduleItemNode()    {}
func (ReturnStatement) moduleItemNode()       {}
func (SwitchStatement) moduleItemNode()       {}
func (SyntaxError) moduleItemNode()           {}
func (ThrowStatement) moduleItemNode()        {}
func (TryStatement) moduleItemNode()          {}
func (VariableStatement) moduleItemNode()     {}
func (WhileStatement) moduleItemNode()        {}
func (WithStatement) moduleItemNode()         {}

type NamedImport interface {
	JsNode
	namedImportNode()
}

// namedImportNode() ensures that only the following types can be
// assigned to NamedImport.
//
func (ImportSpecifier) namedImportNode() {}
func (SyntaxError) namedImportNode()     {}

type PropertyDefinition interface {
	JsNode
	propertyDefinitionNode()
}

// propertyDefinitionNode() ensures that only the following types can be
// assigned to PropertyDefinition.
//
func (GeneratorMethod) propertyDefinitionNode()   {}
func (Getter) propertyDefinitionNode()            {}
func (Method) propertyDefinitionNode()            {}
func (Property) propertyDefinitionNode()          {}
func (Setter) propertyDefinitionNode()            {}
func (ShorthandProperty) propertyDefinitionNode() {}
func (SyntaxError) propertyDefinitionNode()       {}

type PropertyName interface {
	JsNode
	propertyNameNode()
}

// propertyNameNode() ensures that only the following types can be
// assigned to PropertyName.
//
func (ComputedPropertyName) propertyNameNode() {}
func (LiteralPropertyName) propertyNameNode()  {}

type PropertyPattern interface {
	JsNode
	propertyPatternNode()
}

// propertyPatternNode() ensures that only the following types can be
// assigned to PropertyPattern.
//
func (PropertyBinding) propertyPatternNode()   {}
func (SingleNameBinding) propertyPatternNode() {}
func (SyntaxError) propertyPatternNode()       {}

type Statement interface {
	JsNode
	statementNode()
}

// statementNode() ensures that only the following types can be
// assigned to Statement.
//
func (Block) statementNode()                 {}
func (BreakStatement) statementNode()        {}
func (ContinueStatement) statementNode()     {}
func (DebuggerStatement) statementNode()     {}
func (DoWhileStatement) statementNode()      {}
func (EmptyStatement) statementNode()        {}
func (ExpressionStatement) statementNode()   {}
func (ForInStatement) statementNode()        {}
func (ForInStatementWithVar) statementNode() {}
func (ForOfStatement) statementNode()        {}
func (ForOfStatementWithVar) statementNode() {}
func (ForStatement) statementNode()          {}
func (ForStatementWithVar) statementNode()   {}
func (IfStatement) statementNode()           {}
func (LabelledStatement) statementNode()     {}
func (ReturnStatement) statementNode()       {}
func (SwitchStatement) statementNode()       {}
func (ThrowStatement) statementNode()        {}
func (TryStatement) statementNode()          {}
func (VariableStatement) statementNode()     {}
func (WhileStatement) statementNode()        {}
func (WithStatement) statementNode()         {}

type StatementListItem interface {
	JsNode
	statementListItemNode()
}

// statementListItemNode() ensures that only the following types can be
// assigned to StatementListItem.
//
func (Block) statementListItemNode()                 {}
func (BreakStatement) statementListItemNode()        {}
func (Class) statementListItemNode()                 {}
func (ContinueStatement) statementListItemNode()     {}
func (DebuggerStatement) statementListItemNode()     {}
func (DoWhileStatement) statementListItemNode()      {}
func (EmptyStatement) statementListItemNode()        {}
func (ExpressionStatement) statementListItemNode()   {}
func (ForInStatement) statementListItemNode()        {}
func (ForInStatementWithVar) statementListItemNode() {}
func (ForOfStatement) statementListItemNode()        {}
func (ForOfStatementWithVar) statementListItemNode() {}
func (ForStatement) statementListItemNode()          {}
func (ForStatementWithVar) statementListItemNode()   {}
func (Function) statementListItemNode()              {}
func (Generator) statementListItemNode()             {}
func (IfStatement) statementListItemNode()           {}
func (LabelledStatement) statementListItemNode()     {}
func (LexicalDeclaration) statementListItemNode()    {}
func (ReturnStatement) statementListItemNode()       {}
func (SwitchStatement) statementListItemNode()       {}
func (SyntaxError) statementListItemNode()           {}
func (ThrowStatement) statementListItemNode()        {}
func (TryStatement) statementListItemNode()          {}
func (VariableStatement) statementListItemNode()     {}
func (WhileStatement) statementListItemNode()        {}
func (WithStatement) statementListItemNode()         {}

// Types.

type AdditiveExpression struct {
	Node
}

func (n AdditiveExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n AdditiveExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type Arguments struct {
	Node
}

func (n Arguments) List() []Expression {
	nodes := n.Children(selector.Expression)
	var result []Expression = make([]Expression, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(Expression))
	}
	return result
}

type ArrayLiteral struct {
	Node
}

func (n ArrayLiteral) List() []Expression {
	nodes := n.Children(selector.Expression)
	var result []Expression = make([]Expression, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(Expression))
	}
	return result
}

type ArrayPattern struct {
	Node
}

func (n ArrayPattern) ElementPattern() []ElementPattern {
	nodes := n.Children(selector.ElementPattern)
	var result []ElementPattern = make([]ElementPattern, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(ElementPattern))
	}
	return result
}

func (n ArrayPattern) BindingRestElement() *BindingRestElement {
	if child := n.Child(selector.BindingRestElement); child != nil {
		return &BindingRestElement{child}
	}
	return nil
}

type ArrowFunction struct {
	Node
}

func (n ArrowFunction) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n ArrowFunction) Body() *Body {
	if child := n.Child(selector.Body); child != nil {
		return &Body{child}
	}
	return nil
}

func (n ArrowFunction) ConciseBody() *ConciseBody {
	if child := n.Child(selector.ConciseBody); child != nil {
		return &ConciseBody{child}
	}
	return nil
}

type AssignmentExpression struct {
	Node
}

func (n AssignmentExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n AssignmentExpression) AssignmentOperator() *AssignmentOperator {
	if child := n.Child(selector.AssignmentOperator); child != nil {
		return &AssignmentOperator{child}
	}
	return nil
}

func (n AssignmentExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type AssignmentOperator struct {
	Node
}

type BindingIdentifier struct {
	Node
}

type BindingRestElement struct {
	Node
}

func (n BindingRestElement) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

type BitwiseANDExpression struct {
	Node
}

func (n BitwiseANDExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n BitwiseANDExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type BitwiseORExpression struct {
	Node
}

func (n BitwiseORExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n BitwiseORExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type BitwiseXORExpression struct {
	Node
}

func (n BitwiseXORExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n BitwiseXORExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type Block struct {
	Node
}

func (n Block) CaseClause() []CaseClause {
	nodes := n.Children(selector.CaseClause)
	var result []CaseClause = make([]CaseClause, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(CaseClause))
	}
	return result
}

func (n Block) StatementListItem() []StatementListItem {
	nodes := n.Children(selector.StatementListItem)
	var result []StatementListItem = make([]StatementListItem, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(StatementListItem))
	}
	return result
}

type Body struct {
	Node
}

func (n Body) StatementListItem() []StatementListItem {
	nodes := n.Children(selector.StatementListItem)
	var result []StatementListItem = make([]StatementListItem, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(StatementListItem))
	}
	return result
}

type BreakStatement struct {
	Node
}

func (n BreakStatement) LabelIdentifier() *LabelIdentifier {
	if child := n.Child(selector.LabelIdentifier); child != nil {
		return &LabelIdentifier{child}
	}
	return nil
}

type CallExpression struct {
	Node
}

func (n CallExpression) Expr() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n CallExpression) Arguments() Arguments {
	return Arguments{n.Child(selector.Arguments)}
}

type Case struct {
	Node
}

func (n Case) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n Case) StatementListItem() []StatementListItem {
	nodes := n.Children(selector.StatementListItem)
	var result []StatementListItem = make([]StatementListItem, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(StatementListItem))
	}
	return result
}

type Catch struct {
	Node
}

func (n Catch) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

func (n Catch) BindingPattern() BindingPattern {
	if child := n.Child(selector.BindingPattern); child != nil {
		return ToJsNode(child).(BindingPattern)
	}
	return nil
}

func (n Catch) Block() Block {
	return Block{n.Child(selector.Block)}
}

type Class struct {
	Node
}

func (n Class) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

func (n Class) Extends() *Extends {
	if child := n.Child(selector.Extends); child != nil {
		return &Extends{child}
	}
	return nil
}

func (n Class) ClassBody() ClassBody {
	return ClassBody{n.Child(selector.ClassBody)}
}

type ClassBody struct {
	Node
}

func (n ClassBody) ClassElement() []ClassElement {
	nodes := n.Children(selector.ClassElement)
	var result []ClassElement = make([]ClassElement, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(ClassElement))
	}
	return result
}

type ClassExpr struct {
	Node
}

func (n ClassExpr) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

func (n ClassExpr) Extends() *Extends {
	if child := n.Child(selector.Extends); child != nil {
		return &Extends{child}
	}
	return nil
}

func (n ClassExpr) ClassBody() ClassBody {
	return ClassBody{n.Child(selector.ClassBody)}
}

type CommaExpression struct {
	Node
}

func (n CommaExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n CommaExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type ComputedPropertyName struct {
	Node
}

func (n ComputedPropertyName) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type ConciseBody struct {
	Node
}

func (n ConciseBody) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type ConditionalExpression struct {
	Node
}

func (n ConditionalExpression) Cond() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n ConditionalExpression) Then() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

func (n ConditionalExpression) Else() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression).Next(selector.Expression)).(Expression)
}

type ContinueStatement struct {
	Node
}

func (n ContinueStatement) LabelIdentifier() *LabelIdentifier {
	if child := n.Child(selector.LabelIdentifier); child != nil {
		return &LabelIdentifier{child}
	}
	return nil
}

type DebuggerStatement struct {
	Node
}

type Default struct {
	Node
}

func (n Default) StatementListItem() []StatementListItem {
	nodes := n.Children(selector.StatementListItem)
	var result []StatementListItem = make([]StatementListItem, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(StatementListItem))
	}
	return result
}

type DoWhileStatement struct {
	Node
}

func (n DoWhileStatement) Statement() Statement {
	return ToJsNode(n.Child(selector.Statement)).(Statement)
}

func (n DoWhileStatement) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type ElementBinding struct {
	Node
}

func (n ElementBinding) BindingPattern() BindingPattern {
	return ToJsNode(n.Child(selector.BindingPattern)).(BindingPattern)
}

func (n ElementBinding) Initializer() *Initializer {
	if child := n.Child(selector.Initializer); child != nil {
		return &Initializer{child}
	}
	return nil
}

type EmptyDecl struct {
	Node
}

type EmptyStatement struct {
	Node
}

type EqualityExpression struct {
	Node
}

func (n EqualityExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n EqualityExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type ExponentiationExpression struct {
	Node
}

func (n ExponentiationExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n ExponentiationExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type ExportClause struct {
	Node
}

func (n ExportClause) ExportElement() []ExportElement {
	nodes := n.Children(selector.ExportElement)
	var result []ExportElement = make([]ExportElement, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(ExportElement))
	}
	return result
}

type ExportDeclaration struct {
	Node
}

func (n ExportDeclaration) Declaration() Declaration {
	if child := n.Child(selector.Declaration); child != nil {
		return ToJsNode(child).(Declaration)
	}
	return nil
}

func (n ExportDeclaration) ExportClause() *ExportClause {
	if child := n.Child(selector.ExportClause); child != nil {
		return &ExportClause{child}
	}
	return nil
}

func (n ExportDeclaration) VariableStatement() *VariableStatement {
	if child := n.Child(selector.VariableStatement); child != nil {
		return &VariableStatement{child}
	}
	return nil
}

func (n ExportDeclaration) ModuleSpecifier() *ModuleSpecifier {
	if child := n.Child(selector.ModuleSpecifier); child != nil {
		return &ModuleSpecifier{child}
	}
	return nil
}

type ExportDefault struct {
	Node
}

func (n ExportDefault) Declaration() Declaration {
	if child := n.Child(selector.Declaration); child != nil {
		return ToJsNode(child).(Declaration)
	}
	return nil
}

func (n ExportDefault) Expression() Expression {
	if child := n.Child(selector.Expression); child != nil {
		return ToJsNode(child).(Expression)
	}
	return nil
}

type ExportSpecifier struct {
	Node
}

func (n ExportSpecifier) IdentifierReference() IdentifierReference {
	return IdentifierReference{n.Child(selector.IdentifierReference)}
}

func (n ExportSpecifier) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

type ExpressionStatement struct {
	Node
}

func (n ExpressionStatement) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type Extends struct {
	Node
}

func (n Extends) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type Finally struct {
	Node
}

func (n Finally) Block() Block {
	return Block{n.Child(selector.Block)}
}

type ForBinding struct {
	Node
}

func (n ForBinding) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

func (n ForBinding) BindingPattern() BindingPattern {
	if child := n.Child(selector.BindingPattern); child != nil {
		return ToJsNode(child).(BindingPattern)
	}
	return nil
}

type ForCondition struct {
	Node
}

func (n ForCondition) Expression() Expression {
	if child := n.Child(selector.Expression); child != nil {
		return ToJsNode(child).(Expression)
	}
	return nil
}

type ForFinalExpression struct {
	Node
}

func (n ForFinalExpression) Expression() Expression {
	if child := n.Child(selector.Expression); child != nil {
		return ToJsNode(child).(Expression)
	}
	return nil
}

type ForInStatement struct {
	Node
}

func (n ForInStatement) Var() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n ForInStatement) Object() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

func (n ForInStatement) Statement() Statement {
	return ToJsNode(n.Child(selector.Statement)).(Statement)
}

type ForInStatementWithVar struct {
	Node
}

func (n ForInStatementWithVar) ForBinding() ForBinding {
	return ForBinding{n.Child(selector.ForBinding)}
}

func (n ForInStatementWithVar) Object() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n ForInStatementWithVar) Statement() Statement {
	return ToJsNode(n.Child(selector.Statement)).(Statement)
}

type ForOfStatement struct {
	Node
}

func (n ForOfStatement) Var() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n ForOfStatement) Iterable() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

func (n ForOfStatement) Statement() Statement {
	return ToJsNode(n.Child(selector.Statement)).(Statement)
}

type ForOfStatementWithVar struct {
	Node
}

func (n ForOfStatementWithVar) ForBinding() ForBinding {
	return ForBinding{n.Child(selector.ForBinding)}
}

func (n ForOfStatementWithVar) Iterable() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n ForOfStatementWithVar) Statement() Statement {
	return ToJsNode(n.Child(selector.Statement)).(Statement)
}

type ForStatement struct {
	Node
}

func (n ForStatement) Var() Expression {
	if child := n.Child(selector.Expression); child != nil {
		return ToJsNode(child).(Expression)
	}
	return nil
}

func (n ForStatement) ForCondition() ForCondition {
	return ForCondition{n.Child(selector.ForCondition)}
}

func (n ForStatement) ForFinalExpression() ForFinalExpression {
	return ForFinalExpression{n.Child(selector.ForFinalExpression)}
}

func (n ForStatement) Statement() Statement {
	return ToJsNode(n.Child(selector.Statement)).(Statement)
}

type ForStatementWithVar struct {
	Node
}

func (n ForStatementWithVar) LexicalBinding() []LexicalBinding {
	nodes := n.Children(selector.LexicalBinding)
	var result []LexicalBinding = make([]LexicalBinding, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, LexicalBinding{node})
	}
	return result
}

func (n ForStatementWithVar) VariableDeclaration() []VariableDeclaration {
	nodes := n.Children(selector.VariableDeclaration)
	var result []VariableDeclaration = make([]VariableDeclaration, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, VariableDeclaration{node})
	}
	return result
}

func (n ForStatementWithVar) ForCondition() ForCondition {
	return ForCondition{n.Child(selector.ForCondition)}
}

func (n ForStatementWithVar) ForFinalExpression() ForFinalExpression {
	return ForFinalExpression{n.Child(selector.ForFinalExpression)}
}

func (n ForStatementWithVar) Statement() Statement {
	return ToJsNode(n.Child(selector.Statement)).(Statement)
}

type Function struct {
	Node
}

func (n Function) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

func (n Function) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n Function) Body() Body {
	return Body{n.Child(selector.Body)}
}

type FunctionExpression struct {
	Node
}

func (n FunctionExpression) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

func (n FunctionExpression) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n FunctionExpression) Body() Body {
	return Body{n.Child(selector.Body)}
}

type Generator struct {
	Node
}

func (n Generator) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

func (n Generator) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n Generator) Body() Body {
	return Body{n.Child(selector.Body)}
}

type GeneratorExpression struct {
	Node
}

func (n GeneratorExpression) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

func (n GeneratorExpression) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n GeneratorExpression) Body() Body {
	return Body{n.Child(selector.Body)}
}

type GeneratorMethod struct {
	Node
}

func (n GeneratorMethod) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n GeneratorMethod) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n GeneratorMethod) Body() Body {
	return Body{n.Child(selector.Body)}
}

type Getter struct {
	Node
}

func (n Getter) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n Getter) Body() Body {
	return Body{n.Child(selector.Body)}
}

type IdentifierReference struct {
	Node
}

type IfStatement struct {
	Node
}

func (n IfStatement) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n IfStatement) Then() Statement {
	return ToJsNode(n.Child(selector.Statement)).(Statement)
}

func (n IfStatement) Else() Statement {
	if child := n.Child(selector.Statement).Next(selector.Statement); child != nil {
		return ToJsNode(child).(Statement)
	}
	return nil
}

type ImportDeclaration struct {
	Node
}

func (n ImportDeclaration) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

func (n ImportDeclaration) NameSpaceImport() *NameSpaceImport {
	if child := n.Child(selector.NameSpaceImport); child != nil {
		return &NameSpaceImport{child}
	}
	return nil
}

func (n ImportDeclaration) NamedImports() *NamedImports {
	if child := n.Child(selector.NamedImports); child != nil {
		return &NamedImports{child}
	}
	return nil
}

func (n ImportDeclaration) ModuleSpecifier() ModuleSpecifier {
	return ModuleSpecifier{n.Child(selector.ModuleSpecifier)}
}

type ImportSpecifier struct {
	Node
}

func (n ImportSpecifier) IdentifierReference() *IdentifierReference {
	if child := n.Child(selector.IdentifierReference); child != nil {
		return &IdentifierReference{child}
	}
	return nil
}

func (n ImportSpecifier) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

type IndexAccess struct {
	Node
}

func (n IndexAccess) Expr() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n IndexAccess) Index() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type Initializer struct {
	Node
}

func (n Initializer) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type JSXAttributeName struct {
	Node
}

type JSXClosingElement struct {
	Node
}

func (n JSXClosingElement) JSXElementName() JSXElementName {
	return JSXElementName{n.Child(selector.JSXElementName)}
}

type JSXElement struct {
	Node
}

func (n JSXElement) JSXOpeningElement() *JSXOpeningElement {
	if child := n.Child(selector.JSXOpeningElement); child != nil {
		return &JSXOpeningElement{child}
	}
	return nil
}

func (n JSXElement) JSXSelfClosingElement() *JSXSelfClosingElement {
	if child := n.Child(selector.JSXSelfClosingElement); child != nil {
		return &JSXSelfClosingElement{child}
	}
	return nil
}

func (n JSXElement) JSXChild() []JSXChild {
	nodes := n.Children(selector.JSXChild)
	var result []JSXChild = make([]JSXChild, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(JSXChild))
	}
	return result
}

func (n JSXElement) JSXClosingElement() *JSXClosingElement {
	if child := n.Child(selector.JSXClosingElement); child != nil {
		return &JSXClosingElement{child}
	}
	return nil
}

type JSXElementName struct {
	Node
}

type JSXExpression struct {
	Node
}

func (n JSXExpression) Expression() Expression {
	if child := n.Child(selector.Expression); child != nil {
		return ToJsNode(child).(Expression)
	}
	return nil
}

type JSXLiteral struct {
	Node
}

type JSXNormalAttribute struct {
	Node
}

func (n JSXNormalAttribute) JSXAttributeName() JSXAttributeName {
	return JSXAttributeName{n.Child(selector.JSXAttributeName)}
}

func (n JSXNormalAttribute) JSXAttributeValue() JSXAttributeValue {
	return ToJsNode(n.Child(selector.JSXAttributeValue)).(JSXAttributeValue)
}

type JSXOpeningElement struct {
	Node
}

func (n JSXOpeningElement) JSXElementName() JSXElementName {
	return JSXElementName{n.Child(selector.JSXElementName)}
}

func (n JSXOpeningElement) JSXAttribute() []JSXAttribute {
	nodes := n.Children(selector.JSXAttribute)
	var result []JSXAttribute = make([]JSXAttribute, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(JSXAttribute))
	}
	return result
}

type JSXSelfClosingElement struct {
	Node
}

func (n JSXSelfClosingElement) JSXElementName() JSXElementName {
	return JSXElementName{n.Child(selector.JSXElementName)}
}

func (n JSXSelfClosingElement) JSXAttribute() []JSXAttribute {
	nodes := n.Children(selector.JSXAttribute)
	var result []JSXAttribute = make([]JSXAttribute, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(JSXAttribute))
	}
	return result
}

type JSXSpreadAttribute struct {
	Node
}

func (n JSXSpreadAttribute) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type JSXText struct {
	Node
}

type LabelIdentifier struct {
	Node
}

type LabelledStatement struct {
	Node
}

func (n LabelledStatement) Function() *Function {
	if child := n.Child(selector.Function); child != nil {
		return &Function{child}
	}
	return nil
}

func (n LabelledStatement) Statement() Statement {
	if child := n.Child(selector.Statement); child != nil {
		return ToJsNode(child).(Statement)
	}
	return nil
}

type LexicalBinding struct {
	Node
}

func (n LexicalBinding) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

func (n LexicalBinding) BindingPattern() BindingPattern {
	if child := n.Child(selector.BindingPattern); child != nil {
		return ToJsNode(child).(BindingPattern)
	}
	return nil
}

func (n LexicalBinding) Initializer() *Initializer {
	if child := n.Child(selector.Initializer); child != nil {
		return &Initializer{child}
	}
	return nil
}

type LexicalDeclaration struct {
	Node
}

func (n LexicalDeclaration) LexicalBinding() []LexicalBinding {
	nodes := n.Children(selector.LexicalBinding)
	var result []LexicalBinding = make([]LexicalBinding, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, LexicalBinding{node})
	}
	return result
}

type Literal struct {
	Node
}

type LiteralPropertyName struct {
	Node
}

func (n LiteralPropertyName) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

type LogicalANDExpression struct {
	Node
}

func (n LogicalANDExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n LogicalANDExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type LogicalORExpression struct {
	Node
}

func (n LogicalORExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n LogicalORExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type Method struct {
	Node
}

func (n Method) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n Method) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n Method) Body() Body {
	return Body{n.Child(selector.Body)}
}

type Module struct {
	Node
}

func (n Module) ModuleItem() []ModuleItem {
	nodes := n.Children(selector.ModuleItem)
	var result []ModuleItem = make([]ModuleItem, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(ModuleItem))
	}
	return result
}

type ModuleSpecifier struct {
	Node
}

type MultiplicativeExpression struct {
	Node
}

func (n MultiplicativeExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n MultiplicativeExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type NameSpaceImport struct {
	Node
}

func (n NameSpaceImport) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

type NamedImports struct {
	Node
}

func (n NamedImports) NamedImport() []NamedImport {
	nodes := n.Children(selector.NamedImport)
	var result []NamedImport = make([]NamedImport, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(NamedImport))
	}
	return result
}

type NewExpression struct {
	Node
}

func (n NewExpression) Expr() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n NewExpression) Arguments() *Arguments {
	if child := n.Child(selector.Arguments); child != nil {
		return &Arguments{child}
	}
	return nil
}

type NewTarget struct {
	Node
}

type ObjectLiteral struct {
	Node
}

func (n ObjectLiteral) PropertyDefinition() []PropertyDefinition {
	nodes := n.Children(selector.PropertyDefinition)
	var result []PropertyDefinition = make([]PropertyDefinition, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(PropertyDefinition))
	}
	return result
}

type ObjectPattern struct {
	Node
}

func (n ObjectPattern) PropertyPattern() []PropertyPattern {
	nodes := n.Children(selector.PropertyPattern)
	var result []PropertyPattern = make([]PropertyPattern, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(PropertyPattern))
	}
	return result
}

type Parameter struct {
	Node
}

func (n Parameter) ElementPattern() ElementPattern {
	return ToJsNode(n.Child(selector.ElementPattern)).(ElementPattern)
}

type Parameters struct {
	Node
}

func (n Parameters) Expression() Expression {
	if child := n.Child(selector.Expression); child != nil {
		return ToJsNode(child).(Expression)
	}
	return nil
}

func (n Parameters) Parameter() []Parameter {
	nodes := n.Children(selector.Parameter)
	var result []Parameter = make([]Parameter, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, Parameter{node})
	}
	return result
}

func (n Parameters) RestParameter() *RestParameter {
	if child := n.Child(selector.RestParameter); child != nil {
		return &RestParameter{child}
	}
	return nil
}

func (n Parameters) SyntaxError() *SyntaxError {
	if child := n.Child(selector.SyntaxError); child != nil {
		return &SyntaxError{child}
	}
	return nil
}

func (n Parameters) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

func (n Parameters) BindingPattern() BindingPattern {
	if child := n.Child(selector.BindingPattern); child != nil {
		return ToJsNode(child).(BindingPattern)
	}
	return nil
}

type Parenthesized struct {
	Node
}

func (n Parenthesized) Expression() Expression {
	if child := n.Child(selector.Expression); child != nil {
		return ToJsNode(child).(Expression)
	}
	return nil
}

func (n Parenthesized) SyntaxError() *SyntaxError {
	if child := n.Child(selector.SyntaxError); child != nil {
		return &SyntaxError{child}
	}
	return nil
}

func (n Parenthesized) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

func (n Parenthesized) BindingPattern() BindingPattern {
	if child := n.Child(selector.BindingPattern); child != nil {
		return ToJsNode(child).(BindingPattern)
	}
	return nil
}

type PostDec struct {
	Node
}

func (n PostDec) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type PostInc struct {
	Node
}

func (n PostInc) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type PreDec struct {
	Node
}

func (n PreDec) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type PreInc struct {
	Node
}

func (n PreInc) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type Property struct {
	Node
}

func (n Property) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n Property) Value() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type PropertyAccess struct {
	Node
}

func (n PropertyAccess) Expr() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n PropertyAccess) Selector() IdentifierReference {
	return IdentifierReference{n.Child(selector.Expression).Next(selector.IdentifierReference)}
}

type PropertyBinding struct {
	Node
}

func (n PropertyBinding) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n PropertyBinding) ElementPattern() ElementPattern {
	return ToJsNode(n.Child(selector.ElementPattern)).(ElementPattern)
}

type Regexp struct {
	Node
}

type RelationalExpression struct {
	Node
}

func (n RelationalExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n RelationalExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type RestParameter struct {
	Node
}

func (n RestParameter) BindingRestElement() BindingRestElement {
	return BindingRestElement{n.Child(selector.BindingRestElement)}
}

type ReturnStatement struct {
	Node
}

func (n ReturnStatement) Expression() Expression {
	if child := n.Child(selector.Expression); child != nil {
		return ToJsNode(child).(Expression)
	}
	return nil
}

type Setter struct {
	Node
}

func (n Setter) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n Setter) Parameter() Parameter {
	return Parameter{n.Child(selector.Parameter)}
}

func (n Setter) Body() Body {
	return Body{n.Child(selector.Body)}
}

type ShiftExpression struct {
	Node
}

func (n ShiftExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n ShiftExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type ShorthandProperty struct {
	Node
}

func (n ShorthandProperty) IdentifierReference() IdentifierReference {
	return IdentifierReference{n.Child(selector.IdentifierReference)}
}

type SingleNameBinding struct {
	Node
}

func (n SingleNameBinding) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

func (n SingleNameBinding) Initializer() *Initializer {
	if child := n.Child(selector.Initializer); child != nil {
		return &Initializer{child}
	}
	return nil
}

type SpreadElement struct {
	Node
}

func (n SpreadElement) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type StaticMethod struct {
	Node
}

func (n StaticMethod) MethodDefinition() MethodDefinition {
	return ToJsNode(n.Child(selector.MethodDefinition)).(MethodDefinition)
}

type SuperExpression struct {
	Node
}

type SwitchStatement struct {
	Node
}

func (n SwitchStatement) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n SwitchStatement) Block() Block {
	return Block{n.Child(selector.Block)}
}

type SyntaxError struct {
	Node
}

func (n SyntaxError) IdentifierReference() *IdentifierReference {
	if child := n.Child(selector.IdentifierReference); child != nil {
		return &IdentifierReference{child}
	}
	return nil
}

func (n SyntaxError) Initializer() *Initializer {
	if child := n.Child(selector.Initializer); child != nil {
		return &Initializer{child}
	}
	return nil
}

type TaggedTemplate struct {
	Node
}

func (n TaggedTemplate) Tag() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n TaggedTemplate) Literal() TemplateLiteral {
	return TemplateLiteral{n.Child(selector.Expression).Next(selector.TemplateLiteral)}
}

type TemplateLiteral struct {
	Node
}

func (n TemplateLiteral) Template() []Token {
	nodes := n.Children(selector.OneOf(js.NoSubstitutionTemplate, js.TemplateHead, js.TemplateMiddle, js.TemplateTail))
	var result []Token = make([]Token, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(Token))
	}
	return result
}

func (n TemplateLiteral) Substitution() []Expression {
	nodes := n.Children(selector.Expression)
	var result []Expression = make([]Expression, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(Expression))
	}
	return result
}

type This struct {
	Node
}

type ThrowStatement struct {
	Node
}

func (n ThrowStatement) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type TryStatement struct {
	Node
}

func (n TryStatement) Block() Block {
	return Block{n.Child(selector.Block)}
}

func (n TryStatement) Catch() *Catch {
	if child := n.Child(selector.Catch); child != nil {
		return &Catch{child}
	}
	return nil
}

func (n TryStatement) Finally() *Finally {
	if child := n.Child(selector.Finally); child != nil {
		return &Finally{child}
	}
	return nil
}

type UnaryExpression struct {
	Node
}

func (n UnaryExpression) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type VariableDeclaration struct {
	Node
}

func (n VariableDeclaration) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

func (n VariableDeclaration) BindingPattern() BindingPattern {
	if child := n.Child(selector.BindingPattern); child != nil {
		return ToJsNode(child).(BindingPattern)
	}
	return nil
}

func (n VariableDeclaration) Initializer() *Initializer {
	if child := n.Child(selector.Initializer); child != nil {
		return &Initializer{child}
	}
	return nil
}

type VariableStatement struct {
	Node
}

func (n VariableStatement) VariableDeclaration() []VariableDeclaration {
	nodes := n.Children(selector.VariableDeclaration)
	var result []VariableDeclaration = make([]VariableDeclaration, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, VariableDeclaration{node})
	}
	return result
}

type WhileStatement struct {
	Node
}

func (n WhileStatement) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n WhileStatement) Statement() Statement {
	return ToJsNode(n.Child(selector.Statement)).(Statement)
}

type WithStatement struct {
	Node
}

func (n WithStatement) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n WithStatement) Statement() Statement {
	return ToJsNode(n.Child(selector.Statement)).(Statement)
}

type Yield struct {
	Node
}

func (n Yield) Expression() Expression {
	if child := n.Child(selector.Expression); child != nil {
		return ToJsNode(child).(Expression)
	}
	return nil
}
