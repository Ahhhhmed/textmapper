// generated by Textmapper; DO NOT EDIT

package ast

import (
	"github.com/inspirer/textmapper/tm-parsers/js"
	"github.com/inspirer/textmapper/tm-parsers/js/selector"
)

type Node interface {
	Type() js.NodeType
	Offset() int
	Endoffset() int
	// Child returns the first child node that matches the selector.
	Child(sel selector.Selector) Node
	Children(sel selector.Selector) []Node
	// Next returns the first element among the following siblings that matches the selector.
	Next(sel selector.Selector) Node
	// NextAll returns all following siblings of the node that match the selector.
	NextAll(sel selector.Selector) []Node
	Text() string
}

// Interfaces.

type JsNode interface {
	Node
	jsNodeNode()
}

type Token struct {
	Node
}

// All types implement JsNode.
func (Abstract) jsNodeNode()                   {}
func (AccessibilityModifier) jsNodeNode()      {}
func (AdditiveExpression) jsNodeNode()         {}
func (Arguments) jsNodeNode()                  {}
func (ArrayLiteral) jsNodeNode()               {}
func (ArrayPattern) jsNodeNode()               {}
func (ArrayType) jsNodeNode()                  {}
func (ArrowFunction) jsNodeNode()              {}
func (AssignmentExpression) jsNodeNode()       {}
func (AssignmentOperator) jsNodeNode()         {}
func (AsyncArrowFunction) jsNodeNode()         {}
func (AsyncFunction) jsNodeNode()              {}
func (AsyncFunctionExpression) jsNodeNode()    {}
func (AsyncMethod) jsNodeNode()                {}
func (AwaitExpression) jsNodeNode()            {}
func (BindingIdentifier) jsNodeNode()          {}
func (BindingRestElement) jsNodeNode()         {}
func (BitwiseANDExpression) jsNodeNode()       {}
func (BitwiseORExpression) jsNodeNode()        {}
func (BitwiseXORExpression) jsNodeNode()       {}
func (Block) jsNodeNode()                      {}
func (Body) jsNodeNode()                       {}
func (BreakStatement) jsNodeNode()             {}
func (CallExpression) jsNodeNode()             {}
func (CallSignature) jsNodeNode()              {}
func (Case) jsNodeNode()                       {}
func (Catch) jsNodeNode()                      {}
func (Class) jsNodeNode()                      {}
func (ClassBody) jsNodeNode()                  {}
func (ClassExpr) jsNodeNode()                  {}
func (CommaExpression) jsNodeNode()            {}
func (ComputedPropertyName) jsNodeNode()       {}
func (ConciseBody) jsNodeNode()                {}
func (ConditionalExpression) jsNodeNode()      {}
func (ConstructSignature) jsNodeNode()         {}
func (ConstructorType) jsNodeNode()            {}
func (ContinueStatement) jsNodeNode()          {}
func (DebuggerStatement) jsNodeNode()          {}
func (DecoratorCall) jsNodeNode()              {}
func (DecoratorExpr) jsNodeNode()              {}
func (Default) jsNodeNode()                    {}
func (DefaultParameter) jsNodeNode()           {}
func (DoWhileStatement) jsNodeNode()           {}
func (ElementBinding) jsNodeNode()             {}
func (EmptyDecl) jsNodeNode()                  {}
func (EmptyStatement) jsNodeNode()             {}
func (EqualityExpression) jsNodeNode()         {}
func (ExponentiationExpression) jsNodeNode()   {}
func (ExportClause) jsNodeNode()               {}
func (ExportDeclaration) jsNodeNode()          {}
func (ExportDefault) jsNodeNode()              {}
func (ExportSpecifier) jsNodeNode()            {}
func (ExpressionStatement) jsNodeNode()        {}
func (Extends) jsNodeNode()                    {}
func (Finally) jsNodeNode()                    {}
func (ForBinding) jsNodeNode()                 {}
func (ForCondition) jsNodeNode()               {}
func (ForFinalExpression) jsNodeNode()         {}
func (ForInStatement) jsNodeNode()             {}
func (ForInStatementWithVar) jsNodeNode()      {}
func (ForOfStatement) jsNodeNode()             {}
func (ForOfStatementWithVar) jsNodeNode()      {}
func (ForStatement) jsNodeNode()               {}
func (ForStatementWithVar) jsNodeNode()        {}
func (Function) jsNodeNode()                   {}
func (FunctionExpression) jsNodeNode()         {}
func (FunctionType) jsNodeNode()               {}
func (Generator) jsNodeNode()                  {}
func (GeneratorExpression) jsNodeNode()        {}
func (GeneratorMethod) jsNodeNode()            {}
func (Getter) jsNodeNode()                     {}
func (IdentifierReference) jsNodeNode()        {}
func (IfStatement) jsNodeNode()                {}
func (ImportDeclaration) jsNodeNode()          {}
func (ImportSpecifier) jsNodeNode()            {}
func (IndexAccess) jsNodeNode()                {}
func (IndexSignature) jsNodeNode()             {}
func (IndexedAccessType) jsNodeNode()          {}
func (Initializer) jsNodeNode()                {}
func (IntersectionType) jsNodeNode()           {}
func (JSXAttributeName) jsNodeNode()           {}
func (JSXClosingElement) jsNodeNode()          {}
func (JSXElement) jsNodeNode()                 {}
func (JSXElementName) jsNodeNode()             {}
func (JSXExpression) jsNodeNode()              {}
func (JSXLiteral) jsNodeNode()                 {}
func (JSXNormalAttribute) jsNodeNode()         {}
func (JSXOpeningElement) jsNodeNode()          {}
func (JSXSelfClosingElement) jsNodeNode()      {}
func (JSXSpreadAttribute) jsNodeNode()         {}
func (JSXSpreadExpression) jsNodeNode()        {}
func (JSXText) jsNodeNode()                    {}
func (KeyOfType) jsNodeNode()                  {}
func (LabelIdentifier) jsNodeNode()            {}
func (LabelledStatement) jsNodeNode()          {}
func (LexicalBinding) jsNodeNode()             {}
func (LexicalDeclaration) jsNodeNode()         {}
func (Literal) jsNodeNode()                    {}
func (LiteralPropertyName) jsNodeNode()        {}
func (LiteralType) jsNodeNode()                {}
func (LogicalANDExpression) jsNodeNode()       {}
func (LogicalORExpression) jsNodeNode()        {}
func (MappedType) jsNodeNode()                 {}
func (MemberMethod) jsNodeNode()               {}
func (MemberVar) jsNodeNode()                  {}
func (Method) jsNodeNode()                     {}
func (MethodSignature) jsNodeNode()            {}
func (Module) jsNodeNode()                     {}
func (ModuleSpecifier) jsNodeNode()            {}
func (MultiplicativeExpression) jsNodeNode()   {}
func (NameSpaceImport) jsNodeNode()            {}
func (NamedImports) jsNodeNode()               {}
func (NewExpression) jsNodeNode()              {}
func (NewTarget) jsNodeNode()                  {}
func (ObjectLiteral) jsNodeNode()              {}
func (ObjectMethod) jsNodeNode()               {}
func (ObjectPattern) jsNodeNode()              {}
func (ObjectType) jsNodeNode()                 {}
func (Parameters) jsNodeNode()                 {}
func (Parenthesized) jsNodeNode()              {}
func (ParenthesizedType) jsNodeNode()          {}
func (PostDec) jsNodeNode()                    {}
func (PostInc) jsNodeNode()                    {}
func (PreDec) jsNodeNode()                     {}
func (PreInc) jsNodeNode()                     {}
func (PredefinedType) jsNodeNode()             {}
func (Property) jsNodeNode()                   {}
func (PropertyAccess) jsNodeNode()             {}
func (PropertyBinding) jsNodeNode()            {}
func (PropertySignature) jsNodeNode()          {}
func (Readonly) jsNodeNode()                   {}
func (Regexp) jsNodeNode()                     {}
func (RelationalExpression) jsNodeNode()       {}
func (RestParameter) jsNodeNode()              {}
func (ReturnStatement) jsNodeNode()            {}
func (Setter) jsNodeNode()                     {}
func (ShiftExpression) jsNodeNode()            {}
func (ShorthandProperty) jsNodeNode()          {}
func (SingleNameBinding) jsNodeNode()          {}
func (SpreadElement) jsNodeNode()              {}
func (SpreadProperty) jsNodeNode()             {}
func (Static) jsNodeNode()                     {}
func (SuperExpression) jsNodeNode()            {}
func (SwitchStatement) jsNodeNode()            {}
func (SyntaxProblem) jsNodeNode()              {}
func (TaggedTemplate) jsNodeNode()             {}
func (TemplateLiteral) jsNodeNode()            {}
func (This) jsNodeNode()                       {}
func (ThisType) jsNodeNode()                   {}
func (ThrowStatement) jsNodeNode()             {}
func (TryStatement) jsNodeNode()               {}
func (TsAmbientBinding) jsNodeNode()           {}
func (TsAmbientClass) jsNodeNode()             {}
func (TsAmbientClassBody) jsNodeNode()         {}
func (TsAmbientEnum) jsNodeNode()              {}
func (TsAmbientFunction) jsNodeNode()          {}
func (TsAmbientFunctionMember) jsNodeNode()    {}
func (TsAmbientImportAlias) jsNodeNode()       {}
func (TsAmbientIndexMember) jsNodeNode()       {}
func (TsAmbientInterface) jsNodeNode()         {}
func (TsAmbientModule) jsNodeNode()            {}
func (TsAmbientNamespace) jsNodeNode()         {}
func (TsAmbientPropertyMember) jsNodeNode()    {}
func (TsAmbientTypeAlias) jsNodeNode()         {}
func (TsAmbientVar) jsNodeNode()               {}
func (TsAsExpression) jsNodeNode()             {}
func (TsCastExpression) jsNodeNode()           {}
func (TsEnum) jsNodeNode()                     {}
func (TsEnumBody) jsNodeNode()                 {}
func (TsEnumMember) jsNodeNode()               {}
func (TsExportAssignment) jsNodeNode()         {}
func (TsImplementsClause) jsNodeNode()         {}
func (TsImportAliasDeclaration) jsNodeNode()   {}
func (TsImportRequireDeclaration) jsNodeNode() {}
func (TsIndexMemberDeclaration) jsNodeNode()   {}
func (TsInterface) jsNodeNode()                {}
func (TsInterfaceExtends) jsNodeNode()         {}
func (TsNamespace) jsNodeNode()                {}
func (TsNamespaceBody) jsNodeNode()            {}
func (TsNonNull) jsNodeNode()                  {}
func (TsThisParameter) jsNodeNode()            {}
func (TupleType) jsNodeNode()                  {}
func (TypeAliasDeclaration) jsNodeNode()       {}
func (TypeAnnotation) jsNodeNode()             {}
func (TypeArguments) jsNodeNode()              {}
func (TypeConstraint) jsNodeNode()             {}
func (TypeName) jsNodeNode()                   {}
func (TypeParameter) jsNodeNode()              {}
func (TypeParameters) jsNodeNode()             {}
func (TypePredicate) jsNodeNode()              {}
func (TypeQuery) jsNodeNode()                  {}
func (TypeReference) jsNodeNode()              {}
func (UnaryExpression) jsNodeNode()            {}
func (UnionType) jsNodeNode()                  {}
func (VariableDeclaration) jsNodeNode()        {}
func (VariableStatement) jsNodeNode()          {}
func (WhileStatement) jsNodeNode()             {}
func (WithStatement) jsNodeNode()              {}
func (Yield) jsNodeNode()                      {}
func (Token) jsNodeNode()                      {}

type BindingPattern interface {
	JsNode
	bindingPatternNode()
}

// bindingPatternNode() ensures that only the following types can be
// assigned to BindingPattern.
//
func (ArrayPattern) bindingPatternNode()  {}
func (ObjectPattern) bindingPatternNode() {}

type CaseClause interface {
	JsNode
	caseClauseNode()
}

// caseClauseNode() ensures that only the following types can be
// assigned to CaseClause.
//
func (Case) caseClauseNode()    {}
func (Default) caseClauseNode() {}

type ClassElement interface {
	JsNode
	classElementNode()
}

// classElementNode() ensures that only the following types can be
// assigned to ClassElement.
//
func (EmptyDecl) classElementNode()                {}
func (MemberMethod) classElementNode()             {}
func (MemberVar) classElementNode()                {}
func (TsIndexMemberDeclaration) classElementNode() {}

type Declaration interface {
	JsNode
	declarationNode()
}

// declarationNode() ensures that only the following types can be
// assigned to Declaration.
//
func (AsyncFunction) declarationNode()            {}
func (Class) declarationNode()                    {}
func (Function) declarationNode()                 {}
func (Generator) declarationNode()                {}
func (LexicalDeclaration) declarationNode()       {}
func (TsAmbientClass) declarationNode()           {}
func (TsAmbientEnum) declarationNode()            {}
func (TsAmbientFunction) declarationNode()        {}
func (TsAmbientImportAlias) declarationNode()     {}
func (TsAmbientInterface) declarationNode()       {}
func (TsAmbientModule) declarationNode()          {}
func (TsAmbientNamespace) declarationNode()       {}
func (TsAmbientTypeAlias) declarationNode()       {}
func (TsAmbientVar) declarationNode()             {}
func (TsEnum) declarationNode()                   {}
func (TsImportAliasDeclaration) declarationNode() {}
func (TsInterface) declarationNode()              {}
func (TsNamespace) declarationNode()              {}
func (TypeAliasDeclaration) declarationNode()     {}

type Decorator interface {
	JsNode
	decoratorNode()
}

// decoratorNode() ensures that only the following types can be
// assigned to Decorator.
//
func (DecoratorCall) decoratorNode() {}
func (DecoratorExpr) decoratorNode() {}

type ElementPattern interface {
	JsNode
	elementPatternNode()
}

// elementPatternNode() ensures that only the following types can be
// assigned to ElementPattern.
//
func (ElementBinding) elementPatternNode()    {}
func (SingleNameBinding) elementPatternNode() {}
func (SyntaxProblem) elementPatternNode()     {}

type ExportElement interface {
	JsNode
	exportElementNode()
}

// exportElementNode() ensures that only the following types can be
// assigned to ExportElement.
//
func (ExportSpecifier) exportElementNode() {}
func (SyntaxProblem) exportElementNode()   {}

type Expression interface {
	JsNode
	expressionNode()
}

// expressionNode() ensures that only the following types can be
// assigned to Expression.
//
func (AdditiveExpression) expressionNode()       {}
func (ArrayLiteral) expressionNode()             {}
func (ArrowFunction) expressionNode()            {}
func (AssignmentExpression) expressionNode()     {}
func (AsyncArrowFunction) expressionNode()       {}
func (AsyncFunctionExpression) expressionNode()  {}
func (AwaitExpression) expressionNode()          {}
func (BitwiseANDExpression) expressionNode()     {}
func (BitwiseORExpression) expressionNode()      {}
func (BitwiseXORExpression) expressionNode()     {}
func (CallExpression) expressionNode()           {}
func (ClassExpr) expressionNode()                {}
func (CommaExpression) expressionNode()          {}
func (ConditionalExpression) expressionNode()    {}
func (EqualityExpression) expressionNode()       {}
func (ExponentiationExpression) expressionNode() {}
func (FunctionExpression) expressionNode()       {}
func (GeneratorExpression) expressionNode()      {}
func (IdentifierReference) expressionNode()      {}
func (IndexAccess) expressionNode()              {}
func (JSXElement) expressionNode()               {}
func (Literal) expressionNode()                  {}
func (LogicalANDExpression) expressionNode()     {}
func (LogicalORExpression) expressionNode()      {}
func (MultiplicativeExpression) expressionNode() {}
func (NewExpression) expressionNode()            {}
func (NewTarget) expressionNode()                {}
func (ObjectLiteral) expressionNode()            {}
func (Parenthesized) expressionNode()            {}
func (PostDec) expressionNode()                  {}
func (PostInc) expressionNode()                  {}
func (PreDec) expressionNode()                   {}
func (PreInc) expressionNode()                   {}
func (PropertyAccess) expressionNode()           {}
func (Regexp) expressionNode()                   {}
func (RelationalExpression) expressionNode()     {}
func (ShiftExpression) expressionNode()          {}
func (SpreadElement) expressionNode()            {}
func (SuperExpression) expressionNode()          {}
func (TaggedTemplate) expressionNode()           {}
func (TemplateLiteral) expressionNode()          {}
func (This) expressionNode()                     {}
func (TsAsExpression) expressionNode()           {}
func (TsCastExpression) expressionNode()         {}
func (TsNonNull) expressionNode()                {}
func (UnaryExpression) expressionNode()          {}
func (Yield) expressionNode()                    {}

type JSXAttribute interface {
	JsNode
	jSXAttributeNode()
}

// jSXAttributeNode() ensures that only the following types can be
// assigned to JSXAttribute.
//
func (JSXNormalAttribute) jSXAttributeNode() {}
func (JSXSpreadAttribute) jSXAttributeNode() {}

type JSXAttributeValue interface {
	JsNode
	jSXAttributeValueNode()
}

// jSXAttributeValueNode() ensures that only the following types can be
// assigned to JSXAttributeValue.
//
func (JSXElement) jSXAttributeValueNode()    {}
func (JSXExpression) jSXAttributeValueNode() {}
func (JSXLiteral) jSXAttributeValueNode()    {}

type JSXChild interface {
	JsNode
	jSXChildNode()
}

// jSXChildNode() ensures that only the following types can be
// assigned to JSXChild.
//
func (JSXElement) jSXChildNode()          {}
func (JSXExpression) jSXChildNode()       {}
func (JSXSpreadExpression) jSXChildNode() {}
func (JSXText) jSXChildNode()             {}

type MethodDefinition interface {
	JsNode
	methodDefinitionNode()
}

// methodDefinitionNode() ensures that only the following types can be
// assigned to MethodDefinition.
//
func (AsyncMethod) methodDefinitionNode()     {}
func (GeneratorMethod) methodDefinitionNode() {}
func (Getter) methodDefinitionNode()          {}
func (Method) methodDefinitionNode()          {}
func (Setter) methodDefinitionNode()          {}

type Modifier interface {
	JsNode
	modifierNode()
}

// modifierNode() ensures that only the following types can be
// assigned to Modifier.
//
func (Abstract) modifierNode()              {}
func (AccessibilityModifier) modifierNode() {}
func (DecoratorCall) modifierNode()         {}
func (DecoratorExpr) modifierNode()         {}
func (Readonly) modifierNode()              {}
func (Static) modifierNode()                {}

type ModuleItem interface {
	JsNode
	moduleItemNode()
}

// moduleItemNode() ensures that only the following types can be
// assigned to ModuleItem.
//
func (AsyncFunction) moduleItemNode()              {}
func (Block) moduleItemNode()                      {}
func (BreakStatement) moduleItemNode()             {}
func (Class) moduleItemNode()                      {}
func (ContinueStatement) moduleItemNode()          {}
func (DebuggerStatement) moduleItemNode()          {}
func (DoWhileStatement) moduleItemNode()           {}
func (EmptyStatement) moduleItemNode()             {}
func (ExportDeclaration) moduleItemNode()          {}
func (ExportDefault) moduleItemNode()              {}
func (ExpressionStatement) moduleItemNode()        {}
func (ForInStatement) moduleItemNode()             {}
func (ForInStatementWithVar) moduleItemNode()      {}
func (ForOfStatement) moduleItemNode()             {}
func (ForOfStatementWithVar) moduleItemNode()      {}
func (ForStatement) moduleItemNode()               {}
func (ForStatementWithVar) moduleItemNode()        {}
func (Function) moduleItemNode()                   {}
func (Generator) moduleItemNode()                  {}
func (IfStatement) moduleItemNode()                {}
func (ImportDeclaration) moduleItemNode()          {}
func (LabelledStatement) moduleItemNode()          {}
func (LexicalDeclaration) moduleItemNode()         {}
func (ReturnStatement) moduleItemNode()            {}
func (SwitchStatement) moduleItemNode()            {}
func (SyntaxProblem) moduleItemNode()              {}
func (ThrowStatement) moduleItemNode()             {}
func (TryStatement) moduleItemNode()               {}
func (TsAmbientClass) moduleItemNode()             {}
func (TsAmbientEnum) moduleItemNode()              {}
func (TsAmbientFunction) moduleItemNode()          {}
func (TsAmbientImportAlias) moduleItemNode()       {}
func (TsAmbientInterface) moduleItemNode()         {}
func (TsAmbientModule) moduleItemNode()            {}
func (TsAmbientNamespace) moduleItemNode()         {}
func (TsAmbientTypeAlias) moduleItemNode()         {}
func (TsAmbientVar) moduleItemNode()               {}
func (TsEnum) moduleItemNode()                     {}
func (TsExportAssignment) moduleItemNode()         {}
func (TsImportAliasDeclaration) moduleItemNode()   {}
func (TsImportRequireDeclaration) moduleItemNode() {}
func (TsInterface) moduleItemNode()                {}
func (TsNamespace) moduleItemNode()                {}
func (TypeAliasDeclaration) moduleItemNode()       {}
func (VariableStatement) moduleItemNode()          {}
func (WhileStatement) moduleItemNode()             {}
func (WithStatement) moduleItemNode()              {}

type NamedImport interface {
	JsNode
	namedImportNode()
}

// namedImportNode() ensures that only the following types can be
// assigned to NamedImport.
//
func (ImportSpecifier) namedImportNode() {}
func (SyntaxProblem) namedImportNode()   {}

type Parameter interface {
	JsNode
	parameterNode()
}

// parameterNode() ensures that only the following types can be
// assigned to Parameter.
//
func (DefaultParameter) parameterNode() {}
func (RestParameter) parameterNode()    {}
func (SyntaxProblem) parameterNode()    {}
func (TsThisParameter) parameterNode()  {}

type PropertyDefinition interface {
	JsNode
	propertyDefinitionNode()
}

// propertyDefinitionNode() ensures that only the following types can be
// assigned to PropertyDefinition.
//
func (ObjectMethod) propertyDefinitionNode()      {}
func (Property) propertyDefinitionNode()          {}
func (ShorthandProperty) propertyDefinitionNode() {}
func (SpreadProperty) propertyDefinitionNode()    {}
func (SyntaxProblem) propertyDefinitionNode()     {}

type PropertyName interface {
	JsNode
	propertyNameNode()
}

// propertyNameNode() ensures that only the following types can be
// assigned to PropertyName.
//
func (ComputedPropertyName) propertyNameNode() {}
func (LiteralPropertyName) propertyNameNode()  {}

type PropertyPattern interface {
	JsNode
	propertyPatternNode()
}

// propertyPatternNode() ensures that only the following types can be
// assigned to PropertyPattern.
//
func (PropertyBinding) propertyPatternNode()   {}
func (SingleNameBinding) propertyPatternNode() {}
func (SyntaxProblem) propertyPatternNode()     {}

type Statement interface {
	JsNode
	statementNode()
}

// statementNode() ensures that only the following types can be
// assigned to Statement.
//
func (Block) statementNode()                 {}
func (BreakStatement) statementNode()        {}
func (ContinueStatement) statementNode()     {}
func (DebuggerStatement) statementNode()     {}
func (DoWhileStatement) statementNode()      {}
func (EmptyStatement) statementNode()        {}
func (ExpressionStatement) statementNode()   {}
func (ForInStatement) statementNode()        {}
func (ForInStatementWithVar) statementNode() {}
func (ForOfStatement) statementNode()        {}
func (ForOfStatementWithVar) statementNode() {}
func (ForStatement) statementNode()          {}
func (ForStatementWithVar) statementNode()   {}
func (IfStatement) statementNode()           {}
func (LabelledStatement) statementNode()     {}
func (ReturnStatement) statementNode()       {}
func (SwitchStatement) statementNode()       {}
func (ThrowStatement) statementNode()        {}
func (TryStatement) statementNode()          {}
func (VariableStatement) statementNode()     {}
func (WhileStatement) statementNode()        {}
func (WithStatement) statementNode()         {}

type StatementListItem interface {
	JsNode
	statementListItemNode()
}

// statementListItemNode() ensures that only the following types can be
// assigned to StatementListItem.
//
func (AsyncFunction) statementListItemNode()            {}
func (Block) statementListItemNode()                    {}
func (BreakStatement) statementListItemNode()           {}
func (Class) statementListItemNode()                    {}
func (ContinueStatement) statementListItemNode()        {}
func (DebuggerStatement) statementListItemNode()        {}
func (DoWhileStatement) statementListItemNode()         {}
func (EmptyStatement) statementListItemNode()           {}
func (ExpressionStatement) statementListItemNode()      {}
func (ForInStatement) statementListItemNode()           {}
func (ForInStatementWithVar) statementListItemNode()    {}
func (ForOfStatement) statementListItemNode()           {}
func (ForOfStatementWithVar) statementListItemNode()    {}
func (ForStatement) statementListItemNode()             {}
func (ForStatementWithVar) statementListItemNode()      {}
func (Function) statementListItemNode()                 {}
func (Generator) statementListItemNode()                {}
func (IfStatement) statementListItemNode()              {}
func (LabelledStatement) statementListItemNode()        {}
func (LexicalDeclaration) statementListItemNode()       {}
func (ReturnStatement) statementListItemNode()          {}
func (SwitchStatement) statementListItemNode()          {}
func (SyntaxProblem) statementListItemNode()            {}
func (ThrowStatement) statementListItemNode()           {}
func (TryStatement) statementListItemNode()             {}
func (TsAmbientClass) statementListItemNode()           {}
func (TsAmbientEnum) statementListItemNode()            {}
func (TsAmbientFunction) statementListItemNode()        {}
func (TsAmbientImportAlias) statementListItemNode()     {}
func (TsAmbientInterface) statementListItemNode()       {}
func (TsAmbientModule) statementListItemNode()          {}
func (TsAmbientNamespace) statementListItemNode()       {}
func (TsAmbientTypeAlias) statementListItemNode()       {}
func (TsAmbientVar) statementListItemNode()             {}
func (TsEnum) statementListItemNode()                   {}
func (TsImportAliasDeclaration) statementListItemNode() {}
func (TsInterface) statementListItemNode()              {}
func (TsNamespace) statementListItemNode()              {}
func (TypeAliasDeclaration) statementListItemNode()     {}
func (VariableStatement) statementListItemNode()        {}
func (WhileStatement) statementListItemNode()           {}
func (WithStatement) statementListItemNode()            {}

type TsAmbientClassElement interface {
	JsNode
	tsAmbientClassElementNode()
}

// tsAmbientClassElementNode() ensures that only the following types can be
// assigned to TsAmbientClassElement.
//
func (TsAmbientFunctionMember) tsAmbientClassElementNode() {}
func (TsAmbientIndexMember) tsAmbientClassElementNode()    {}
func (TsAmbientPropertyMember) tsAmbientClassElementNode() {}

type TsAmbientElement interface {
	JsNode
	tsAmbientElementNode()
}

// tsAmbientElementNode() ensures that only the following types can be
// assigned to TsAmbientElement.
//
func (TsAmbientClass) tsAmbientElementNode()       {}
func (TsAmbientEnum) tsAmbientElementNode()        {}
func (TsAmbientFunction) tsAmbientElementNode()    {}
func (TsAmbientImportAlias) tsAmbientElementNode() {}
func (TsAmbientInterface) tsAmbientElementNode()   {}
func (TsAmbientModule) tsAmbientElementNode()      {}
func (TsAmbientNamespace) tsAmbientElementNode()   {}
func (TsAmbientTypeAlias) tsAmbientElementNode()   {}
func (TsAmbientVar) tsAmbientElementNode()         {}

type TsType interface {
	JsNode
	tsTypeNode()
}

// tsTypeNode() ensures that only the following types can be
// assigned to TsType.
//
func (ArrayType) tsTypeNode()         {}
func (ConstructorType) tsTypeNode()   {}
func (FunctionType) tsTypeNode()      {}
func (IndexedAccessType) tsTypeNode() {}
func (IntersectionType) tsTypeNode()  {}
func (KeyOfType) tsTypeNode()         {}
func (LiteralType) tsTypeNode()       {}
func (MappedType) tsTypeNode()        {}
func (ObjectType) tsTypeNode()        {}
func (ParenthesizedType) tsTypeNode() {}
func (PredefinedType) tsTypeNode()    {}
func (ThisType) tsTypeNode()          {}
func (TupleType) tsTypeNode()         {}
func (TypePredicate) tsTypeNode()     {}
func (TypeQuery) tsTypeNode()         {}
func (TypeReference) tsTypeNode()     {}
func (UnionType) tsTypeNode()         {}

type TypeMember interface {
	JsNode
	typeMemberNode()
}

// typeMemberNode() ensures that only the following types can be
// assigned to TypeMember.
//
func (CallSignature) typeMemberNode()      {}
func (ConstructSignature) typeMemberNode() {}
func (IndexSignature) typeMemberNode()     {}
func (MethodSignature) typeMemberNode()    {}
func (PropertySignature) typeMemberNode()  {}

// Types.

type Abstract struct {
	Node
}

type AccessibilityModifier struct {
	Node
}

type AdditiveExpression struct {
	Node
}

func (n AdditiveExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n AdditiveExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type Arguments struct {
	Node
}

func (n Arguments) TypeArguments() *TypeArguments {
	if child := n.Child(selector.TypeArguments); child != nil {
		return &TypeArguments{child}
	}
	return nil
}

func (n Arguments) List() []Expression {
	nodes := n.Children(selector.Expression)
	var result []Expression = make([]Expression, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(Expression))
	}
	return result
}

type ArrayLiteral struct {
	Node
}

func (n ArrayLiteral) List() []Expression {
	nodes := n.Children(selector.Expression)
	var result []Expression = make([]Expression, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(Expression))
	}
	return result
}

type ArrayPattern struct {
	Node
}

func (n ArrayPattern) ElementPattern() []ElementPattern {
	nodes := n.Children(selector.ElementPattern)
	var result []ElementPattern = make([]ElementPattern, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(ElementPattern))
	}
	return result
}

func (n ArrayPattern) BindingRestElement() *BindingRestElement {
	if child := n.Child(selector.BindingRestElement); child != nil {
		return &BindingRestElement{child}
	}
	return nil
}

type ArrayType struct {
	Node
}

func (n ArrayType) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type ArrowFunction struct {
	Node
}

func (n ArrowFunction) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

func (n ArrowFunction) TypeParameters() *TypeParameters {
	if child := n.Child(selector.TypeParameters); child != nil {
		return &TypeParameters{child}
	}
	return nil
}

func (n ArrowFunction) Parameters() *Parameters {
	if child := n.Child(selector.Parameters); child != nil {
		return &Parameters{child}
	}
	return nil
}

func (n ArrowFunction) TypeAnnotation() *TypeAnnotation {
	if child := n.Child(selector.TypeAnnotation); child != nil {
		return &TypeAnnotation{child}
	}
	return nil
}

func (n ArrowFunction) Body() *Body {
	if child := n.Child(selector.Body); child != nil {
		return &Body{child}
	}
	return nil
}

func (n ArrowFunction) ConciseBody() *ConciseBody {
	if child := n.Child(selector.ConciseBody); child != nil {
		return &ConciseBody{child}
	}
	return nil
}

type AssignmentExpression struct {
	Node
}

func (n AssignmentExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n AssignmentExpression) AssignmentOperator() *AssignmentOperator {
	if child := n.Child(selector.AssignmentOperator); child != nil {
		return &AssignmentOperator{child}
	}
	return nil
}

func (n AssignmentExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type AssignmentOperator struct {
	Node
}

type AsyncArrowFunction struct {
	Node
}

func (n AsyncArrowFunction) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

func (n AsyncArrowFunction) TypeParameters() *TypeParameters {
	if child := n.Child(selector.TypeParameters); child != nil {
		return &TypeParameters{child}
	}
	return nil
}

func (n AsyncArrowFunction) Parameters() *Parameters {
	if child := n.Child(selector.Parameters); child != nil {
		return &Parameters{child}
	}
	return nil
}

func (n AsyncArrowFunction) TypeAnnotation() *TypeAnnotation {
	if child := n.Child(selector.TypeAnnotation); child != nil {
		return &TypeAnnotation{child}
	}
	return nil
}

func (n AsyncArrowFunction) Body() *Body {
	if child := n.Child(selector.Body); child != nil {
		return &Body{child}
	}
	return nil
}

func (n AsyncArrowFunction) ConciseBody() *ConciseBody {
	if child := n.Child(selector.ConciseBody); child != nil {
		return &ConciseBody{child}
	}
	return nil
}

type AsyncFunction struct {
	Node
}

func (n AsyncFunction) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

func (n AsyncFunction) TypeParameters() *TypeParameters {
	if child := n.Child(selector.TypeParameters); child != nil {
		return &TypeParameters{child}
	}
	return nil
}

func (n AsyncFunction) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n AsyncFunction) TypeAnnotation() *TypeAnnotation {
	if child := n.Child(selector.TypeAnnotation); child != nil {
		return &TypeAnnotation{child}
	}
	return nil
}

func (n AsyncFunction) Body() Body {
	return Body{n.Child(selector.Body)}
}

type AsyncFunctionExpression struct {
	Node
}

func (n AsyncFunctionExpression) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

func (n AsyncFunctionExpression) TypeParameters() *TypeParameters {
	if child := n.Child(selector.TypeParameters); child != nil {
		return &TypeParameters{child}
	}
	return nil
}

func (n AsyncFunctionExpression) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n AsyncFunctionExpression) TypeAnnotation() *TypeAnnotation {
	if child := n.Child(selector.TypeAnnotation); child != nil {
		return &TypeAnnotation{child}
	}
	return nil
}

func (n AsyncFunctionExpression) Body() Body {
	return Body{n.Child(selector.Body)}
}

type AsyncMethod struct {
	Node
}

func (n AsyncMethod) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n AsyncMethod) TypeParameters() *TypeParameters {
	if child := n.Child(selector.TypeParameters); child != nil {
		return &TypeParameters{child}
	}
	return nil
}

func (n AsyncMethod) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n AsyncMethod) TypeAnnotation() *TypeAnnotation {
	if child := n.Child(selector.TypeAnnotation); child != nil {
		return &TypeAnnotation{child}
	}
	return nil
}

func (n AsyncMethod) Body() Body {
	return Body{n.Child(selector.Body)}
}

type AwaitExpression struct {
	Node
}

func (n AwaitExpression) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type BindingIdentifier struct {
	Node
}

type BindingRestElement struct {
	Node
}

func (n BindingRestElement) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

type BitwiseANDExpression struct {
	Node
}

func (n BitwiseANDExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n BitwiseANDExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type BitwiseORExpression struct {
	Node
}

func (n BitwiseORExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n BitwiseORExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type BitwiseXORExpression struct {
	Node
}

func (n BitwiseXORExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n BitwiseXORExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type Block struct {
	Node
}

func (n Block) CaseClause() []CaseClause {
	nodes := n.Children(selector.CaseClause)
	var result []CaseClause = make([]CaseClause, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(CaseClause))
	}
	return result
}

func (n Block) StatementListItem() []StatementListItem {
	nodes := n.Children(selector.StatementListItem)
	var result []StatementListItem = make([]StatementListItem, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(StatementListItem))
	}
	return result
}

type Body struct {
	Node
}

func (n Body) StatementListItem() []StatementListItem {
	nodes := n.Children(selector.StatementListItem)
	var result []StatementListItem = make([]StatementListItem, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(StatementListItem))
	}
	return result
}

type BreakStatement struct {
	Node
}

func (n BreakStatement) LabelIdentifier() *LabelIdentifier {
	if child := n.Child(selector.LabelIdentifier); child != nil {
		return &LabelIdentifier{child}
	}
	return nil
}

type CallExpression struct {
	Node
}

func (n CallExpression) Expr() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n CallExpression) Arguments() Arguments {
	return Arguments{n.Child(selector.Arguments)}
}

type CallSignature struct {
	Node
}

func (n CallSignature) TypeParameters() *TypeParameters {
	if child := n.Child(selector.TypeParameters); child != nil {
		return &TypeParameters{child}
	}
	return nil
}

func (n CallSignature) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n CallSignature) TypeAnnotation() *TypeAnnotation {
	if child := n.Child(selector.TypeAnnotation); child != nil {
		return &TypeAnnotation{child}
	}
	return nil
}

type Case struct {
	Node
}

func (n Case) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n Case) StatementListItem() []StatementListItem {
	nodes := n.Children(selector.StatementListItem)
	var result []StatementListItem = make([]StatementListItem, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(StatementListItem))
	}
	return result
}

type Catch struct {
	Node
}

func (n Catch) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

func (n Catch) BindingPattern() BindingPattern {
	if child := n.Child(selector.BindingPattern); child != nil {
		return ToJsNode(child).(BindingPattern)
	}
	return nil
}

func (n Catch) Block() Block {
	return Block{n.Child(selector.Block)}
}

type Class struct {
	Node
}

func (n Class) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var result []Modifier = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(Modifier))
	}
	return result
}

func (n Class) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

func (n Class) TypeParameters() *TypeParameters {
	if child := n.Child(selector.TypeParameters); child != nil {
		return &TypeParameters{child}
	}
	return nil
}

func (n Class) Extends() *Extends {
	if child := n.Child(selector.Extends); child != nil {
		return &Extends{child}
	}
	return nil
}

func (n Class) TsImplementsClause() *TsImplementsClause {
	if child := n.Child(selector.TsImplementsClause); child != nil {
		return &TsImplementsClause{child}
	}
	return nil
}

func (n Class) ClassBody() ClassBody {
	return ClassBody{n.Child(selector.ClassBody)}
}

type ClassBody struct {
	Node
}

func (n ClassBody) ClassElement() []ClassElement {
	nodes := n.Children(selector.ClassElement)
	var result []ClassElement = make([]ClassElement, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(ClassElement))
	}
	return result
}

type ClassExpr struct {
	Node
}

func (n ClassExpr) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var result []Modifier = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(Modifier))
	}
	return result
}

func (n ClassExpr) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

func (n ClassExpr) TypeParameters() *TypeParameters {
	if child := n.Child(selector.TypeParameters); child != nil {
		return &TypeParameters{child}
	}
	return nil
}

func (n ClassExpr) Extends() *Extends {
	if child := n.Child(selector.Extends); child != nil {
		return &Extends{child}
	}
	return nil
}

func (n ClassExpr) TsImplementsClause() *TsImplementsClause {
	if child := n.Child(selector.TsImplementsClause); child != nil {
		return &TsImplementsClause{child}
	}
	return nil
}

func (n ClassExpr) ClassBody() ClassBody {
	return ClassBody{n.Child(selector.ClassBody)}
}

type CommaExpression struct {
	Node
}

func (n CommaExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n CommaExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type ComputedPropertyName struct {
	Node
}

func (n ComputedPropertyName) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type ConciseBody struct {
	Node
}

func (n ConciseBody) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type ConditionalExpression struct {
	Node
}

func (n ConditionalExpression) Cond() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n ConditionalExpression) Then() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

func (n ConditionalExpression) Else() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression).Next(selector.Expression)).(Expression)
}

type ConstructSignature struct {
	Node
}

func (n ConstructSignature) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var result []Modifier = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(Modifier))
	}
	return result
}

func (n ConstructSignature) TypeParameters() *TypeParameters {
	if child := n.Child(selector.TypeParameters); child != nil {
		return &TypeParameters{child}
	}
	return nil
}

func (n ConstructSignature) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n ConstructSignature) TypeAnnotation() *TypeAnnotation {
	if child := n.Child(selector.TypeAnnotation); child != nil {
		return &TypeAnnotation{child}
	}
	return nil
}

type ConstructorType struct {
	Node
}

func (n ConstructorType) TypeParameters() *TypeParameters {
	if child := n.Child(selector.TypeParameters); child != nil {
		return &TypeParameters{child}
	}
	return nil
}

func (n ConstructorType) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n ConstructorType) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type ContinueStatement struct {
	Node
}

func (n ContinueStatement) LabelIdentifier() *LabelIdentifier {
	if child := n.Child(selector.LabelIdentifier); child != nil {
		return &LabelIdentifier{child}
	}
	return nil
}

type DebuggerStatement struct {
	Node
}

type DecoratorCall struct {
	Node
}

func (n DecoratorCall) IdentifierReference() []IdentifierReference {
	nodes := n.Children(selector.IdentifierReference)
	var result []IdentifierReference = make([]IdentifierReference, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, IdentifierReference{node})
	}
	return result
}

func (n DecoratorCall) Arguments() Arguments {
	return Arguments{n.Child(selector.Arguments)}
}

type DecoratorExpr struct {
	Node
}

func (n DecoratorExpr) IdentifierReference() []IdentifierReference {
	nodes := n.Children(selector.IdentifierReference)
	var result []IdentifierReference = make([]IdentifierReference, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, IdentifierReference{node})
	}
	return result
}

type Default struct {
	Node
}

func (n Default) StatementListItem() []StatementListItem {
	nodes := n.Children(selector.StatementListItem)
	var result []StatementListItem = make([]StatementListItem, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(StatementListItem))
	}
	return result
}

type DefaultParameter struct {
	Node
}

func (n DefaultParameter) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var result []Modifier = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(Modifier))
	}
	return result
}

func (n DefaultParameter) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

func (n DefaultParameter) BindingPattern() BindingPattern {
	if child := n.Child(selector.BindingPattern); child != nil {
		return ToJsNode(child).(BindingPattern)
	}
	return nil
}

func (n DefaultParameter) TypeAnnotation() *TypeAnnotation {
	if child := n.Child(selector.TypeAnnotation); child != nil {
		return &TypeAnnotation{child}
	}
	return nil
}

func (n DefaultParameter) Initializer() *Initializer {
	if child := n.Child(selector.Initializer); child != nil {
		return &Initializer{child}
	}
	return nil
}

type DoWhileStatement struct {
	Node
}

func (n DoWhileStatement) Statement() Statement {
	return ToJsNode(n.Child(selector.Statement)).(Statement)
}

func (n DoWhileStatement) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type ElementBinding struct {
	Node
}

func (n ElementBinding) BindingPattern() BindingPattern {
	return ToJsNode(n.Child(selector.BindingPattern)).(BindingPattern)
}

func (n ElementBinding) Initializer() *Initializer {
	if child := n.Child(selector.Initializer); child != nil {
		return &Initializer{child}
	}
	return nil
}

type EmptyDecl struct {
	Node
}

type EmptyStatement struct {
	Node
}

type EqualityExpression struct {
	Node
}

func (n EqualityExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n EqualityExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type ExponentiationExpression struct {
	Node
}

func (n ExponentiationExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n ExponentiationExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type ExportClause struct {
	Node
}

func (n ExportClause) ExportElement() []ExportElement {
	nodes := n.Children(selector.ExportElement)
	var result []ExportElement = make([]ExportElement, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(ExportElement))
	}
	return result
}

type ExportDeclaration struct {
	Node
}

func (n ExportDeclaration) ExportClause() *ExportClause {
	if child := n.Child(selector.ExportClause); child != nil {
		return &ExportClause{child}
	}
	return nil
}

func (n ExportDeclaration) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var result []Modifier = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(Modifier))
	}
	return result
}

func (n ExportDeclaration) VariableStatement() *VariableStatement {
	if child := n.Child(selector.VariableStatement); child != nil {
		return &VariableStatement{child}
	}
	return nil
}

func (n ExportDeclaration) Declaration() Declaration {
	if child := n.Child(selector.Declaration); child != nil {
		return ToJsNode(child).(Declaration)
	}
	return nil
}

func (n ExportDeclaration) ModuleSpecifier() *ModuleSpecifier {
	if child := n.Child(selector.ModuleSpecifier); child != nil {
		return &ModuleSpecifier{child}
	}
	return nil
}

type ExportDefault struct {
	Node
}

func (n ExportDefault) Expression() Expression {
	if child := n.Child(selector.Expression); child != nil {
		return ToJsNode(child).(Expression)
	}
	return nil
}

func (n ExportDefault) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var result []Modifier = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(Modifier))
	}
	return result
}

func (n ExportDefault) Declaration() Declaration {
	if child := n.Child(selector.Declaration); child != nil {
		return ToJsNode(child).(Declaration)
	}
	return nil
}

type ExportSpecifier struct {
	Node
}

func (n ExportSpecifier) IdentifierReference() IdentifierReference {
	return IdentifierReference{n.Child(selector.IdentifierReference)}
}

func (n ExportSpecifier) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

type ExpressionStatement struct {
	Node
}

func (n ExpressionStatement) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type Extends struct {
	Node
}

func (n Extends) Expression() Expression {
	if child := n.Child(selector.Expression); child != nil {
		return ToJsNode(child).(Expression)
	}
	return nil
}

func (n Extends) TypeReference() *TypeReference {
	if child := n.Child(selector.TypeReference); child != nil {
		return &TypeReference{child}
	}
	return nil
}

type Finally struct {
	Node
}

func (n Finally) Block() Block {
	return Block{n.Child(selector.Block)}
}

type ForBinding struct {
	Node
}

func (n ForBinding) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

func (n ForBinding) BindingPattern() BindingPattern {
	if child := n.Child(selector.BindingPattern); child != nil {
		return ToJsNode(child).(BindingPattern)
	}
	return nil
}

type ForCondition struct {
	Node
}

func (n ForCondition) Expression() Expression {
	if child := n.Child(selector.Expression); child != nil {
		return ToJsNode(child).(Expression)
	}
	return nil
}

type ForFinalExpression struct {
	Node
}

func (n ForFinalExpression) Expression() Expression {
	if child := n.Child(selector.Expression); child != nil {
		return ToJsNode(child).(Expression)
	}
	return nil
}

type ForInStatement struct {
	Node
}

func (n ForInStatement) Var() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n ForInStatement) Object() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

func (n ForInStatement) Statement() Statement {
	return ToJsNode(n.Child(selector.Statement)).(Statement)
}

type ForInStatementWithVar struct {
	Node
}

func (n ForInStatementWithVar) ForBinding() ForBinding {
	return ForBinding{n.Child(selector.ForBinding)}
}

func (n ForInStatementWithVar) Object() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n ForInStatementWithVar) Statement() Statement {
	return ToJsNode(n.Child(selector.Statement)).(Statement)
}

type ForOfStatement struct {
	Node
}

func (n ForOfStatement) Var() JsNode {
	return ToJsNode(n.Child(selector.OneOf(js.AdditiveExpression, js.ArrayLiteral, js.ArrowFunction, js.AssignmentExpression, js.AsyncArrowFunction, js.AsyncFunctionExpression, js.AwaitExpression, js.BitwiseANDExpression, js.BitwiseORExpression, js.BitwiseXORExpression, js.CallExpression, js.ClassExpr, js.CommaExpression, js.ConditionalExpression, js.EqualityExpression, js.ExponentiationExpression, js.FunctionExpression, js.GeneratorExpression, js.IdentifierReference, js.IndexAccess, js.JSXElement, js.Literal, js.LogicalANDExpression, js.LogicalORExpression, js.MultiplicativeExpression, js.NewExpression, js.NewTarget, js.ObjectLiteral, js.Parenthesized, js.PostDec, js.PostInc, js.PreDec, js.PreInc, js.PropertyAccess, js.Regexp, js.RelationalExpression, js.ShiftExpression, js.SpreadElement, js.SuperExpression, js.TaggedTemplate, js.TemplateLiteral, js.This, js.TsAsExpression, js.TsCastExpression, js.TsNonNull, js.UnaryExpression, js.Yield))).(JsNode)
}

func (n ForOfStatement) Iterable() Expression {
	return ToJsNode(n.Child(selector.OneOf(js.AdditiveExpression, js.ArrayLiteral, js.ArrowFunction, js.AssignmentExpression, js.AsyncArrowFunction, js.AsyncFunctionExpression, js.AwaitExpression, js.BitwiseANDExpression, js.BitwiseORExpression, js.BitwiseXORExpression, js.CallExpression, js.ClassExpr, js.CommaExpression, js.ConditionalExpression, js.EqualityExpression, js.ExponentiationExpression, js.FunctionExpression, js.GeneratorExpression, js.IdentifierReference, js.IndexAccess, js.JSXElement, js.Literal, js.LogicalANDExpression, js.LogicalORExpression, js.MultiplicativeExpression, js.NewExpression, js.NewTarget, js.ObjectLiteral, js.Parenthesized, js.PostDec, js.PostInc, js.PreDec, js.PreInc, js.PropertyAccess, js.Regexp, js.RelationalExpression, js.ShiftExpression, js.SpreadElement, js.SuperExpression, js.TaggedTemplate, js.TemplateLiteral, js.This, js.TsAsExpression, js.TsCastExpression, js.TsNonNull, js.UnaryExpression, js.Yield)).Next(selector.Expression)).(Expression)
}

func (n ForOfStatement) Statement() Statement {
	return ToJsNode(n.Child(selector.Statement)).(Statement)
}

type ForOfStatementWithVar struct {
	Node
}

func (n ForOfStatementWithVar) ForBinding() ForBinding {
	return ForBinding{n.Child(selector.ForBinding)}
}

func (n ForOfStatementWithVar) Iterable() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n ForOfStatementWithVar) Statement() Statement {
	return ToJsNode(n.Child(selector.Statement)).(Statement)
}

type ForStatement struct {
	Node
}

func (n ForStatement) Var() Expression {
	if child := n.Child(selector.Expression); child != nil {
		return ToJsNode(child).(Expression)
	}
	return nil
}

func (n ForStatement) ForCondition() ForCondition {
	return ForCondition{n.Child(selector.ForCondition)}
}

func (n ForStatement) ForFinalExpression() ForFinalExpression {
	return ForFinalExpression{n.Child(selector.ForFinalExpression)}
}

func (n ForStatement) Statement() Statement {
	return ToJsNode(n.Child(selector.Statement)).(Statement)
}

type ForStatementWithVar struct {
	Node
}

func (n ForStatementWithVar) LexicalBinding() []LexicalBinding {
	nodes := n.Children(selector.LexicalBinding)
	var result []LexicalBinding = make([]LexicalBinding, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, LexicalBinding{node})
	}
	return result
}

func (n ForStatementWithVar) VariableDeclaration() []VariableDeclaration {
	nodes := n.Children(selector.VariableDeclaration)
	var result []VariableDeclaration = make([]VariableDeclaration, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, VariableDeclaration{node})
	}
	return result
}

func (n ForStatementWithVar) ForCondition() ForCondition {
	return ForCondition{n.Child(selector.ForCondition)}
}

func (n ForStatementWithVar) ForFinalExpression() ForFinalExpression {
	return ForFinalExpression{n.Child(selector.ForFinalExpression)}
}

func (n ForStatementWithVar) Statement() Statement {
	return ToJsNode(n.Child(selector.Statement)).(Statement)
}

type Function struct {
	Node
}

func (n Function) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

func (n Function) TypeParameters() *TypeParameters {
	if child := n.Child(selector.TypeParameters); child != nil {
		return &TypeParameters{child}
	}
	return nil
}

func (n Function) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n Function) TypeAnnotation() *TypeAnnotation {
	if child := n.Child(selector.TypeAnnotation); child != nil {
		return &TypeAnnotation{child}
	}
	return nil
}

func (n Function) Body() Body {
	return Body{n.Child(selector.Body)}
}

type FunctionExpression struct {
	Node
}

func (n FunctionExpression) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

func (n FunctionExpression) TypeParameters() *TypeParameters {
	if child := n.Child(selector.TypeParameters); child != nil {
		return &TypeParameters{child}
	}
	return nil
}

func (n FunctionExpression) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n FunctionExpression) TypeAnnotation() *TypeAnnotation {
	if child := n.Child(selector.TypeAnnotation); child != nil {
		return &TypeAnnotation{child}
	}
	return nil
}

func (n FunctionExpression) Body() Body {
	return Body{n.Child(selector.Body)}
}

type FunctionType struct {
	Node
}

func (n FunctionType) TypeParameters() *TypeParameters {
	if child := n.Child(selector.TypeParameters); child != nil {
		return &TypeParameters{child}
	}
	return nil
}

func (n FunctionType) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n FunctionType) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type Generator struct {
	Node
}

func (n Generator) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

func (n Generator) TypeParameters() *TypeParameters {
	if child := n.Child(selector.TypeParameters); child != nil {
		return &TypeParameters{child}
	}
	return nil
}

func (n Generator) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n Generator) TypeAnnotation() *TypeAnnotation {
	if child := n.Child(selector.TypeAnnotation); child != nil {
		return &TypeAnnotation{child}
	}
	return nil
}

func (n Generator) Body() Body {
	return Body{n.Child(selector.Body)}
}

type GeneratorExpression struct {
	Node
}

func (n GeneratorExpression) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

func (n GeneratorExpression) TypeParameters() *TypeParameters {
	if child := n.Child(selector.TypeParameters); child != nil {
		return &TypeParameters{child}
	}
	return nil
}

func (n GeneratorExpression) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n GeneratorExpression) TypeAnnotation() *TypeAnnotation {
	if child := n.Child(selector.TypeAnnotation); child != nil {
		return &TypeAnnotation{child}
	}
	return nil
}

func (n GeneratorExpression) Body() Body {
	return Body{n.Child(selector.Body)}
}

type GeneratorMethod struct {
	Node
}

func (n GeneratorMethod) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n GeneratorMethod) TypeParameters() *TypeParameters {
	if child := n.Child(selector.TypeParameters); child != nil {
		return &TypeParameters{child}
	}
	return nil
}

func (n GeneratorMethod) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n GeneratorMethod) TypeAnnotation() *TypeAnnotation {
	if child := n.Child(selector.TypeAnnotation); child != nil {
		return &TypeAnnotation{child}
	}
	return nil
}

func (n GeneratorMethod) Body() Body {
	return Body{n.Child(selector.Body)}
}

type Getter struct {
	Node
}

func (n Getter) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n Getter) TypeAnnotation() *TypeAnnotation {
	if child := n.Child(selector.TypeAnnotation); child != nil {
		return &TypeAnnotation{child}
	}
	return nil
}

func (n Getter) Body() Body {
	return Body{n.Child(selector.Body)}
}

type IdentifierReference struct {
	Node
}

type IfStatement struct {
	Node
}

func (n IfStatement) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n IfStatement) Then() Statement {
	return ToJsNode(n.Child(selector.Statement)).(Statement)
}

func (n IfStatement) Else() Statement {
	if child := n.Child(selector.Statement).Next(selector.Statement); child != nil {
		return ToJsNode(child).(Statement)
	}
	return nil
}

type ImportDeclaration struct {
	Node
}

func (n ImportDeclaration) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

func (n ImportDeclaration) NameSpaceImport() *NameSpaceImport {
	if child := n.Child(selector.NameSpaceImport); child != nil {
		return &NameSpaceImport{child}
	}
	return nil
}

func (n ImportDeclaration) NamedImports() *NamedImports {
	if child := n.Child(selector.NamedImports); child != nil {
		return &NamedImports{child}
	}
	return nil
}

func (n ImportDeclaration) ModuleSpecifier() ModuleSpecifier {
	return ModuleSpecifier{n.Child(selector.ModuleSpecifier)}
}

type ImportSpecifier struct {
	Node
}

func (n ImportSpecifier) IdentifierReference() *IdentifierReference {
	if child := n.Child(selector.IdentifierReference); child != nil {
		return &IdentifierReference{child}
	}
	return nil
}

func (n ImportSpecifier) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

type IndexAccess struct {
	Node
}

func (n IndexAccess) Expr() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n IndexAccess) Index() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type IndexSignature struct {
	Node
}

func (n IndexSignature) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var result []Modifier = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(Modifier))
	}
	return result
}

func (n IndexSignature) TypeAnnotation() TypeAnnotation {
	return TypeAnnotation{n.Child(selector.TypeAnnotation)}
}

type IndexedAccessType struct {
	Node
}

func (n IndexedAccessType) Left() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

func (n IndexedAccessType) Index() TsType {
	return ToJsNode(n.Child(selector.TsType).Next(selector.TsType)).(TsType)
}

type Initializer struct {
	Node
}

func (n Initializer) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type IntersectionType struct {
	Node
}

func (n IntersectionType) Inner() []TsType {
	nodes := n.Children(selector.TsType)
	var result []TsType = make([]TsType, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(TsType))
	}
	return result
}

type JSXAttributeName struct {
	Node
}

type JSXClosingElement struct {
	Node
}

func (n JSXClosingElement) JSXElementName() JSXElementName {
	return JSXElementName{n.Child(selector.JSXElementName)}
}

type JSXElement struct {
	Node
}

func (n JSXElement) JSXOpeningElement() *JSXOpeningElement {
	if child := n.Child(selector.JSXOpeningElement); child != nil {
		return &JSXOpeningElement{child}
	}
	return nil
}

func (n JSXElement) JSXSelfClosingElement() *JSXSelfClosingElement {
	if child := n.Child(selector.JSXSelfClosingElement); child != nil {
		return &JSXSelfClosingElement{child}
	}
	return nil
}

func (n JSXElement) JSXChild() []JSXChild {
	nodes := n.Children(selector.JSXChild)
	var result []JSXChild = make([]JSXChild, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(JSXChild))
	}
	return result
}

func (n JSXElement) JSXClosingElement() *JSXClosingElement {
	if child := n.Child(selector.JSXClosingElement); child != nil {
		return &JSXClosingElement{child}
	}
	return nil
}

type JSXElementName struct {
	Node
}

type JSXExpression struct {
	Node
}

func (n JSXExpression) Expression() Expression {
	if child := n.Child(selector.Expression); child != nil {
		return ToJsNode(child).(Expression)
	}
	return nil
}

type JSXLiteral struct {
	Node
}

type JSXNormalAttribute struct {
	Node
}

func (n JSXNormalAttribute) JSXAttributeName() JSXAttributeName {
	return JSXAttributeName{n.Child(selector.JSXAttributeName)}
}

func (n JSXNormalAttribute) JSXAttributeValue() JSXAttributeValue {
	if child := n.Child(selector.JSXAttributeValue); child != nil {
		return ToJsNode(child).(JSXAttributeValue)
	}
	return nil
}

type JSXOpeningElement struct {
	Node
}

func (n JSXOpeningElement) JSXElementName() JSXElementName {
	return JSXElementName{n.Child(selector.JSXElementName)}
}

func (n JSXOpeningElement) JSXAttribute() []JSXAttribute {
	nodes := n.Children(selector.JSXAttribute)
	var result []JSXAttribute = make([]JSXAttribute, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(JSXAttribute))
	}
	return result
}

type JSXSelfClosingElement struct {
	Node
}

func (n JSXSelfClosingElement) JSXElementName() JSXElementName {
	return JSXElementName{n.Child(selector.JSXElementName)}
}

func (n JSXSelfClosingElement) JSXAttribute() []JSXAttribute {
	nodes := n.Children(selector.JSXAttribute)
	var result []JSXAttribute = make([]JSXAttribute, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(JSXAttribute))
	}
	return result
}

type JSXSpreadAttribute struct {
	Node
}

func (n JSXSpreadAttribute) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type JSXSpreadExpression struct {
	Node
}

func (n JSXSpreadExpression) Expression() Expression {
	if child := n.Child(selector.Expression); child != nil {
		return ToJsNode(child).(Expression)
	}
	return nil
}

type JSXText struct {
	Node
}

type KeyOfType struct {
	Node
}

func (n KeyOfType) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type LabelIdentifier struct {
	Node
}

type LabelledStatement struct {
	Node
}

func (n LabelledStatement) LabelIdentifier() LabelIdentifier {
	return LabelIdentifier{n.Child(selector.LabelIdentifier)}
}

func (n LabelledStatement) Function() *Function {
	if child := n.Child(selector.Function); child != nil {
		return &Function{child}
	}
	return nil
}

func (n LabelledStatement) Statement() Statement {
	if child := n.Child(selector.Statement); child != nil {
		return ToJsNode(child).(Statement)
	}
	return nil
}

type LexicalBinding struct {
	Node
}

func (n LexicalBinding) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

func (n LexicalBinding) BindingPattern() BindingPattern {
	if child := n.Child(selector.BindingPattern); child != nil {
		return ToJsNode(child).(BindingPattern)
	}
	return nil
}

func (n LexicalBinding) TypeAnnotation() *TypeAnnotation {
	if child := n.Child(selector.TypeAnnotation); child != nil {
		return &TypeAnnotation{child}
	}
	return nil
}

func (n LexicalBinding) Initializer() *Initializer {
	if child := n.Child(selector.Initializer); child != nil {
		return &Initializer{child}
	}
	return nil
}

type LexicalDeclaration struct {
	Node
}

func (n LexicalDeclaration) LexicalBinding() []LexicalBinding {
	nodes := n.Children(selector.LexicalBinding)
	var result []LexicalBinding = make([]LexicalBinding, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, LexicalBinding{node})
	}
	return result
}

type Literal struct {
	Node
}

type LiteralPropertyName struct {
	Node
}

func (n LiteralPropertyName) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

type LiteralType struct {
	Node
}

type LogicalANDExpression struct {
	Node
}

func (n LogicalANDExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n LogicalANDExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type LogicalORExpression struct {
	Node
}

func (n LogicalORExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n LogicalORExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type MappedType struct {
	Node
}

func (n MappedType) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

func (n MappedType) TypeAnnotation() TypeAnnotation {
	return TypeAnnotation{n.Child(selector.TypeAnnotation)}
}

type MemberMethod struct {
	Node
}

func (n MemberMethod) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var result []Modifier = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(Modifier))
	}
	return result
}

func (n MemberMethod) MethodDefinition() MethodDefinition {
	return ToJsNode(n.Child(selector.MethodDefinition)).(MethodDefinition)
}

type MemberVar struct {
	Node
}

func (n MemberVar) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var result []Modifier = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(Modifier))
	}
	return result
}

func (n MemberVar) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n MemberVar) TypeAnnotation() *TypeAnnotation {
	if child := n.Child(selector.TypeAnnotation); child != nil {
		return &TypeAnnotation{child}
	}
	return nil
}

func (n MemberVar) Initializer() *Initializer {
	if child := n.Child(selector.Initializer); child != nil {
		return &Initializer{child}
	}
	return nil
}

type Method struct {
	Node
}

func (n Method) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n Method) TypeParameters() *TypeParameters {
	if child := n.Child(selector.TypeParameters); child != nil {
		return &TypeParameters{child}
	}
	return nil
}

func (n Method) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n Method) TypeAnnotation() *TypeAnnotation {
	if child := n.Child(selector.TypeAnnotation); child != nil {
		return &TypeAnnotation{child}
	}
	return nil
}

func (n Method) Body() Body {
	return Body{n.Child(selector.Body)}
}

type MethodSignature struct {
	Node
}

func (n MethodSignature) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var result []Modifier = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(Modifier))
	}
	return result
}

func (n MethodSignature) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n MethodSignature) TypeParameters() *TypeParameters {
	if child := n.Child(selector.TypeParameters); child != nil {
		return &TypeParameters{child}
	}
	return nil
}

func (n MethodSignature) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n MethodSignature) TypeAnnotation() *TypeAnnotation {
	if child := n.Child(selector.TypeAnnotation); child != nil {
		return &TypeAnnotation{child}
	}
	return nil
}

type Module struct {
	Node
}

func (n Module) ModuleItem() []ModuleItem {
	nodes := n.Children(selector.ModuleItem)
	var result []ModuleItem = make([]ModuleItem, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(ModuleItem))
	}
	return result
}

type ModuleSpecifier struct {
	Node
}

type MultiplicativeExpression struct {
	Node
}

func (n MultiplicativeExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n MultiplicativeExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type NameSpaceImport struct {
	Node
}

func (n NameSpaceImport) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

type NamedImports struct {
	Node
}

func (n NamedImports) NamedImport() []NamedImport {
	nodes := n.Children(selector.NamedImport)
	var result []NamedImport = make([]NamedImport, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(NamedImport))
	}
	return result
}

type NewExpression struct {
	Node
}

func (n NewExpression) Expr() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n NewExpression) Arguments() *Arguments {
	if child := n.Child(selector.Arguments); child != nil {
		return &Arguments{child}
	}
	return nil
}

type NewTarget struct {
	Node
}

type ObjectLiteral struct {
	Node
}

func (n ObjectLiteral) PropertyDefinition() []PropertyDefinition {
	nodes := n.Children(selector.PropertyDefinition)
	var result []PropertyDefinition = make([]PropertyDefinition, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(PropertyDefinition))
	}
	return result
}

type ObjectMethod struct {
	Node
}

func (n ObjectMethod) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var result []Modifier = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(Modifier))
	}
	return result
}

func (n ObjectMethod) MethodDefinition() MethodDefinition {
	return ToJsNode(n.Child(selector.MethodDefinition)).(MethodDefinition)
}

type ObjectPattern struct {
	Node
}

func (n ObjectPattern) PropertyPattern() []PropertyPattern {
	nodes := n.Children(selector.PropertyPattern)
	var result []PropertyPattern = make([]PropertyPattern, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(PropertyPattern))
	}
	return result
}

func (n ObjectPattern) BindingRestElement() *BindingRestElement {
	if child := n.Child(selector.BindingRestElement); child != nil {
		return &BindingRestElement{child}
	}
	return nil
}

type ObjectType struct {
	Node
}

func (n ObjectType) TypeMember() []TypeMember {
	nodes := n.Children(selector.TypeMember)
	var result []TypeMember = make([]TypeMember, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(TypeMember))
	}
	return result
}

type Parameters struct {
	Node
}

func (n Parameters) Parameter() []Parameter {
	nodes := n.Children(selector.Parameter)
	var result []Parameter = make([]Parameter, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(Parameter))
	}
	return result
}

type Parenthesized struct {
	Node
}

func (n Parenthesized) Expression() Expression {
	if child := n.Child(selector.Expression); child != nil {
		return ToJsNode(child).(Expression)
	}
	return nil
}

func (n Parenthesized) SyntaxProblem() *SyntaxProblem {
	if child := n.Child(selector.SyntaxProblem); child != nil {
		return &SyntaxProblem{child}
	}
	return nil
}

type ParenthesizedType struct {
	Node
}

func (n ParenthesizedType) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type PostDec struct {
	Node
}

func (n PostDec) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type PostInc struct {
	Node
}

func (n PostInc) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type PreDec struct {
	Node
}

func (n PreDec) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type PreInc struct {
	Node
}

func (n PreInc) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type PredefinedType struct {
	Node
}

type Property struct {
	Node
}

func (n Property) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var result []Modifier = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(Modifier))
	}
	return result
}

func (n Property) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n Property) Value() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type PropertyAccess struct {
	Node
}

func (n PropertyAccess) Expr() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n PropertyAccess) Selector() IdentifierReference {
	return IdentifierReference{n.Child(selector.Expression).Next(selector.IdentifierReference)}
}

type PropertyBinding struct {
	Node
}

func (n PropertyBinding) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n PropertyBinding) ElementPattern() ElementPattern {
	return ToJsNode(n.Child(selector.ElementPattern)).(ElementPattern)
}

type PropertySignature struct {
	Node
}

func (n PropertySignature) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var result []Modifier = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(Modifier))
	}
	return result
}

func (n PropertySignature) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n PropertySignature) TypeAnnotation() *TypeAnnotation {
	if child := n.Child(selector.TypeAnnotation); child != nil {
		return &TypeAnnotation{child}
	}
	return nil
}

type Readonly struct {
	Node
}

type Regexp struct {
	Node
}

type RelationalExpression struct {
	Node
}

func (n RelationalExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n RelationalExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type RestParameter struct {
	Node
}

func (n RestParameter) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

func (n RestParameter) TypeAnnotation() *TypeAnnotation {
	if child := n.Child(selector.TypeAnnotation); child != nil {
		return &TypeAnnotation{child}
	}
	return nil
}

type ReturnStatement struct {
	Node
}

func (n ReturnStatement) Expression() Expression {
	if child := n.Child(selector.Expression); child != nil {
		return ToJsNode(child).(Expression)
	}
	return nil
}

type Setter struct {
	Node
}

func (n Setter) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n Setter) Parameter() Parameter {
	return ToJsNode(n.Child(selector.Parameter)).(Parameter)
}

func (n Setter) Body() Body {
	return Body{n.Child(selector.Body)}
}

type ShiftExpression struct {
	Node
}

func (n ShiftExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n ShiftExpression) Right() Expression {
	return ToJsNode(n.Child(selector.Expression).Next(selector.Expression)).(Expression)
}

type ShorthandProperty struct {
	Node
}

func (n ShorthandProperty) IdentifierReference() IdentifierReference {
	return IdentifierReference{n.Child(selector.IdentifierReference)}
}

type SingleNameBinding struct {
	Node
}

func (n SingleNameBinding) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

func (n SingleNameBinding) Initializer() *Initializer {
	if child := n.Child(selector.Initializer); child != nil {
		return &Initializer{child}
	}
	return nil
}

type SpreadElement struct {
	Node
}

func (n SpreadElement) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type SpreadProperty struct {
	Node
}

func (n SpreadProperty) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type Static struct {
	Node
}

type SuperExpression struct {
	Node
}

type SwitchStatement struct {
	Node
}

func (n SwitchStatement) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n SwitchStatement) Block() Block {
	return Block{n.Child(selector.Block)}
}

type SyntaxProblem struct {
	Node
}

func (n SyntaxProblem) IdentifierReference() *IdentifierReference {
	if child := n.Child(selector.IdentifierReference); child != nil {
		return &IdentifierReference{child}
	}
	return nil
}

func (n SyntaxProblem) Initializer() *Initializer {
	if child := n.Child(selector.Initializer); child != nil {
		return &Initializer{child}
	}
	return nil
}

type TaggedTemplate struct {
	Node
}

func (n TaggedTemplate) Tag() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n TaggedTemplate) Literal() TemplateLiteral {
	return TemplateLiteral{n.Child(selector.Expression).Next(selector.TemplateLiteral)}
}

type TemplateLiteral struct {
	Node
}

func (n TemplateLiteral) Template() []Token {
	nodes := n.Children(selector.OneOf(js.NoSubstitutionTemplate, js.TemplateHead, js.TemplateMiddle, js.TemplateTail))
	var result []Token = make([]Token, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(Token))
	}
	return result
}

func (n TemplateLiteral) Substitution() []Expression {
	nodes := n.Children(selector.Expression)
	var result []Expression = make([]Expression, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(Expression))
	}
	return result
}

type This struct {
	Node
}

type ThisType struct {
	Node
}

type ThrowStatement struct {
	Node
}

func (n ThrowStatement) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type TryStatement struct {
	Node
}

func (n TryStatement) Block() Block {
	return Block{n.Child(selector.Block)}
}

func (n TryStatement) Catch() *Catch {
	if child := n.Child(selector.Catch); child != nil {
		return &Catch{child}
	}
	return nil
}

func (n TryStatement) Finally() *Finally {
	if child := n.Child(selector.Finally); child != nil {
		return &Finally{child}
	}
	return nil
}

type TsAmbientBinding struct {
	Node
}

func (n TsAmbientBinding) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

func (n TsAmbientBinding) TypeAnnotation() *TypeAnnotation {
	if child := n.Child(selector.TypeAnnotation); child != nil {
		return &TypeAnnotation{child}
	}
	return nil
}

type TsAmbientClass struct {
	Node
}

func (n TsAmbientClass) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var result []Modifier = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(Modifier))
	}
	return result
}

func (n TsAmbientClass) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

func (n TsAmbientClass) TypeParameters() *TypeParameters {
	if child := n.Child(selector.TypeParameters); child != nil {
		return &TypeParameters{child}
	}
	return nil
}

func (n TsAmbientClass) Extends() *Extends {
	if child := n.Child(selector.Extends); child != nil {
		return &Extends{child}
	}
	return nil
}

func (n TsAmbientClass) TsImplementsClause() *TsImplementsClause {
	if child := n.Child(selector.TsImplementsClause); child != nil {
		return &TsImplementsClause{child}
	}
	return nil
}

func (n TsAmbientClass) TsAmbientClassBody() TsAmbientClassBody {
	return TsAmbientClassBody{n.Child(selector.TsAmbientClassBody)}
}

type TsAmbientClassBody struct {
	Node
}

func (n TsAmbientClassBody) TsAmbientClassElement() []TsAmbientClassElement {
	nodes := n.Children(selector.TsAmbientClassElement)
	var result []TsAmbientClassElement = make([]TsAmbientClassElement, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(TsAmbientClassElement))
	}
	return result
}

type TsAmbientEnum struct {
	Node
}

func (n TsAmbientEnum) TsEnum() TsEnum {
	return TsEnum{n.Child(selector.TsEnum)}
}

type TsAmbientFunction struct {
	Node
}

func (n TsAmbientFunction) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

func (n TsAmbientFunction) TypeParameters() *TypeParameters {
	if child := n.Child(selector.TypeParameters); child != nil {
		return &TypeParameters{child}
	}
	return nil
}

func (n TsAmbientFunction) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n TsAmbientFunction) TypeAnnotation() *TypeAnnotation {
	if child := n.Child(selector.TypeAnnotation); child != nil {
		return &TypeAnnotation{child}
	}
	return nil
}

type TsAmbientFunctionMember struct {
	Node
}

func (n TsAmbientFunctionMember) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var result []Modifier = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(Modifier))
	}
	return result
}

func (n TsAmbientFunctionMember) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n TsAmbientFunctionMember) TypeParameters() *TypeParameters {
	if child := n.Child(selector.TypeParameters); child != nil {
		return &TypeParameters{child}
	}
	return nil
}

func (n TsAmbientFunctionMember) Parameters() Parameters {
	return Parameters{n.Child(selector.Parameters)}
}

func (n TsAmbientFunctionMember) TypeAnnotation() *TypeAnnotation {
	if child := n.Child(selector.TypeAnnotation); child != nil {
		return &TypeAnnotation{child}
	}
	return nil
}

type TsAmbientImportAlias struct {
	Node
}

func (n TsAmbientImportAlias) TsImportAliasDeclaration() TsImportAliasDeclaration {
	return TsImportAliasDeclaration{n.Child(selector.TsImportAliasDeclaration)}
}

type TsAmbientIndexMember struct {
	Node
}

func (n TsAmbientIndexMember) IndexSignature() IndexSignature {
	return IndexSignature{n.Child(selector.IndexSignature)}
}

type TsAmbientInterface struct {
	Node
}

func (n TsAmbientInterface) TsInterface() TsInterface {
	return TsInterface{n.Child(selector.TsInterface)}
}

type TsAmbientModule struct {
	Node
}

func (n TsAmbientModule) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

func (n TsAmbientModule) ModuleItem() []ModuleItem {
	nodes := n.Children(selector.ModuleItem)
	var result []ModuleItem = make([]ModuleItem, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(ModuleItem))
	}
	return result
}

type TsAmbientNamespace struct {
	Node
}

func (n TsAmbientNamespace) BindingIdentifier() []BindingIdentifier {
	nodes := n.Children(selector.BindingIdentifier)
	var result []BindingIdentifier = make([]BindingIdentifier, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, BindingIdentifier{node})
	}
	return result
}

func (n TsAmbientNamespace) TsAmbientElement() []TsAmbientElement {
	nodes := n.Children(selector.TsAmbientElement)
	var result []TsAmbientElement = make([]TsAmbientElement, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(TsAmbientElement))
	}
	return result
}

type TsAmbientPropertyMember struct {
	Node
}

func (n TsAmbientPropertyMember) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var result []Modifier = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(Modifier))
	}
	return result
}

func (n TsAmbientPropertyMember) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n TsAmbientPropertyMember) TypeAnnotation() *TypeAnnotation {
	if child := n.Child(selector.TypeAnnotation); child != nil {
		return &TypeAnnotation{child}
	}
	return nil
}

type TsAmbientTypeAlias struct {
	Node
}

func (n TsAmbientTypeAlias) TypeAliasDeclaration() TypeAliasDeclaration {
	return TypeAliasDeclaration{n.Child(selector.TypeAliasDeclaration)}
}

type TsAmbientVar struct {
	Node
}

func (n TsAmbientVar) TsAmbientBinding() []TsAmbientBinding {
	nodes := n.Children(selector.TsAmbientBinding)
	var result []TsAmbientBinding = make([]TsAmbientBinding, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, TsAmbientBinding{node})
	}
	return result
}

type TsAsExpression struct {
	Node
}

func (n TsAsExpression) Left() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n TsAsExpression) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type TsCastExpression struct {
	Node
}

func (n TsCastExpression) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

func (n TsCastExpression) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type TsEnum struct {
	Node
}

func (n TsEnum) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

func (n TsEnum) TsEnumBody() TsEnumBody {
	return TsEnumBody{n.Child(selector.TsEnumBody)}
}

type TsEnumBody struct {
	Node
}

func (n TsEnumBody) TsEnumMember() []TsEnumMember {
	nodes := n.Children(selector.TsEnumMember)
	var result []TsEnumMember = make([]TsEnumMember, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, TsEnumMember{node})
	}
	return result
}

type TsEnumMember struct {
	Node
}

func (n TsEnumMember) PropertyName() PropertyName {
	return ToJsNode(n.Child(selector.PropertyName)).(PropertyName)
}

func (n TsEnumMember) Expression() Expression {
	if child := n.Child(selector.Expression); child != nil {
		return ToJsNode(child).(Expression)
	}
	return nil
}

type TsExportAssignment struct {
	Node
}

func (n TsExportAssignment) IdentifierReference() IdentifierReference {
	return IdentifierReference{n.Child(selector.IdentifierReference)}
}

type TsImplementsClause struct {
	Node
}

func (n TsImplementsClause) TypeReference() []TypeReference {
	nodes := n.Children(selector.TypeReference)
	var result []TypeReference = make([]TypeReference, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, TypeReference{node})
	}
	return result
}

type TsImportAliasDeclaration struct {
	Node
}

func (n TsImportAliasDeclaration) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

func (n TsImportAliasDeclaration) Ref() []IdentifierReference {
	nodes := n.Children(selector.IdentifierReference)
	var result []IdentifierReference = make([]IdentifierReference, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, IdentifierReference{node})
	}
	return result
}

type TsImportRequireDeclaration struct {
	Node
}

func (n TsImportRequireDeclaration) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

type TsIndexMemberDeclaration struct {
	Node
}

func (n TsIndexMemberDeclaration) IndexSignature() IndexSignature {
	return IndexSignature{n.Child(selector.IndexSignature)}
}

type TsInterface struct {
	Node
}

func (n TsInterface) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

func (n TsInterface) TypeParameters() *TypeParameters {
	if child := n.Child(selector.TypeParameters); child != nil {
		return &TypeParameters{child}
	}
	return nil
}

func (n TsInterface) TsInterfaceExtends() *TsInterfaceExtends {
	if child := n.Child(selector.TsInterfaceExtends); child != nil {
		return &TsInterfaceExtends{child}
	}
	return nil
}

func (n TsInterface) ObjectType() ObjectType {
	return ObjectType{n.Child(selector.ObjectType)}
}

type TsInterfaceExtends struct {
	Node
}

func (n TsInterfaceExtends) TypeReference() []TypeReference {
	nodes := n.Children(selector.TypeReference)
	var result []TypeReference = make([]TypeReference, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, TypeReference{node})
	}
	return result
}

type TsNamespace struct {
	Node
}

func (n TsNamespace) BindingIdentifier() []BindingIdentifier {
	nodes := n.Children(selector.BindingIdentifier)
	var result []BindingIdentifier = make([]BindingIdentifier, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, BindingIdentifier{node})
	}
	return result
}

func (n TsNamespace) TsNamespaceBody() TsNamespaceBody {
	return TsNamespaceBody{n.Child(selector.TsNamespaceBody)}
}

type TsNamespaceBody struct {
	Node
}

func (n TsNamespaceBody) ModuleItem() []ModuleItem {
	nodes := n.Children(selector.ModuleItem)
	var result []ModuleItem = make([]ModuleItem, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(ModuleItem))
	}
	return result
}

type TsNonNull struct {
	Node
}

func (n TsNonNull) Expr() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type TsThisParameter struct {
	Node
}

func (n TsThisParameter) TypeAnnotation() TypeAnnotation {
	return TypeAnnotation{n.Child(selector.TypeAnnotation)}
}

type TupleType struct {
	Node
}

func (n TupleType) TsType() []TsType {
	nodes := n.Children(selector.TsType)
	var result []TsType = make([]TsType, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(TsType))
	}
	return result
}

type TypeAliasDeclaration struct {
	Node
}

func (n TypeAliasDeclaration) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

func (n TypeAliasDeclaration) TypeParameters() *TypeParameters {
	if child := n.Child(selector.TypeParameters); child != nil {
		return &TypeParameters{child}
	}
	return nil
}

func (n TypeAliasDeclaration) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type TypeAnnotation struct {
	Node
}

func (n TypeAnnotation) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type TypeArguments struct {
	Node
}

func (n TypeArguments) TsType() []TsType {
	nodes := n.Children(selector.TsType)
	var result []TsType = make([]TsType, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(TsType))
	}
	return result
}

type TypeConstraint struct {
	Node
}

func (n TypeConstraint) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type TypeName struct {
	Node
}

func (n TypeName) Ref() []IdentifierReference {
	nodes := n.Children(selector.IdentifierReference)
	var result []IdentifierReference = make([]IdentifierReference, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, IdentifierReference{node})
	}
	return result
}

type TypeParameter struct {
	Node
}

func (n TypeParameter) BindingIdentifier() BindingIdentifier {
	return BindingIdentifier{n.Child(selector.BindingIdentifier)}
}

func (n TypeParameter) TypeConstraint() *TypeConstraint {
	if child := n.Child(selector.TypeConstraint); child != nil {
		return &TypeConstraint{child}
	}
	return nil
}

func (n TypeParameter) TsType() TsType {
	if child := n.Child(selector.TsType); child != nil {
		return ToJsNode(child).(TsType)
	}
	return nil
}

type TypeParameters struct {
	Node
}

func (n TypeParameters) TypeParameter() []TypeParameter {
	nodes := n.Children(selector.TypeParameter)
	var result []TypeParameter = make([]TypeParameter, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, TypeParameter{node})
	}
	return result
}

type TypePredicate struct {
	Node
}

func (n TypePredicate) Paramref() IdentifierReference {
	return IdentifierReference{n.Child(selector.IdentifierReference)}
}

func (n TypePredicate) TsType() TsType {
	return ToJsNode(n.Child(selector.TsType)).(TsType)
}

type TypeQuery struct {
	Node
}

func (n TypeQuery) IdentifierReference() []IdentifierReference {
	nodes := n.Children(selector.IdentifierReference)
	var result []IdentifierReference = make([]IdentifierReference, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, IdentifierReference{node})
	}
	return result
}

type TypeReference struct {
	Node
}

func (n TypeReference) TypeName() TypeName {
	return TypeName{n.Child(selector.TypeName)}
}

func (n TypeReference) TypeArguments() *TypeArguments {
	if child := n.Child(selector.TypeArguments); child != nil {
		return &TypeArguments{child}
	}
	return nil
}

type UnaryExpression struct {
	Node
}

func (n UnaryExpression) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

type UnionType struct {
	Node
}

func (n UnionType) Inner() []TsType {
	nodes := n.Children(selector.TsType)
	var result []TsType = make([]TsType, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToJsNode(node).(TsType))
	}
	return result
}

type VariableDeclaration struct {
	Node
}

func (n VariableDeclaration) BindingIdentifier() *BindingIdentifier {
	if child := n.Child(selector.BindingIdentifier); child != nil {
		return &BindingIdentifier{child}
	}
	return nil
}

func (n VariableDeclaration) BindingPattern() BindingPattern {
	if child := n.Child(selector.BindingPattern); child != nil {
		return ToJsNode(child).(BindingPattern)
	}
	return nil
}

func (n VariableDeclaration) TypeAnnotation() *TypeAnnotation {
	if child := n.Child(selector.TypeAnnotation); child != nil {
		return &TypeAnnotation{child}
	}
	return nil
}

func (n VariableDeclaration) Initializer() *Initializer {
	if child := n.Child(selector.Initializer); child != nil {
		return &Initializer{child}
	}
	return nil
}

type VariableStatement struct {
	Node
}

func (n VariableStatement) VariableDeclaration() []VariableDeclaration {
	nodes := n.Children(selector.VariableDeclaration)
	var result []VariableDeclaration = make([]VariableDeclaration, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, VariableDeclaration{node})
	}
	return result
}

type WhileStatement struct {
	Node
}

func (n WhileStatement) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n WhileStatement) Statement() Statement {
	return ToJsNode(n.Child(selector.Statement)).(Statement)
}

type WithStatement struct {
	Node
}

func (n WithStatement) Expression() Expression {
	return ToJsNode(n.Child(selector.Expression)).(Expression)
}

func (n WithStatement) Statement() Statement {
	return ToJsNode(n.Child(selector.Statement)).(Statement)
}

type Yield struct {
	Node
}

func (n Yield) Expression() Expression {
	if child := n.Child(selector.Expression); child != nil {
		return ToJsNode(child).(Expression)
	}
	return nil
}
