// generated by Textmapper; DO NOT EDIT

package ast

import (
	"github.com/inspirer/textmapper/tm-go/parsers/tm"
	"github.com/inspirer/textmapper/tm-go/parsers/tm/selector"
)

type Node interface {
	Type() tm.NodeType
	Offset() int
	Endoffset() int
	// Child returns the first child node that matches the selector.
	Child(sel selector.Selector) Node
	Children(sel selector.Selector) []Node
	// Next returns the first element among the following siblings that matches the selector.
	Next(sel selector.Selector) Node
	// NextAll returns all following siblings of the node that match the selector.
	NextAll(sel selector.Selector) []Node
	Text() string
}

// Interfaces.

type TmNode interface {
	Node
	tmNodeNode()
}

type Token struct {
	Node
}

// All types implement TmNode.
func (AnnotationImpl) tmNodeNode()       {}
func (Annotations) tmNodeNode()          {}
func (ArgumentFalse) tmNodeNode()        {}
func (ArgumentImpl) tmNodeNode()         {}
func (ArgumentTrue) tmNodeNode()         {}
func (Array) tmNodeNode()                {}
func (Assoc) tmNodeNode()                {}
func (BooleanLiteral) tmNodeNode()       {}
func (Command) tmNodeNode()              {}
func (DirectiveAssert) tmNodeNode()      {}
func (DirectiveBrackets) tmNodeNode()    {}
func (DirectiveInput) tmNodeNode()       {}
func (DirectiveInterface) tmNodeNode()   {}
func (DirectivePrio) tmNodeNode()        {}
func (DirectiveSet) tmNodeNode()         {}
func (ExclusiveStates) tmNodeNode()      {}
func (Header) tmNodeNode()               {}
func (Identifier) tmNodeNode()           {}
func (Import) tmNodeNode()               {}
func (InclusiveStates) tmNodeNode()      {}
func (InlineParameter) tmNodeNode()      {}
func (Input) tmNodeNode()                {}
func (Inputref) tmNodeNode()             {}
func (IntegerLiteral) tmNodeNode()       {}
func (InterfaceType) tmNodeNode()        {}
func (KeyValue) tmNodeNode()             {}
func (Lexeme) tmNodeNode()               {}
func (LexemeAttribute) tmNodeNode()      {}
func (LexemeAttrs) tmNodeNode()          {}
func (LexerSection) tmNodeNode()         {}
func (LexerState) tmNodeNode()           {}
func (ListSeparator) tmNodeNode()        {}
func (Name) tmNodeNode()                 {}
func (NamedPattern) tmNodeNode()         {}
func (Nonterm) tmNodeNode()              {}
func (NontermParams) tmNodeNode()        {}
func (ParamModifier) tmNodeNode()        {}
func (ParamRef) tmNodeNode()             {}
func (ParamType) tmNodeNode()            {}
func (ParserSection) tmNodeNode()        {}
func (Pattern) tmNodeNode()              {}
func (Predicate) tmNodeNode()            {}
func (PredicateAnd) tmNodeNode()         {}
func (PredicateEq) tmNodeNode()          {}
func (PredicateNot) tmNodeNode()         {}
func (PredicateNotEq) tmNodeNode()       {}
func (PredicateOr) tmNodeNode()          {}
func (RawType) tmNodeNode()              {}
func (References) tmNodeNode()           {}
func (ReportClause) tmNodeNode()         {}
func (RhsAnnotated) tmNodeNode()         {}
func (RhsAssignment) tmNodeNode()        {}
func (RhsCast) tmNodeNode()              {}
func (RhsIgnored) tmNodeNode()           {}
func (RhsNested) tmNodeNode()            {}
func (RhsOptional) tmNodeNode()          {}
func (RhsPlusAssignment) tmNodeNode()    {}
func (RhsPlusList) tmNodeNode()          {}
func (RhsQuantifier) tmNodeNode()        {}
func (RhsSet) tmNodeNode()               {}
func (RhsStarList) tmNodeNode()          {}
func (RhsSuffix) tmNodeNode()            {}
func (RhsSymbol) tmNodeNode()            {}
func (Rule) tmNodeNode()                 {}
func (SetAnd) tmNodeNode()               {}
func (SetComplement) tmNodeNode()        {}
func (SetCompound) tmNodeNode()          {}
func (SetOr) tmNodeNode()                {}
func (SetSymbol) tmNodeNode()            {}
func (StartConditions) tmNodeNode()      {}
func (StartConditionsScope) tmNodeNode() {}
func (Stateref) tmNodeNode()             {}
func (StringLiteral) tmNodeNode()        {}
func (SubType) tmNodeNode()              {}
func (Symref) tmNodeNode()               {}
func (SymrefArgs) tmNodeNode()           {}
func (SyntaxProblem) tmNodeNode()        {}
func (TemplateParam) tmNodeNode()        {}
func (VoidType) tmNodeNode()             {}
func (Token) tmNodeNode()                {}

type Annotation interface {
	TmNode
	annotationNode()
}

// annotationNode() ensures that only the following types can be
// assigned to Annotation.
//
func (AnnotationImpl) annotationNode() {}
func (SyntaxProblem) annotationNode()  {}

type Argument interface {
	TmNode
	argumentNode()
}

// argumentNode() ensures that only the following types can be
// assigned to Argument.
//
func (ArgumentFalse) argumentNode() {}
func (ArgumentImpl) argumentNode()  {}
func (ArgumentTrue) argumentNode()  {}

type Expression interface {
	TmNode
	expressionNode()
}

// expressionNode() ensures that only the following types can be
// assigned to Expression.
//
func (Array) expressionNode()          {}
func (BooleanLiteral) expressionNode() {}
func (IntegerLiteral) expressionNode() {}
func (StringLiteral) expressionNode()  {}
func (Symref) expressionNode()         {}
func (SyntaxProblem) expressionNode()  {}

type GrammarPart interface {
	TmNode
	grammarPartNode()
}

// grammarPartNode() ensures that only the following types can be
// assigned to GrammarPart.
//
func (DirectiveAssert) grammarPartNode()    {}
func (DirectiveInput) grammarPartNode()     {}
func (DirectiveInterface) grammarPartNode() {}
func (DirectivePrio) grammarPartNode()      {}
func (DirectiveSet) grammarPartNode()       {}
func (Nonterm) grammarPartNode()            {}
func (SyntaxProblem) grammarPartNode()      {}
func (TemplateParam) grammarPartNode()      {}

type LexerPart interface {
	TmNode
	lexerPartNode()
}

// lexerPartNode() ensures that only the following types can be
// assigned to LexerPart.
//
func (DirectiveBrackets) lexerPartNode()    {}
func (ExclusiveStates) lexerPartNode()      {}
func (InclusiveStates) lexerPartNode()      {}
func (Lexeme) lexerPartNode()               {}
func (NamedPattern) lexerPartNode()         {}
func (StartConditionsScope) lexerPartNode() {}
func (SyntaxProblem) lexerPartNode()        {}

type Literal interface {
	TmNode
	literalNode()
}

// literalNode() ensures that only the following types can be
// assigned to Literal.
//
func (BooleanLiteral) literalNode() {}
func (IntegerLiteral) literalNode() {}
func (StringLiteral) literalNode()  {}

type NontermParam interface {
	TmNode
	nontermParamNode()
}

// nontermParamNode() ensures that only the following types can be
// assigned to NontermParam.
//
func (InlineParameter) nontermParamNode() {}
func (ParamRef) nontermParamNode()        {}

type NontermType interface {
	TmNode
	nontermTypeNode()
}

// nontermTypeNode() ensures that only the following types can be
// assigned to NontermType.
//
func (InterfaceType) nontermTypeNode() {}
func (RawType) nontermTypeNode()       {}
func (SubType) nontermTypeNode()       {}
func (VoidType) nontermTypeNode()      {}

type Option interface {
	TmNode
	optionNode()
}

// optionNode() ensures that only the following types can be
// assigned to Option.
//
func (KeyValue) optionNode()      {}
func (SyntaxProblem) optionNode() {}

type ParamValue interface {
	TmNode
	paramValueNode()
}

// paramValueNode() ensures that only the following types can be
// assigned to ParamValue.
//
func (BooleanLiteral) paramValueNode() {}
func (IntegerLiteral) paramValueNode() {}
func (ParamRef) paramValueNode()       {}
func (StringLiteral) paramValueNode()  {}

type PredicateExpression interface {
	TmNode
	predicateExpressionNode()
}

// predicateExpressionNode() ensures that only the following types can be
// assigned to PredicateExpression.
//
func (ParamRef) predicateExpressionNode()       {}
func (PredicateAnd) predicateExpressionNode()   {}
func (PredicateEq) predicateExpressionNode()    {}
func (PredicateNot) predicateExpressionNode()   {}
func (PredicateNotEq) predicateExpressionNode() {}
func (PredicateOr) predicateExpressionNode()    {}

type RhsPart interface {
	TmNode
	rhsPartNode()
}

// rhsPartNode() ensures that only the following types can be
// assigned to RhsPart.
//
func (Command) rhsPartNode()           {}
func (RhsAnnotated) rhsPartNode()      {}
func (RhsAssignment) rhsPartNode()     {}
func (RhsCast) rhsPartNode()           {}
func (RhsIgnored) rhsPartNode()        {}
func (RhsNested) rhsPartNode()         {}
func (RhsOptional) rhsPartNode()       {}
func (RhsPlusAssignment) rhsPartNode() {}
func (RhsPlusList) rhsPartNode()       {}
func (RhsQuantifier) rhsPartNode()     {}
func (RhsSet) rhsPartNode()            {}
func (RhsStarList) rhsPartNode()       {}
func (RhsSymbol) rhsPartNode()         {}
func (SyntaxProblem) rhsPartNode()     {}

type Rule0 interface {
	TmNode
	rule0Node()
}

// rule0Node() ensures that only the following types can be
// assigned to Rule0.
//
func (Rule) rule0Node()          {}
func (SyntaxProblem) rule0Node() {}

type SetExpression interface {
	TmNode
	setExpressionNode()
}

// setExpressionNode() ensures that only the following types can be
// assigned to SetExpression.
//
func (SetAnd) setExpressionNode()        {}
func (SetComplement) setExpressionNode() {}
func (SetCompound) setExpressionNode()   {}
func (SetOr) setExpressionNode()         {}
func (SetSymbol) setExpressionNode()     {}

// Types.

type AnnotationImpl struct {
	Node
}

func (n AnnotationImpl) Name() Identifier {
	return Identifier{n.Child(selector.Identifier)}
}

func (n AnnotationImpl) Expression() Expression {
	if child := n.Child(selector.Expression); child != nil {
		return ToTmNode(child).(Expression)
	}
	return nil
}

type Annotations struct {
	Node
}

func (n Annotations) Annotation() []Annotation {
	nodes := n.Children(selector.Annotation)
	var result []Annotation = make([]Annotation, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToTmNode(node).(Annotation))
	}
	return result
}

type ArgumentFalse struct {
	Node
}

func (n ArgumentFalse) Name() ParamRef {
	return ParamRef{n.Child(selector.ParamRef)}
}

type ArgumentImpl struct {
	Node
}

func (n ArgumentImpl) Name() ParamRef {
	return ParamRef{n.Child(selector.ParamRef)}
}

func (n ArgumentImpl) Val() ParamValue {
	if child := n.Child(selector.ParamRef).Next(selector.ParamValue); child != nil {
		return ToTmNode(child).(ParamValue)
	}
	return nil
}

type ArgumentTrue struct {
	Node
}

func (n ArgumentTrue) Name() ParamRef {
	return ParamRef{n.Child(selector.ParamRef)}
}

type Array struct {
	Node
}

func (n Array) Expression() []Expression {
	nodes := n.Children(selector.Expression)
	var result []Expression = make([]Expression, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToTmNode(node).(Expression))
	}
	return result
}

type Assoc struct {
	Node
}

type BooleanLiteral struct {
	Node
}

type Command struct {
	Node
}

type DirectiveAssert struct {
	Node
}

func (n DirectiveAssert) RhsSet() RhsSet {
	return RhsSet{n.Child(selector.RhsSet)}
}

type DirectiveBrackets struct {
	Node
}

func (n DirectiveBrackets) Opening() Symref {
	return Symref{n.Child(selector.Symref)}
}

func (n DirectiveBrackets) Closing() Symref {
	return Symref{n.Child(selector.Symref).Next(selector.Symref)}
}

type DirectiveInput struct {
	Node
}

func (n DirectiveInput) InputRefs() []Inputref {
	nodes := n.Children(selector.Inputref)
	var result []Inputref = make([]Inputref, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, Inputref{node})
	}
	return result
}

type DirectiveInterface struct {
	Node
}

func (n DirectiveInterface) Ids() []Identifier {
	nodes := n.Children(selector.Identifier)
	var result []Identifier = make([]Identifier, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, Identifier{node})
	}
	return result
}

type DirectivePrio struct {
	Node
}

func (n DirectivePrio) Assoc() Assoc {
	return Assoc{n.Child(selector.Assoc)}
}

func (n DirectivePrio) Symbols() References {
	return References{n.Child(selector.References)}
}

type DirectiveSet struct {
	Node
}

func (n DirectiveSet) Name() Identifier {
	return Identifier{n.Child(selector.Identifier)}
}

func (n DirectiveSet) RhsSet() RhsSet {
	return RhsSet{n.Child(selector.RhsSet)}
}

type ExclusiveStates struct {
	Node
}

func (n ExclusiveStates) States() []LexerState {
	nodes := n.Children(selector.LexerState)
	var result []LexerState = make([]LexerState, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, LexerState{node})
	}
	return result
}

type Header struct {
	Node
}

func (n Header) Name() Name {
	return Name{n.Child(selector.Name)}
}

func (n Header) Target() *Name {
	if child := n.Child(selector.Name).Next(selector.Name); child != nil {
		return &Name{child}
	}
	return nil
}

type Identifier struct {
	Node
}

type Import struct {
	Node
}

func (n Import) Alias() *Identifier {
	if child := n.Child(selector.Identifier); child != nil {
		return &Identifier{child}
	}
	return nil
}

func (n Import) Path() StringLiteral {
	return StringLiteral{n.Child(selector.StringLiteral)}
}

type InclusiveStates struct {
	Node
}

func (n InclusiveStates) States() []LexerState {
	nodes := n.Children(selector.LexerState)
	var result []LexerState = make([]LexerState, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, LexerState{node})
	}
	return result
}

type InlineParameter struct {
	Node
}

func (n InlineParameter) ParamType() Identifier {
	return Identifier{n.Child(selector.Identifier)}
}

func (n InlineParameter) Name() Identifier {
	return Identifier{n.Child(selector.Identifier).Next(selector.Identifier)}
}

func (n InlineParameter) ParamValue() ParamValue {
	if child := n.Child(selector.ParamValue); child != nil {
		return ToTmNode(child).(ParamValue)
	}
	return nil
}

type Input struct {
	Node
}

func (n Input) Header() Header {
	return Header{n.Child(selector.Header)}
}

func (n Input) Imports() []Import {
	nodes := n.Children(selector.Import)
	var result []Import = make([]Import, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, Import{node})
	}
	return result
}

func (n Input) Options() []Option {
	nodes := n.Children(selector.Option)
	var result []Option = make([]Option, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToTmNode(node).(Option))
	}
	return result
}

func (n Input) Lexer() LexerSection {
	return LexerSection{n.Child(selector.LexerSection)}
}

func (n Input) Parser() *ParserSection {
	if child := n.Child(selector.ParserSection); child != nil {
		return &ParserSection{child}
	}
	return nil
}

type Inputref struct {
	Node
}

func (n Inputref) Reference() Symref {
	return Symref{n.Child(selector.Symref)}
}

type IntegerLiteral struct {
	Node
}

type InterfaceType struct {
	Node
}

type KeyValue struct {
	Node
}

func (n KeyValue) Key() Identifier {
	return Identifier{n.Child(selector.Identifier)}
}

func (n KeyValue) Value() Expression {
	return ToTmNode(n.Child(selector.Expression)).(Expression)
}

type Lexeme struct {
	Node
}

func (n Lexeme) StartConditions() *StartConditions {
	if child := n.Child(selector.StartConditions); child != nil {
		return &StartConditions{child}
	}
	return nil
}

func (n Lexeme) Name() Identifier {
	return Identifier{n.Child(selector.Identifier)}
}

func (n Lexeme) RawType() *RawType {
	if child := n.Child(selector.RawType); child != nil {
		return &RawType{child}
	}
	return nil
}

func (n Lexeme) Pattern() *Pattern {
	if child := n.Child(selector.Pattern); child != nil {
		return &Pattern{child}
	}
	return nil
}

func (n Lexeme) Priority() *IntegerLiteral {
	if child := n.Child(selector.IntegerLiteral); child != nil {
		return &IntegerLiteral{child}
	}
	return nil
}

func (n Lexeme) Attrs() *LexemeAttrs {
	if child := n.Child(selector.LexemeAttrs); child != nil {
		return &LexemeAttrs{child}
	}
	return nil
}

func (n Lexeme) Command() *Command {
	if child := n.Child(selector.Command); child != nil {
		return &Command{child}
	}
	return nil
}

type LexemeAttribute struct {
	Node
}

type LexemeAttrs struct {
	Node
}

func (n LexemeAttrs) LexemeAttribute() LexemeAttribute {
	return LexemeAttribute{n.Child(selector.LexemeAttribute)}
}

type LexerSection struct {
	Node
}

func (n LexerSection) LexerPart() []LexerPart {
	nodes := n.Children(selector.LexerPart)
	var result []LexerPart = make([]LexerPart, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToTmNode(node).(LexerPart))
	}
	return result
}

type LexerState struct {
	Node
}

func (n LexerState) Name() Identifier {
	return Identifier{n.Child(selector.Identifier)}
}

type ListSeparator struct {
	Node
}

func (n ListSeparator) Separator() References {
	return References{n.Child(selector.References)}
}

type Name struct {
	Node
}

func (n Name) Identifier() []Identifier {
	nodes := n.Children(selector.Identifier)
	var result []Identifier = make([]Identifier, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, Identifier{node})
	}
	return result
}

type NamedPattern struct {
	Node
}

func (n NamedPattern) Name() Identifier {
	return Identifier{n.Child(selector.Identifier)}
}

func (n NamedPattern) Pattern() Pattern {
	return Pattern{n.Child(selector.Pattern)}
}

type Nonterm struct {
	Node
}

func (n Nonterm) Annotations() *Annotations {
	if child := n.Child(selector.Annotations); child != nil {
		return &Annotations{child}
	}
	return nil
}

func (n Nonterm) Name() Identifier {
	return Identifier{n.Child(selector.Identifier)}
}

func (n Nonterm) Params() *NontermParams {
	if child := n.Child(selector.NontermParams); child != nil {
		return &NontermParams{child}
	}
	return nil
}

func (n Nonterm) NontermType() NontermType {
	if child := n.Child(selector.NontermType); child != nil {
		return ToTmNode(child).(NontermType)
	}
	return nil
}

func (n Nonterm) ReportClause() *ReportClause {
	if child := n.Child(selector.ReportClause); child != nil {
		return &ReportClause{child}
	}
	return nil
}

func (n Nonterm) Rule0() []Rule0 {
	nodes := n.Children(selector.Rule0)
	var result []Rule0 = make([]Rule0, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToTmNode(node).(Rule0))
	}
	return result
}

type NontermParams struct {
	Node
}

func (n NontermParams) List() []NontermParam {
	nodes := n.Children(selector.NontermParam)
	var result []NontermParam = make([]NontermParam, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToTmNode(node).(NontermParam))
	}
	return result
}

type ParamModifier struct {
	Node
}

type ParamRef struct {
	Node
}

func (n ParamRef) Identifier() Identifier {
	return Identifier{n.Child(selector.Identifier)}
}

type ParamType struct {
	Node
}

type ParserSection struct {
	Node
}

func (n ParserSection) GrammarPart() []GrammarPart {
	nodes := n.Children(selector.GrammarPart)
	var result []GrammarPart = make([]GrammarPart, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToTmNode(node).(GrammarPart))
	}
	return result
}

type Pattern struct {
	Node
}

type Predicate struct {
	Node
}

func (n Predicate) PredicateExpression() PredicateExpression {
	return ToTmNode(n.Child(selector.PredicateExpression)).(PredicateExpression)
}

type PredicateAnd struct {
	Node
}

func (n PredicateAnd) Left() PredicateExpression {
	return ToTmNode(n.Child(selector.PredicateExpression)).(PredicateExpression)
}

func (n PredicateAnd) Right() PredicateExpression {
	return ToTmNode(n.Child(selector.PredicateExpression).Next(selector.PredicateExpression)).(PredicateExpression)
}

type PredicateEq struct {
	Node
}

func (n PredicateEq) ParamRef() ParamRef {
	return ParamRef{n.Child(selector.ParamRef)}
}

func (n PredicateEq) Literal() Literal {
	return ToTmNode(n.Child(selector.Literal)).(Literal)
}

type PredicateNot struct {
	Node
}

func (n PredicateNot) ParamRef() ParamRef {
	return ParamRef{n.Child(selector.ParamRef)}
}

type PredicateNotEq struct {
	Node
}

func (n PredicateNotEq) ParamRef() ParamRef {
	return ParamRef{n.Child(selector.ParamRef)}
}

func (n PredicateNotEq) Literal() Literal {
	return ToTmNode(n.Child(selector.Literal)).(Literal)
}

type PredicateOr struct {
	Node
}

func (n PredicateOr) Left() PredicateExpression {
	return ToTmNode(n.Child(selector.PredicateExpression)).(PredicateExpression)
}

func (n PredicateOr) Right() PredicateExpression {
	return ToTmNode(n.Child(selector.PredicateExpression).Next(selector.PredicateExpression)).(PredicateExpression)
}

type RawType struct {
	Node
}

type References struct {
	Node
}

func (n References) References() *References {
	if child := n.Child(selector.References); child != nil {
		return &References{child}
	}
	return nil
}

func (n References) Symref() Symref {
	return Symref{n.Child(selector.Symref)}
}

type ReportClause struct {
	Node
}

func (n ReportClause) Action() Identifier {
	return Identifier{n.Child(selector.Identifier)}
}

func (n ReportClause) Kind() *Identifier {
	if child := n.Child(selector.Identifier).Next(selector.Identifier); child != nil {
		return &Identifier{child}
	}
	return nil
}

type RhsAnnotated struct {
	Node
}

func (n RhsAnnotated) Annotations() Annotations {
	return Annotations{n.Child(selector.Annotations)}
}

func (n RhsAnnotated) Inner() RhsPart {
	return ToTmNode(n.Child(selector.RhsPart)).(RhsPart)
}

type RhsAssignment struct {
	Node
}

func (n RhsAssignment) Id() Identifier {
	return Identifier{n.Child(selector.Identifier)}
}

func (n RhsAssignment) Inner() RhsPart {
	return ToTmNode(n.Child(selector.RhsPart)).(RhsPart)
}

type RhsCast struct {
	Node
}

func (n RhsCast) Inner() RhsPart {
	return ToTmNode(n.Child(selector.RhsPart)).(RhsPart)
}

func (n RhsCast) Target() Symref {
	return Symref{n.Child(selector.Symref)}
}

type RhsIgnored struct {
	Node
}

func (n RhsIgnored) Rule0() []Rule0 {
	nodes := n.Children(selector.Rule0)
	var result []Rule0 = make([]Rule0, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToTmNode(node).(Rule0))
	}
	return result
}

type RhsNested struct {
	Node
}

func (n RhsNested) Rule0() []Rule0 {
	nodes := n.Children(selector.Rule0)
	var result []Rule0 = make([]Rule0, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToTmNode(node).(Rule0))
	}
	return result
}

type RhsOptional struct {
	Node
}

func (n RhsOptional) Inner() RhsPart {
	return ToTmNode(n.Child(selector.RhsPart)).(RhsPart)
}

type RhsPlusAssignment struct {
	Node
}

func (n RhsPlusAssignment) Id() Identifier {
	return Identifier{n.Child(selector.Identifier)}
}

func (n RhsPlusAssignment) Inner() RhsPart {
	return ToTmNode(n.Child(selector.RhsPart)).(RhsPart)
}

type RhsPlusList struct {
	Node
}

func (n RhsPlusList) RuleParts() []RhsPart {
	nodes := n.Children(selector.RhsPart)
	var result []RhsPart = make([]RhsPart, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToTmNode(node).(RhsPart))
	}
	return result
}

func (n RhsPlusList) ListSeparator() ListSeparator {
	return ListSeparator{n.Child(selector.ListSeparator)}
}

type RhsQuantifier struct {
	Node
}

func (n RhsQuantifier) Inner() RhsPart {
	return ToTmNode(n.Child(selector.RhsPart)).(RhsPart)
}

type RhsSet struct {
	Node
}

func (n RhsSet) Expr() SetExpression {
	return ToTmNode(n.Child(selector.SetExpression)).(SetExpression)
}

type RhsStarList struct {
	Node
}

func (n RhsStarList) RuleParts() []RhsPart {
	nodes := n.Children(selector.RhsPart)
	var result []RhsPart = make([]RhsPart, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToTmNode(node).(RhsPart))
	}
	return result
}

func (n RhsStarList) ListSeparator() ListSeparator {
	return ListSeparator{n.Child(selector.ListSeparator)}
}

type RhsSuffix struct {
	Node
}

func (n RhsSuffix) Symref() Symref {
	return Symref{n.Child(selector.Symref)}
}

type RhsSymbol struct {
	Node
}

func (n RhsSymbol) Reference() Symref {
	return Symref{n.Child(selector.Symref)}
}

type Rule struct {
	Node
}

func (n Rule) Predicate() *Predicate {
	if child := n.Child(selector.Predicate); child != nil {
		return &Predicate{child}
	}
	return nil
}

func (n Rule) RhsPart() []RhsPart {
	nodes := n.Children(selector.RhsPart)
	var result []RhsPart = make([]RhsPart, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToTmNode(node).(RhsPart))
	}
	return result
}

func (n Rule) RhsSuffix() *RhsSuffix {
	if child := n.Child(selector.RhsSuffix); child != nil {
		return &RhsSuffix{child}
	}
	return nil
}

func (n Rule) ReportClause() *ReportClause {
	if child := n.Child(selector.ReportClause); child != nil {
		return &ReportClause{child}
	}
	return nil
}

type SetAnd struct {
	Node
}

func (n SetAnd) Left() SetExpression {
	return ToTmNode(n.Child(selector.SetExpression)).(SetExpression)
}

func (n SetAnd) Right() SetExpression {
	return ToTmNode(n.Child(selector.SetExpression).Next(selector.SetExpression)).(SetExpression)
}

type SetComplement struct {
	Node
}

func (n SetComplement) Inner() SetExpression {
	return ToTmNode(n.Child(selector.SetExpression)).(SetExpression)
}

type SetCompound struct {
	Node
}

func (n SetCompound) Inner() SetExpression {
	return ToTmNode(n.Child(selector.SetExpression)).(SetExpression)
}

type SetOr struct {
	Node
}

func (n SetOr) Left() SetExpression {
	return ToTmNode(n.Child(selector.SetExpression)).(SetExpression)
}

func (n SetOr) Right() SetExpression {
	return ToTmNode(n.Child(selector.SetExpression).Next(selector.SetExpression)).(SetExpression)
}

type SetSymbol struct {
	Node
}

func (n SetSymbol) Operator() *Identifier {
	if child := n.Child(selector.Identifier); child != nil {
		return &Identifier{child}
	}
	return nil
}

func (n SetSymbol) Symbol() Symref {
	return Symref{n.Child(selector.Symref)}
}

type StartConditions struct {
	Node
}

func (n StartConditions) Stateref() []Stateref {
	nodes := n.Children(selector.Stateref)
	var result []Stateref = make([]Stateref, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, Stateref{node})
	}
	return result
}

type StartConditionsScope struct {
	Node
}

func (n StartConditionsScope) StartConditions() StartConditions {
	return StartConditions{n.Child(selector.StartConditions)}
}

func (n StartConditionsScope) LexerPart() []LexerPart {
	nodes := n.Children(selector.LexerPart)
	var result []LexerPart = make([]LexerPart, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToTmNode(node).(LexerPart))
	}
	return result
}

type Stateref struct {
	Node
}

func (n Stateref) Name() Identifier {
	return Identifier{n.Child(selector.Identifier)}
}

type StringLiteral struct {
	Node
}

type SubType struct {
	Node
}

func (n SubType) Reference() Symref {
	return Symref{n.Child(selector.Symref)}
}

type Symref struct {
	Node
}

func (n Symref) Name() Identifier {
	return Identifier{n.Child(selector.Identifier)}
}

func (n Symref) Args() *SymrefArgs {
	if child := n.Child(selector.SymrefArgs); child != nil {
		return &SymrefArgs{child}
	}
	return nil
}

type SymrefArgs struct {
	Node
}

func (n SymrefArgs) ArgList() []Argument {
	nodes := n.Children(selector.Argument)
	var result []Argument = make([]Argument, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToTmNode(node).(Argument))
	}
	return result
}

type SyntaxProblem struct {
	Node
}

type TemplateParam struct {
	Node
}

func (n TemplateParam) Modifier() *ParamModifier {
	if child := n.Child(selector.ParamModifier); child != nil {
		return &ParamModifier{child}
	}
	return nil
}

func (n TemplateParam) ParamType() ParamType {
	return ParamType{n.Child(selector.ParamType)}
}

func (n TemplateParam) Name() Identifier {
	return Identifier{n.Child(selector.Identifier)}
}

func (n TemplateParam) ParamValue() ParamValue {
	if child := n.Child(selector.ParamValue); child != nil {
		return ToTmNode(child).(ParamValue)
	}
	return nil
}

type VoidType struct {
	Node
}
