// generated by Textmapper; DO NOT EDIT

package ast

import (
	"github.com/inspirer/textmapper/tm-go/parsers/test"
	"github.com/inspirer/textmapper/tm-go/parsers/test/filters"
)

type Node interface {
	Type() test.NodeType
	Child(filter ...filters.NodeFilter) Node
	Children(filter ...filters.NodeFilter) []Node
}

// Interfaces.

type TestNode interface {
	testNodeNode()
}

// All types implement TestNode.
func (Block) testNodeNode()         {}
func (Decl1) testNodeNode()         {}
func (Decl2) testNodeNode()         {}
func (QualifiedName) testNodeNode() {}
func (Test) testNodeNode()          {}

type Declaration interface {
	declarationNode()
}

// declarationNode() ensures that only the following types can be
// assigned to Declaration.
//
func (Block) declarationNode() {}
func (Decl1) declarationNode() {}
func (Decl2) declarationNode() {}

// Types.

type Block struct {
	Node
}

func (n Block) Declaration() []Declaration {
	nodes := n.Children(filters.Declaration)
	var result []Declaration = make([]Declaration, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToTestNode(node).(Declaration))
	}
	return result
}

type Decl1 struct {
	Node
}

func (n Decl1) QualifiedName() QualifiedName {
	return QualifiedName{n.Child(filters.QualifiedName)}
}

type Decl2 struct {
	Node
}

type QualifiedName struct {
	Node
}

func (n QualifiedName) QualifiedName() *QualifiedName {
	if child := n.Child(filters.QualifiedName); child != nil {
		return &QualifiedName{child}
	}
	return nil
}

func (n QualifiedName) Identifier() Identifier {
	return Identifier{n.Child(filters.Identifier)}
}

type Test struct {
	Node
}

func (n Test) Declaration() []Declaration {
	nodes := n.Children(filters.Declaration)
	var result []Declaration = make([]Declaration, 0, len(nodes))
	for _, node := range nodes {
		result = append(result, ToTestNode(node).(Declaration))
	}
	return result
}
