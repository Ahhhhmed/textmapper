package gen

type file struct {
	name     string
	template string
}

var genFiles = []file{
	{"token.go", tokenTpl},
	{"lexer_tables.go", lexerTablesTpl},
}

const sharedDefs = `
{{define "header" -}}
// generated by Textmapper; DO NOT EDIT

{{end}}

`

const tokenTpl = `
{{template "header" . -}}
package {{.Name}}

// Token is an enum of all terminal symbols of the {{.Name}} language.
type Token int

// Token values.
const (
	UNAVAILABLE Token = iota-1
{{- range .Tokens}}
	{{.ID}}{{if .Comment}}  // {{.Comment}}{{end}}
{{- end}}

	NumTokens
)

var tokenStr = [...]string{
{{- range .Tokens}}
	{{if .Comment}}{{str_literal .Comment}}{{else}}{{str_literal .ID}}{{end}},
{{- end}}
}

func (tok Token) String() string {
	if tok >= 0 && int(tok) < len(tokenStr) {
		return tokenStr[tok]
	}
	return "fmt".Sprintf("token(%d)", tok)
}
`

const lexerTablesTpl = `
{{template "header" . -}}
package {{.Name}}

const tmNumClasses = {{.Lexer.Tables.NumSymbols}}

{{$runeType := bits .Lexer.Tables.NumSymbols -}}
{{if gt .Lexer.Tables.LastMapEntry.Start 2048 -}}
type mapRange struct {
	lo         rune
	hi         rune
	defaultVal uint{{$runeType}}
	val        []uint{{$runeType}}
}

func mapRune(c rune) int {
	lo := 0
	hi := len(tmRuneRanges)
	for lo < hi {
		m := lo + (hi-lo)/2
		r := tmRuneRanges[m]
		if c < r.lo {
			hi = m
		} else if c >= r.hi {
			lo = m + 1
		} else {
			i := int(c - r.lo)
			if i < len(r.val) {
				return int(r.val[i])
			}
			return int(r.defaultVal)
		}
	}
	return 1
}

// Latin-1 characters.
var tmRuneClass = []uint{{$runeType}}{
{{- int_array (.Lexer.Tables.SymbolArr 256) "\t" 79 -}}
}

const tmRuneClassLen = 256
const tmFirstRule = {{.Lexer.Tables.ActionStart}}

var tmRuneRanges = []mapRange{
{{range .Lexer.Tables.CompressedMap 256 -}}
	{ {{- .Lo}}, {{.Hi}}, {{.DefaultVal}}, {{if .Vals}}[]uint{{$runeType}}{
{{- int_array .Vals "\t\t" 78 -}}
	}{{else}}nil{{end -}} },
{{end -}}
}

{{else -}}
{{ $runeArr := .Lexer.Tables.SymbolArr 0 }}
var tmRuneClass = []uint{{$runeType}}{
{{- int_array $runeArr "\t" 79 -}}
}

const tmRuneClassLen = {{len $runeArr}}
const tmFirstRule = {{.Lexer.Tables.ActionStart}}

{{end -}}
var tmStateMap = []int{
{{- int_array .Lexer.Tables.StateMap "\t" 79 -}}
}

{{if .Lexer.RuleToken -}}
var tmToken = []Token{
{{- int_array .Lexer.RuleToken "\t" 79 -}}
}

{{end -}}
var tmLexerAction = []int{{bits_per_element .Lexer.Tables.Dfa}}{
{{- int_array .Lexer.Tables.Dfa "\t" 79 -}}
}

{{if .Lexer.Tables.Backtrack}}
var tmBacktracking = []int{
{{- range .Lexer.Tables.Backtrack}}
	{{.Action}}, {{.NextState}},{{if .Details}}  // {{.Details}}{{end}}
{{- end}}
}
{{- end}}`
