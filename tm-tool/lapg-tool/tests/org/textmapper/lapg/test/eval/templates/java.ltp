
${template header-}
/**
 * Copyright 2002-2012 Evgeny Gryaznov
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
${end}

${template main-}
${file opts.prefix+'Parser.java'}${call unit}${end-}
${file opts.prefix+'Lexer.java'}${call java_lexer.unit}${end-}
${end}

${template parserCtor-}
	protected org.textmapper.lapg.eval.GenericParseContext.@TextSource source;
	protected final org.textmapper.lapg.api.@Grammar grammar;

	private final int[] lapg_action;
	private final short[] lapg_lalr;
	private final short[] lapg_sym_goto;
	private final short[] lapg_sym_from;
	private final short[] lapg_sym_to;
	private final int[] lapg_rlen;
	private final int[] lapg_rlex;

	private final boolean debugSyntax;

	public ${opts.prefix}Parser(${call package}.${opts.prefix}Lexer.@ErrorReporter reporter, org.textmapper.lapg.api.@ParserData tables, org.textmapper.lapg.api.@Grammar grammar, boolean debugSyntax) {
		this.reporter = reporter;
		this.grammar = grammar;
		this.lapg_action = tables.getAction();
		this.lapg_lalr = tables.getLalr();
		this.lapg_sym_goto = tables.getSymGoto();
		this.lapg_sym_to = tables.getSymTo();
		this.lapg_sym_from = tables.getSymFrom();
		this.lapg_rlen = tables.getRuleLength();
		this.lapg_rlex = tables.getLeft();
		this.debugSyntax = debugSyntax;
	}
${end}

${template classcode-}
${end}

${template parserTables-}
${end}

${template debugShift-}
		if (debugSyntax) {
			System.out.println(java.text.@MessageFormat.format("shift: {0} ({1})", grammar.getSymbols()[lapg_n.lexem].getName(), lapg_lexer.current()));
		}
${end}

${template debugReduce-}
		if (debugSyntax) {
			System.out.println("reduce to " + grammar.getSymbols()[lapg_rlex[rule]].getName());
		}
${end}

${template dynamicRecoveringCheck-}
				if (grammar.getError() == null) {
					break;
				}
${end}

${template applyRule-}
	protected void applyRule(${self->symbolClassName()} lapg_gg, int rule, int ruleLength) {
		if (ruleLength == 1) {
			Object right = lapg_m[lapg_head].sym;
			if (right instanceof org.textmapper.lapg.eval.@GenericNode) {
				lapg_gg.sym = right;
			} else {
				lapg_gg.sym = new org.textmapper.lapg.eval.@GenericNode(source, lapg_gg.offset, lapg_gg.endoffset);
			}
		} else if (ruleLength > 1) {
			java.util.@List<org.textmapper.lapg.eval.@GenericNode> children = new java.util.@ArrayList<org.textmapper.lapg.eval.@GenericNode>(ruleLength);
			for (int i = ruleLength - 1; i >= 0; i--) {
				if (lapg_m[lapg_head - i].sym instanceof org.textmapper.lapg.eval.@GenericNode) {
					children.add((org.textmapper.lapg.eval.@GenericNode) lapg_m[lapg_head - i].sym);
				}
			}
			lapg_gg.sym = new org.textmapper.lapg.eval.@GenericNode(source, lapg_gg.offset, lapg_gg.endoffset, children.toArray(new org.textmapper.lapg.eval.@GenericNode[children.size()]));
		}
	}
${end}

${template customParseRoutines-}
${end}

${cached query symbolClassName() = 'ParseSymbol'}

${cached query lazyNext() = true}

${cached query hasRecovering() = true}
${cached query errorLexem() = 'grammar.getError().getIndex()'}

${query mainParseVisibility() = 'public'}

${cached query needActionsTable = true}
${cached query needInitialState = true}
${cached query needFinalState = true}
${cached query hasNoEoiInputs = true}
${cached query hasEoiInputs = true}
