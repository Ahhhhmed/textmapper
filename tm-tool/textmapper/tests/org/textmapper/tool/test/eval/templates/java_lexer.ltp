
${template lexerCtor-}
	private final org.textmapper.lapg.api.@Grammar grammar;
	private final int[] tmCharClass;
	private final int[] tmRuleSymbol;
	private final int[] tmGoto;
	private final int[] tmStateMap;
	private final int tmCharsCount;

	public ${opts.prefix}Lexer(java.io.@Reader stream, ErrorReporter reporter, org.textmapper.lapg.api.@LexerData lexerData, org.textmapper.lapg.api.@Grammar grammar) throws java.io.@IOException {
		this.reporter = reporter;
		this.grammar = grammar;
		tmRuleSymbol = getLexemNum(grammar);
		tmCharClass = lexerData.getChar2no();
		tmGoto = lexerData.getChange();
		tmCharsCount = lexerData.getNchars();
		tmStateMap = lexerData.getGroupset();
		reset(${if opts.lexerInput != 'custom'}stream${end});
	}
${end}

${template mapCharacter-}
	private int mapCharacter(int chr) {
		if (chr >= 0 && chr < tmCharClass.length) {
			return tmCharClass[chr];
		}
		return 1;
	}
${end}

${template createToken}
	protected boolean createToken(${self->java.symbolClassName()} lapg_n, int ruleIndex) throws java.io.@IOException {
		int lexemKind = grammar.getLexerRules()[ruleIndex].getKind();
		return lexemKind != org.textmapper.lapg.api.@LexerRule.KIND_SPACE;
	}
${end}

${template statesInterface-}
${end}

${template lexemsInterface}
	public interface Lexems {
		public static final int Unavailable_ = -1;
	}
${end}

${template unpackRoutines}
	private static int[] getLexemNum(org.textmapper.lapg.api.@Grammar grammar) {
		org.textmapper.lapg.api.@LexerRule[] lexerRules = grammar.getLexerRules();
		int[] result = new int[lexerRules.length];
		for (int i = 0; i < lexerRules.length; i++) {
			result[i] = lexerRules[i].getSymbol().getIndex();
		}
		return result;
	}
${end}

${template lexerTables-}
${end}

${cached query hasLexemActions() = false}

${cached query classLexems() = []}

${query numOfChars = 'tmCharsCount'}

${query tmStateMapExists() = true}