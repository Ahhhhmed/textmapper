
// Ast

class Input {
	Header header;
	list<Import> importOptlist;
	list<Option> optionOptlist;
	LexerSection lexerSection;
	ParserSection parserSection;
}

input  : Input ::=
	{header} importOptlist=import__optlist optionOptlist=option_optlist lexerSection=lexer_section parserSection=parser_section?
;

class Header {
	Name target;
	Name name;
	ParsingAlgorithm parsingAlgorithm;
}

header  : Header ::=
	Llanguage {name} ('(' target=name ')')? parsingAlgorithm=parsing_algorithmopt ';'
;

class LexerSection {
	list<LexerPartsItem> lexerParts;
}

lexer_section  : LexerSection ::=
	'::' Llexer lexerParts=lexer_parts
;

class ParserSection {
	list<GrammarPartsItem> grammarParts;
}

parser_section  : ParserSection ::=
	'::' Lparser grammarParts=grammar_parts
;

class ParsingAlgorithm {
	Integer la;
}

parsing_algorithm  : ParsingAlgorithm ::=
	Llalr '(' la=icon ')'
;

class Import {
	String alias;
	String file;
}

import_  : Import ::=
	Limport alias=ID? file=scon ';'
;

class Option {
	String ID;
	Expression expression;
	SyntaxProblem syntaxProblem;
}

option  : Option ::=
	{ID} '=' {expression}
  | syntaxProblem=syntax_problem
;

class Identifier {
	String ID;
}

identifier  : Identifier ::=
	{ID}
;

class Symref : Expression {
	String name;
}

symref  : Symref ::=
	name=ID
;

type (String) ::=
	'(' scon ')'
  | '(' type_part_list ')'
;

type_part_list  : void
	(type_part)+ ;

type_part  : void ::=
	'<'
  | '>'
  | '['
  | ']'
  | ID
  | '*'
  | '.'
  | ','
  | '?'
  | '@'
  | '&'
  | '(' type_part_list? ')'
;

class Pattern {
	String regexp;
}

pattern  : Pattern ::=
	{regexp}
;

class LexerPartsItem {
	LexerPart lexerPart;
	SyntaxProblem syntaxProblem;
}

lexer_parts  : list<LexerPartsItem>
	this+=new.LexerPartsItem(lexerPart=lexer_part)
		(this+=new.LexerPartsItem((lexerPart=lexer_part | syntaxProblem=syntax_problem)))* ;

interface LexerPart {
}

lexer_part  : LexerPart ::=
	this=state_selector
  | this=named_pattern
  | this=lexeme
;

class NamedPattern : LexerPart {
	String name;
	Pattern pattern;
}

named_pattern  : NamedPattern ::=
	name=ID '=' {pattern}
;

class Lexeme : LexerPart {
	Identifier name;
	Integer priority;
	String type;
	Pattern pattern;
	Stateref lexemTransition;
	LexemAttrs lexemAttrs;
	Command command;
}

lexeme  : Lexeme ::=
	name=identifier type=typeopt ':' ({pattern} lexemTransition=lexem_transitionopt priority=iconopt lexemAttrs=lexem_attrsopt command=commandopt)?
;

class Stateref {
	String name;
}

lexem_transition  : Stateref ::=
	'=>' this=stateref
;

class LexemAttrs {
	LexemAttribute lexemAttribute;
}

lexem_attrs  : LexemAttrs ::=
	'(' lexemAttribute=lexem_attribute ')'
;

enum LexemAttribute {
	LSOFT,
	LCLASS,
	LSPACE,
	LLAYOUT
}

lexem_attribute  : LexemAttribute ::=
	this=Lsoft as LexemAttribute.LSOFT
  | this=Lclass as LexemAttribute.LCLASS
  | this=Lspace as LexemAttribute.LSPACE
  | this=Llayout as LexemAttribute.LLAYOUT
;

class StateSelector : LexerPart {
	list<LexerState> states;
}

state_selector  : StateSelector ::=
	'[' states=lexer_state_list ']'
;

stateref  : Stateref ::=
	name=ID
;

class LexerState {
	Identifier name;
	Stateref defaultTransition;
}

lexer_state  : LexerState ::=
	name=identifier ('=>' defaultTransition=stateref)?
;

class GrammarPartsItem {
	GrammarPart grammarPart;
	SyntaxProblem syntaxProblem;
}

grammar_parts  : list<GrammarPartsItem>
	this+=new.GrammarPartsItem(grammarPart=grammar_part)
		(this+=new.GrammarPartsItem((grammarPart=grammar_part | syntaxProblem=syntax_problem)))* ;

interface GrammarPart {
}

grammar_part  : GrammarPart ::=
	this=nonterm
  | this=directive
;

class Nonterm : GrammarPart {
	Identifier name;
	NontermType type;
	Annotations annotations;
	list<Rule0> rules;
}

nonterm  : Nonterm ::=
	{annotations}? name=identifier type=nonterm_type? '::=' {rules} ';'
;

interface NontermType {
}

class NontermTypeAST : NontermType {
	Symref symref;
}

class NontermTypeHint : NontermType {
	boolean isInline;
	KindKind kind;
	Identifier name;
	enum KindKind {
		LVOID,
		LINTERFACE,
		LCLASS
	}
}

class NontermTypeRaw : NontermType {
	String type;
}

nonterm_type  : NontermType ::=
	this=new.NontermTypeAST: Lreturns {symref}
  | this=new.NontermTypeHint: isInline=Linline as true? kind=Lclass as KindKind.LCLASS name=identifieropt
  | this=new.NontermTypeHint: kind=Linterface as KindKind.LINTERFACE name=identifieropt
  | this=new.NontermTypeHint: kind=Lvoid as KindKind.LVOID
  | this=new.NontermTypeRaw: {type}
;

enum Assoc {
	LLEFT,
	LRIGHT,
	LNONASSOC
}

assoc  : Assoc ::=
	this=Lleft as Assoc.LLEFT
  | this=Lright as Assoc.LRIGHT
  | this=Lnonassoc as Assoc.LNONASSOC
;

class DirectivePrio : GrammarPart {
	list<Symref> symbols;
	Assoc assoc;
}

class DirectiveInput : GrammarPart {
	list<Inputref> inputRefs;
}

directive  : GrammarPart ::=
	this=new.DirectivePrio: '%' {assoc} symbols=references ';'
  | this=new.DirectiveInput: '%' Linput inputRefs=inputref_list ';'
;

class Inputref {
	boolean noeoi;
	Symref symref;
}

inputref  : Inputref ::=
	{symref} noeoi=Lnoeoi as true?
;

references  : list<Symref>
	(this+=symref)+ ;

references_cs  : list<Symref>
	(this+=symref
		separator ',')+ ;

rules  : list<Rule0> ::=
	this=rule0_list
;

class Rule0 {
	RhsPrefix rhsPrefix;
	list<RhsPartsItem> rhsParts;
	RhsSuffix rhsSuffix;
	SyntaxProblem syntaxProblem;
}

rule0  : Rule0 ::=
	{rhsPrefix}? {rhsParts}? rhsSuffix=rhsSuffixopt
  | syntaxProblem=syntax_problem
;

class RhsPrefix {
	Annotations annotations;
	Identifier alias;
}

rhsPrefix  : RhsPrefix ::=
	'[' {annotations} ']'
  | '[' {annotations}? alias=identifier ']'
;

class RhsSuffix {
	KindKind kind;
	Symref symref;
	enum KindKind {
		LSHIFT,
		LPRIO
	}
}

rhsSuffix  : RhsSuffix ::=
	'%' kind=Lprio as KindKind.LPRIO {symref}
  | '%' kind=Lshift as KindKind.LSHIFT {symref}
;

class RhsPartsItem {
	RhsPart rhsPart;
	SyntaxProblem syntaxProblem;
}

rhsParts  : list<RhsPartsItem>
	this+=new.RhsPartsItem({rhsPart})
		(this+=new.RhsPartsItem(({rhsPart} | syntaxProblem=syntax_problem)))* ;

interface RhsPart {
}

rhsPart  : RhsPart ::=
	this=rhsAnnotated
  | this=rhsUnordered
  | this=command
;

class RhsAnnotated : RhsPart {
	RhsAnnotations rhsAnnotations;
	RhsPart rhsAssignment;
}

rhsAnnotated  : RhsPart ::=
	this=rhsAssignment
  | this=new.RhsAnnotated: {rhsAnnotations} {rhsAssignment}
;

class RhsAssignment : RhsPart {
	Identifier id;
	boolean addition;
	RhsPart inner;
}

rhsAssignment  : RhsPart ::=
	this=rhsOptional
  | this=new.RhsAssignment: id=identifier ('=' | addition='+=' as true) inner=rhsOptional
;

class RhsOptional : RhsPart {
	RhsPart rhsCast;
}

rhsOptional  : RhsPart ::=
	this=rhsCast
  | this=new.RhsOptional: {rhsCast} '?'
;

class RhsCast : RhsPart {
	RhsPart rhsClass;
	Symref symref;
	Literal literal;
}

rhsCast  : RhsPart ::=
	this=rhsClass
  | this=new.RhsCast: {rhsClass} Las {symref}
  | this=new.RhsCast: {rhsClass} Las {literal}
;

class RhsUnordered : RhsPart {
	RhsPart left;
	RhsPart right;
}

rhsUnordered  : RhsPart ::=
	this=new.RhsUnordered: left=rhsPart '&' right=rhsPart
;

class RhsClass : RhsPart {
	Identifier identifier;
	RhsPart rhsPrimary;
}

rhsClass  : RhsPart ::=
	this=rhsPrimary
  | this=new.RhsClass: {identifier} ':' {rhsPrimary}
;

class RhsPrimarySymbol : RhsPart {
	Symref symref;
}

class RhsPrimaryGroup : RhsPart {
	list<Rule0> rules;
}

class RhsPrimaryList : RhsPart {
	QuantifierKind quantifier;
	list<RhsPartsItem> rhsParts;
	list<Symref> references;
	RhsPart rhsPrimary;
	enum QuantifierKind {
		PLUS,
		MULT
	}
}

rhsPrimary  : RhsPart ::=
	this=new.RhsPrimarySymbol: {symref}
  | this=new.RhsPrimaryGroup: '(' {rules} ')'
  | this=new.RhsPrimaryList: '(' {rhsParts} Lseparator {references} ')' quantifier='+' as QuantifierKind.PLUS
  | this=new.RhsPrimaryList: '(' {rhsParts} Lseparator {references} ')' quantifier='*' as QuantifierKind.MULT
  | this=new.RhsPrimaryList: {rhsPrimary} quantifier='*' as QuantifierKind.MULT
  | this=new.RhsPrimaryList: {rhsPrimary} quantifier='+' as QuantifierKind.PLUS
;

class RhsAnnotations {
	list<Annotation> annotationList;
	NegativeLa negativeLa;
}

rhsAnnotations  : RhsAnnotations ::=
	annotationList=annotation_list
  | negativeLa=negative_la annotationList=annotation_list
  | negativeLa=negative_la
;

class Annotations {
	list<Annotation> annotations;
}

annotations  : Annotations ::=
	annotations=annotation_list
;

class Annotation {
	String name;
	Expression expression;
	SyntaxProblem syntaxProblem;
}

annotation  : Annotation ::=
	'@' name=ID ('{' {expression} '}')?
  | '@' syntaxProblem=syntax_problem
;

class NegativeLa {
	list<Symref> unwantedSymbols;
}

negative_la  : NegativeLa ::=
	'(?!' unwantedSymbols=symref_list ')'
;

interface Expression {
}

class ExpressionInstance : Expression {
	Name className;
	list<MapEntriesItem> mapEntries;
}

class ExpressionArray : Expression {
	list<Expression> content;
}

expression  : Expression ::=
	this=literal
  | this=symref
  | this=new.ExpressionInstance: Lnew className=name '(' mapEntries=map_entriesopt ')'
  | this=new.ExpressionArray: '[' content=expression_list_opt ']'
  | this=syntax_problem
;

class Literal : Expression {
	String sval;
	Integer ival;
	boolean val;
}

literal  : Literal ::=
	sval=scon
  | ival=icon
  | val=Ltrue as true
  | val=Lfalse as false
;

class MapEntriesItem {
	String ID;
	Expression expression;
}

map_entries  : list<MapEntriesItem>
	(this+=new.MapEntriesItem({ID} map_separator {expression})
		separator ',')+ ;

map_separator  : void ::=
	':'
  | '='
  | '=>'
;

class Name {
	String qualifiedId;
}

name  : Name ::=
	qualifiedId=qualified_id
;

qualified_id (String) ::=
	ID
  | qualified_id '.' ID
;

class Command : RhsPart {
}

command  : Command ::=
	code
;

class SyntaxProblem : Expression {
}

syntax_problem  : SyntaxProblem ::=
	error
;

import__optlist  : list<Import>
	(this+=import_)* ;

option_optlist  : list<Option>
	(this+=option)* ;

parsing_algorithmopt  : ParsingAlgorithm ::=
	this=parsing_algorithm?
;

typeopt (String) ::=
	type?
;

lexem_transitionopt  : Stateref ::=
	this=lexem_transition?
;

iconopt (Integer) ::=
	icon?
;

lexem_attrsopt  : LexemAttrs ::=
	this=lexem_attrs?
;

commandopt  : Command ::=
	this=command?
;

lexer_state_list  : list<LexerState>
	(this+=lexer_state
		separator ',')+ ;

identifieropt  : Identifier ::=
	this=identifier?
;

inputref_list  : list<Inputref>
	(this+=inputref
		separator ',')+ ;

rule0_list  : list<Rule0>
	(this+=rule0
		separator '|')+ ;

rhsSuffixopt  : RhsSuffix ::=
	this=rhsSuffix?
;

annotation_list  : list<Annotation>
	(this+=annotation)+ ;

symref_list  : list<Symref>
	(this+=symref
		separator '|')+ ;

map_entriesopt  : list<MapEntriesItem> ::=
	this=map_entries?
;

expression_list  : list<Expression>
	(this+=expression
		separator ',')+ ;

expression_list_opt  : list<Expression> ::=
	this=expression_list?
;

