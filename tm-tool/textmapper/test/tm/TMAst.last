
// Ast

class Input {
	Header header;
	list<Import> importOptlist;
	list<Option> optionOptlist;
	LexerSection lexerSection;
	ParserSection parserSection;
}

input  : Input ::=
	{header} importOptlist=import__optlist optionOptlist=option_optlist lexerSection=lexer_section parserSection=parser_section?
;

class Header {
	Name name;
	Name target;
	ParsingAlgorithm parsingAlgorithm;
}

header  : Header ::=
	Llanguage {name} ('(' target=name ')')? parsingAlgorithm=parsing_algorithmopt ';'
;

class LexerSection {
	list<LexerPartsItem> lexerParts;
}

lexer_section  : LexerSection ::=
	'::' Llexer lexerParts=lexer_parts
;

class ParserSection {
	list<GrammarPartsItem> grammarParts;
}

parser_section  : ParserSection ::=
	'::' Lparser grammarParts=grammar_parts
;

class ParsingAlgorithm {
	Integer la;
}

parsing_algorithm  : ParsingAlgorithm ::=
	Llalr '(' la=icon ')'
;

class Import {
	String alias;
	String file;
}

import_  : Import ::=
	Limport alias=ID? file=scon ';'
;

class Option {
	String key;
	Expression value;
	SyntaxProblem syntaxProblem;
}

option  : Option ::=
	key=ID '=' value=expression
  | syntaxProblem=syntax_problem
;

class Identifier {
	String ID;
}

identifier  : Identifier ::=
	{ID}
;

class Symref : Expression {
	String name;
}

symref  : Symref ::=
	name=ID
;

type (String) ::=
	'(' scon ')'
  | '(' type_part_list ')'
;

type_part_list  : void
	(type_part)+ ;

type_part  : void ::=
	'<'
  | '>'
  | '['
  | ']'
  | ID
  | '*'
  | '.'
  | ','
  | '?'
  | '@'
  | '&'
  | '(' type_part_list? ')'
;

class Pattern {
	String regexp;
}

pattern  : Pattern ::=
	{regexp}
;

class LexerPartsItem {
	LexerPart lexerPart;
	SyntaxProblem syntaxProblem;
}

lexer_parts  : list<LexerPartsItem>
	this+=new.LexerPartsItem(lexerPart=lexer_part)
		(this+=new.LexerPartsItem((lexerPart=lexer_part | syntaxProblem=syntax_problem)))* ;

interface LexerPart {
}

lexer_part  : LexerPart ::=
	this=state_selector
  | this=named_pattern
  | this=lexeme
;

class NamedPattern : LexerPart {
	String name;
	Pattern pattern;
}

named_pattern  : NamedPattern ::=
	name=ID '=' {pattern}
;

class Lexeme : LexerPart {
	Identifier name;
	String type;
	Pattern pattern;
	Stateref transition;
	Integer priority;
	LexemeAttrs attrs;
	Command command;
}

lexeme  : Lexeme ::=
	name=identifier type=typeopt ':' ({pattern} transition=lexeme_transitionopt priority=iconopt attrs=lexeme_attrsopt command=commandopt)?
;

class Stateref {
	String name;
}

lexeme_transition  : Stateref ::=
	'=>' this=stateref
;

class LexemeAttrs {
	LexemeAttribute kind;
}

lexeme_attrs  : LexemeAttrs ::=
	'(' kind=lexeme_attribute ')'
;

enum LexemeAttribute {
	LSOFT,
	LCLASS,
	LSPACE,
	LLAYOUT
}

lexeme_attribute  : LexemeAttribute ::=
	this=Lsoft as LexemeAttribute.LSOFT
  | this=Lclass as LexemeAttribute.LCLASS
  | this=Lspace as LexemeAttribute.LSPACE
  | this=Llayout as LexemeAttribute.LLAYOUT
;

class StateSelector : LexerPart {
	list<LexerState> states;
}

state_selector  : StateSelector ::=
	'[' states=lexer_state_list_Comma_separated ']'
;

stateref  : Stateref ::=
	name=ID
;

class LexerState {
	Identifier name;
	Stateref defaultTransition;
}

lexer_state  : LexerState ::=
	name=identifier ('=>' defaultTransition=stateref)?
;

class GrammarPartsItem {
	GrammarPart grammarPart;
	SyntaxProblem syntaxProblem;
}

grammar_parts  : list<GrammarPartsItem>
	this+=new.GrammarPartsItem(grammarPart=grammar_part)
		(this+=new.GrammarPartsItem((grammarPart=grammar_part | syntaxProblem=syntax_problem)))* ;

interface GrammarPart {
}

grammar_part  : GrammarPart ::=
	this=nonterm
  | this=directive
;

class Nonterm : GrammarPart {
	Annotations annotations;
	Identifier name;
	NontermType type;
	list<Rule0> rules;
}

nonterm  : Nonterm ::=
	{annotations}? name=identifier type=nonterm_type? '::=' {rules} ';'
;

interface NontermType {
}

class NontermTypeAST : NontermType {
	Symref symref;
}

class NontermTypeHint : NontermType {
	boolean isInline;
	KindKind kind;
	Identifier name;
	enum KindKind {
		LCLASS,
		LVOID,
		LINTERFACE
	}
}

class NontermTypeRaw : NontermType {
	String text;
}

nonterm_type  : NontermType ::=
	this=new.NontermTypeAST: Lreturns {symref}
  | this=new.NontermTypeHint: isInline=Linline as true? kind=Lclass as KindKind.LCLASS name=identifieropt
  | this=new.NontermTypeHint: kind=Linterface as KindKind.LINTERFACE name=identifieropt
  | this=new.NontermTypeHint: kind=Lvoid as KindKind.LVOID
  | this=new.NontermTypeRaw: text=type
;

enum Assoc {
	LLEFT,
	LRIGHT,
	LNONASSOC
}

assoc  : Assoc ::=
	this=Lleft as Assoc.LLEFT
  | this=Lright as Assoc.LRIGHT
  | this=Lnonassoc as Assoc.LNONASSOC
;

class DirectivePrio : GrammarPart {
	Assoc assoc;
	list<Symref> symbols;
}

class DirectiveInput : GrammarPart {
	list<Inputref> inputRefs;
}

directive  : GrammarPart ::=
	this=new.DirectivePrio: '%' {assoc} symbols=references ';'
  | this=new.DirectiveInput: '%' Linput inputRefs=inputref_list_Comma_separated ';'
;

class Inputref {
	Symref reference;
	boolean noeoi;
}

inputref  : Inputref ::=
	reference=symref noeoi=Lnoeoi as true?
;

references  : list<Symref>
	(this+=symref)+ ;

references_cs  : list<Symref>
	(this+=symref
		separator ',')+ ;

rules  : list<Rule0> ::=
	this=rule0_list_Or_separated
;

class Rule0 {
	RhsPrefix rhsPrefix;
	list<RhsPartsItem> rhsParts;
	RhsSuffix rhsSuffix;
	SyntaxProblem syntaxProblem;
}

rule0  : Rule0 ::=
	{rhsPrefix}? {rhsParts}? rhsSuffix=rhsSuffixopt
  | syntaxProblem=syntax_problem
;

class RhsPrefix {
	Annotations annotations;
	Identifier alias;
}

rhsPrefix  : RhsPrefix ::=
	'[' {annotations} ']'
  | '[' {annotations}? alias=identifier ']'
;

class RhsSuffix {
	KindKind kind;
	Symref symref;
	enum KindKind {
		LPRIO,
		LSHIFT
	}
}

rhsSuffix  : RhsSuffix ::=
	'%' kind=Lprio as KindKind.LPRIO {symref}
  | '%' kind=Lshift as KindKind.LSHIFT {symref}
;

class RhsPartsItem {
	RhsPart rhsPart;
	SyntaxProblem syntaxProblem;
}

rhsParts  : list<RhsPartsItem>
	this+=new.RhsPartsItem({rhsPart})
		(this+=new.RhsPartsItem(({rhsPart} | syntaxProblem=syntax_problem)))* ;

interface RhsPart {
}

rhsPart  : RhsPart ::=
	this=rhsAnnotated
  | this=rhsUnordered
  | this=command
;

class RhsAnnotated : RhsPart {
	Annotations annotations;
	RhsPart rhsAssignment;
}

rhsAnnotated  : RhsPart ::=
	this=rhsAssignment
  | this=new.RhsAnnotated: {annotations} {rhsAssignment}
;

class RhsAssignment : RhsPart {
	Identifier id;
	boolean addition;
	RhsPart inner;
}

rhsAssignment  : RhsPart ::=
	this=rhsOptional
  | this=new.RhsAssignment: id=identifier ('=' | addition='+=' as true) inner=rhsOptional
;

class RhsQuantifier : RhsPart {
	RhsPart inner;
	QuantifierKind quantifier;
	enum QuantifierKind {
		QUESTIONMARK,
		PLUS,
		MULT
	}
}

rhsOptional  : RhsPart ::=
	this=rhsCast
  | this=new.RhsQuantifier: inner=rhsCast quantifier='?' as QuantifierKind.QUESTIONMARK
;

class RhsCast : RhsPart {
	RhsPart rhsClass;
	Symref symref;
}

class RhsAsLiteral : RhsPart {
	RhsPart inner;
	Literal literal;
}

rhsCast  : RhsPart ::=
	this=rhsClass
  | this=new.RhsCast: {rhsClass} Las {symref}
  | this=new.RhsAsLiteral: inner=rhsClass Las {literal}
;

class RhsUnordered : RhsPart {
	RhsPart left;
	RhsPart right;
}

rhsUnordered  : RhsPart ::=
	this=new.RhsUnordered: left=rhsPart '&' right=rhsPart
;

class RhsClass : RhsPart {
	Identifier identifier;
	RhsPart inner;
}

rhsClass  : RhsPart ::=
	this=rhsPrimary
  | this=new.RhsClass: {identifier} ':' inner=rhsPrimary
;

class RhsSymbol : RhsPart {
	Symref reference;
}

class RhsNested : RhsPart {
	list<Rule0> rules;
}

class RhsList : RhsPart {
	list<RhsPartsItem> rhsParts;
	list<Symref> references;
	QuantifierKind quantifier;
	enum QuantifierKind {
		PLUS,
		MULT
	}
}

class RhsIgnored : RhsPart {
	list<Rule0> rules;
	list<RhsBracketsPair> brackets;
}

rhsPrimary  : RhsPart ::=
	this=new.RhsSymbol: reference=symref
  | this=new.RhsNested: '(' {rules} ')'
  | this=new.RhsList: '(' {rhsParts} Lseparator {references} ')' quantifier='+' as QuantifierKind.PLUS
  | this=new.RhsList: '(' {rhsParts} Lseparator {references} ')' quantifier='*' as QuantifierKind.MULT
  | this=new.RhsQuantifier: inner=rhsPrimary quantifier='*' as QuantifierKind.MULT
  | this=new.RhsQuantifier: inner=rhsPrimary quantifier='+' as QuantifierKind.PLUS
  | this=new.RhsIgnored: '$' '(' {rules} (';' brackets=rhsBracketsPair_list_Comma_separated)? ')'
;

class RhsBracketsPair {
	Symref lhs;
	Symref rhs;
}

rhsBracketsPair  : RhsBracketsPair ::=
	lhs=symref '..' rhs=symref
;

class Annotations {
	list<Annotation> annotations;
}

annotations  : Annotations ::=
	annotations=annotation_list
;

class Annotation {
	String name;
	Expression expression;
	SyntaxProblem syntaxProblem;
}

annotation  : Annotation ::=
	'@' name=ID ('{' {expression} '}')?
  | '@' syntaxProblem=syntax_problem
;

interface Expression {
}

class Instance : Expression {
	Name className;
	list<MapEntriesItem> mapEntries;
}

class Array : Expression {
	list<Expression> content;
}

expression  : Expression ::=
	this=literal
  | this=symref
  | this=new.Instance: Lnew className=name '(' mapEntries=map_entriesopt ')'
  | this=new.Array: '[' content=expression_list_Comma_separated_opt ']'
  | this=syntax_problem
;

class Literal : Expression {
	String sval;
	Integer ival;
	boolean val;
}

literal  : Literal ::=
	sval=scon
  | ival=icon
  | val=Ltrue as true
  | val=Lfalse as false
;

class MapEntriesItem {
	String ID;
	Expression expression;
}

map_entries  : list<MapEntriesItem>
	(this+=new.MapEntriesItem({ID} map_separator {expression})
		separator ',')+ ;

map_separator  : void ::=
	':'
  | '='
  | '=>'
;

class Name {
	String qualifiedId;
}

name  : Name ::=
	qualifiedId=qualified_id
;

qualified_id (String) ::=
	ID
  | qualified_id '.' ID
;

class Command : RhsPart {
}

command  : Command ::=
	code
;

class SyntaxProblem : Expression {
}

syntax_problem  : SyntaxProblem ::=
	error
;

import__optlist  : list<Import>
	(this+=import_)* ;

option_optlist  : list<Option>
	(this+=option)* ;

parsing_algorithmopt  : ParsingAlgorithm ::=
	this=parsing_algorithm?
;

typeopt (String) ::=
	type?
;

lexeme_transitionopt  : Stateref ::=
	this=lexeme_transition?
;

iconopt (Integer) ::=
	icon?
;

lexeme_attrsopt  : LexemeAttrs ::=
	this=lexeme_attrs?
;

commandopt  : Command ::=
	this=command?
;

lexer_state_list_Comma_separated  : list<LexerState>
	(this+=lexer_state
		separator ',')+ ;

identifieropt  : Identifier ::=
	this=identifier?
;

inputref_list_Comma_separated  : list<Inputref>
	(this+=inputref
		separator ',')+ ;

rule0_list_Or_separated  : list<Rule0>
	(this+=rule0
		separator '|')+ ;

rhsSuffixopt  : RhsSuffix ::=
	this=rhsSuffix?
;

rhsBracketsPair_list_Comma_separated  : list<RhsBracketsPair>
	(this+=rhsBracketsPair
		separator ',')+ ;

annotation_list  : list<Annotation>
	(this+=annotation)+ ;

map_entriesopt  : list<MapEntriesItem> ::=
	this=map_entries?
;

expression_list_Comma_separated  : list<Expression>
	(this+=expression
		separator ',')+ ;

expression_list_Comma_separated_opt  : list<Expression> ::=
	this=expression_list_Comma_separated?
;

