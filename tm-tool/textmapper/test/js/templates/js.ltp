${template main-}
${file opts.prefix+'_parser.js'-}
// generated parser

(function(window) {

var ${opts.prefix} = {
	DEBUG_SYNTAX: false
};

${call js_lexer.unit-}
${call unit-}

window.${opts.prefix} = ${opts.prefix};

})(window);
${end-}
${end}





${template unit-}

${opts.prefix}.NonTerm = {
${for i in [parser.nterms, parser.nsyms-1]-}
	${parser.sym[i].id->escapeJsReserved()}: ${i}${if i < parser.nsyms-1},${end}
${end-}
};

${opts.prefix}.Parser = function() {
};

${opts.prefix}.Parser.prototype = {
${call parserTables-}

	lapg_syms: [
${foreach s in parser.sym separator ',\n'-}
		"${s.name}"${end}
	],

	lapg_next: function(state,symbol) {
${if parser.nactions > 0-}
		var p;
		if (this.lapg_action[state] < -2) {
			for (p = -this.lapg_action[state] - 3; this.lapg_lalr[p] >= 0; p += 2) {
				if (this.lapg_lalr[p] == symbol) {
					break;
				}
			}
			return this.lapg_lalr[p + 1];
		}
${end-}
		return this.lapg_action[state];
	},

	lapg_state_sym: function(state, symbol) {
		var min = this.lapg_sym_goto[symbol], max = this.lapg_sym_goto[symbol + 1] - 1;
		var i, e;

		while (min <= max) {
			e = (min + max) >> 1;
			i = this.lapg_sym_from[e];
			if (i == state) {
				return this.lapg_sym_to[e];
			} else if (i < state) {
				min = e + 1;
			} else {
				max = e - 1;
			}
		}
		return -1;
	},

	parse: function(lexer${if syntax.input.length > 1}, state${end}) {
		this.lapg_m = new Array(${opts.stack});
		this.lapg_head = 0;
${if syntax.error}		var lapg_symbols_ok = 4;
${end-}

		this.lapg_m[0] = {
			state: ${syntax.input.length > 1 ? 'state' : 0}
		};
		this.lapg_n = lexer.next();

		while (this.lapg_m[this.lapg_head].state != ${syntax.input.length > 1 ? (parser.nstates - syntax.input.length) + '+state' : parser.nstates-1}) {
			var lapg_i = this.lapg_next(this.lapg_m[this.lapg_head].state, this.lapg_n.symbol);

			if (lapg_i >= 0) {
				this.reduce(lapg_i);
			} else if (lapg_i == -1) {
				this.shift(lexer);
${if syntax.error}				lapg_symbols_ok++;
${end-}
			}

			if (lapg_i == -2 || this.lapg_m[this.lapg_head].state == -1) {
${if syntax.error-}
				if (this.lapg_n.symbol == 0) {
					break;
				}
				while (this.lapg_head >= 0 && this.lapg_state_sym(this.lapg_m[this.lapg_head].state, ${syntax.error.index}) == -1) {
					this.lapg_m[this.lapg_head] = null; // TODO dispose?
					this.lapg_head--;
				}
				if (this.lapg_head >= 0) {
					this.lapg_m[++this.lapg_head] = {
						symbol: ${syntax.error.index},
						state: this.lapg_state_sym(this.lapg_m[this.lapg_head - 1].state, ${syntax.error.index}),
${if opts.positions.contains('line')-}
						line: this.lapg_n.line,
${end-}
${if opts.positions.contains('column')-}
						column: this.lapg_n.column,
${end-}
${if opts.positions.contains('offset')-}
						offset: this.lapg_n.offset,
${end-}
${if opts.endpositions.contains('line')-}
						endline: this.lapg_n.endline,
${end-}
${if opts.endpositions.contains('column')-}
						endcolumn: this.lapg_n.endcolumn,
${end-}
${if opts.endpositions.contains('offset')-}
						endoffset: this.lapg_n.endoffset,
${end-}
						sym: null
					};
					if (lapg_symbols_ok >= 4) {
${if opts.positions.contains('column')-}
						lexer.errorHandler(${call err_location('this.lapg_n')}lexer.tokenLine, "syntax error before line " + lexer.tokenLine + ", column " + this.lapg_n.column);
${else-}
						lexer.errorHandler(${call err_location('this.lapg_n')}lexer.tokenLine, "syntax error before line " + lexer.tokenLine);
${end-}
					}
					if (lapg_symbols_ok <= 1) {
						this.lapg_n = lexer.next();
					}
					lapg_symbols_ok = 0;
					continue;
				} else {
					this.lapg_head = 0;
					this.lapg_m[0] = {
						state: ${syntax.input.length > 1 ? 'state' : 0}
					};
				}
${end-}
				break;
			}
		}

		if (this.lapg_m[this.lapg_head].state != ${syntax.input.length > 1 ? (parser.nstates - syntax.input.length) + '+state' : parser.nstates-1}) {
${if syntax.error-}
			if (lapg_symbols_ok >= 4) {
	${else-}
${end}			lexer.errorHandler(${call err_location('this.lapg_n')}lexer.tokenLine, "syntax error before line " + lexer.tokenLine${if opts.positions.contains('column')} + ", column " + this.lapg_n.column${end});
${if syntax.error-}
			}
${end-}
			return null;
		}
		return this.lapg_m[this.lapg_head - 1].sym;
	},

	shift: function(lexer) {
		this.lapg_m[++this.lapg_head] = this.lapg_n;
		this.lapg_m[this.lapg_head].state = this.lapg_state_sym(this.lapg_m[this.lapg_head - 1].state, this.lapg_n.symbol);
		if (${opts.prefix}.DEBUG_SYNTAX) {
			${opts.prefix}.DEBUG_SYNTAX("shift: " + this.lapg_syms[this.lapg_n.symbol] + " (" + lexer.token + ")");
		}
		if (this.lapg_m[this.lapg_head].state != -1 && this.lapg_n.symbol != 0) {
			this.lapg_n = lexer.next();
		}
	},

	reduce: function(rule) {
		var lapg_gg = {};
		lapg_gg.sym = (this.lapg_rlen[rule] != 0) ? this.lapg_m[this.lapg_head + 1 - this.lapg_rlen[rule]].sym : null;
		lapg_gg.symbol = this.lapg_rlex[rule];
		lapg_gg.state = 0;
		if (${opts.prefix}.DEBUG_SYNTAX) {
			${opts.prefix}.DEBUG_SYNTAX("reduce to " + this.lapg_syms[this.lapg_rlex[rule]]);
		}
${if opts.positions.contains('line') || opts.positions.contains('offset') || opts.positions.contains('column')-}
		var startsym = (this.lapg_rlen[rule] != 0) ? this.lapg_m[this.lapg_head + 1 - this.lapg_rlen[rule]] : this.lapg_n;
${if opts.positions.contains('line')-}
		lapg_gg.line = startsym.line;
${end-}
${if opts.positions.contains('column')-}
		lapg_gg.column = startsym.column;
${end-}
${if opts.positions.contains('offset')-}
		lapg_gg.offset = startsym.offset;
${end-}
${end-}
${if opts.endpositions.contains('line')-}
		lapg_gg.endline = (this.lapg_rlen[rule] != 0) ? this.lapg_m[this.lapg_head].endline : this.lapg_n.line;
${end-}
${if opts.endpositions.contains('column')-}
		lapg_gg.endcolumn = (this.lapg_rlen[rule] != 0) ? this.lapg_m[this.lapg_head].endcolumn : this.lapg_n.column;
${end-}
${if opts.endpositions.contains('offset')-}
		lapg_gg.endoffset = (this.lapg_rlen[rule] != 0) ? this.lapg_m[this.lapg_head].endoffset : this.lapg_n.offset;
${end-}
${if syntax.hasActions() || opts.genast == 'on'-}
		switch (rule) {
${foreach rule in syntax.rules-}
${if rule.getAction() || opts.genast == 'on' && self->java_ast.astcode(rule)-}
			case ${rule.getIndex()}:  // ${rule}
${if rule.getAction()-}
				${call parserAction for rule-}
${if opts.breaks == 'on'}				break;$/
${else-}
				${call astAction(self->java_ast.astcode(rule)) for rule-}
				break;
${end-}
${end-}
${end-}
		}
${end-}
		for (var e = this.lapg_rlen[rule]; e > 0; e--) {
			this.lapg_m[this.lapg_head--] = null;
		}
		this.lapg_m[++this.lapg_head] = lapg_gg;
		this.lapg_m[this.lapg_head].state = this.lapg_state_sym(this.lapg_m[this.lapg_head - 1].state, lapg_gg.symbol);
	}
${if syntax.input.length > 1-}
${foreach inp in syntax.input}
	parse${util.toFirstUpper(inp.id)}: function(lexer) {
		return parse(lexer, ${index});
	}
${end-}
${end-}
};
${end}

${template parserTables-}
${call parserTable(parser.action_index, 'int', 'lapg_action', 'LapgAction')-}

${if parser.nactions > 0-}
${call parserTable(parser.action_table, 'short', 'lapg_lalr', 'LapgLalr')}
${end-}
${call parserTable(parser.sym_goto, 'short', 'lapg_sym_goto', 'LapgSymGoto')-}

${call parserTable(parser.sym_from, 'short', 'lapg_sym_from', 'LapgSymFrom')-}

${call parserTable(parser.sym_to, 'short', 'lapg_sym_to', 'LapgSymTo')-}

${call parserTable(parser.ruleLength, 'short', 'lapg_rlen', 'LapgRLen')-}

${call parserTable(parser.rleft, 'short', 'lapg_rlex', 'LapgRLex')-}
${if opts.packTables == 'true'}
${call java_pack.unpackInt-}
${call java_pack.unpackShort-}
${end-}
${end}


${template parserTable(arr, atype, name, cname)-}
	${name}: [
		${util.format(arr, 16, 2)}
	],
${end}

${template parserAction-}
${eval getAction(), '[action in '+getAction().getLocation()+']'}
${end}

${template astAction(code)-}
${eval code, '[generated action for '+self+']'-}
${end}

${template getsym-}
${if self.isLeft}lapg_gg${else}this.lapg_m[this.lapg_head-${self.rightOffset}]${end-}
${end}

${template symbol-}
${if symbol->type()-}
((${symbol->type()})${call getsym-}.sym)${else-}
${call getsym-}.sym${end-}
${end}

${template sym_line-}
${call getsym}.line${end}

${template sym_column-}
${call getsym}.column${end}

${template sym_offset-}
${call getsym}.offset${end}

${template sym_endline-}
${call getsym}.endline${end}

${template sym_endcolumn-}
${call getsym}.endcolumn${end}

${template sym_endoffset-}
${call getsym}.endoffset${end}

${template err_location(var)-}
${if opts.positions.contains('offset')}${var}.offset, ${end-}
${if opts.endpositions.contains('offset')}${var}.endoffset, ${end-}
${end}


${cached query type() = context.opts.genast == 'on' ? context->ast.getType(self) : self.type }


${query escapeJsReserved() =
	[
		'__proto__', 'undefined', 'null', 'true', 'false',

		'break', 'do', 'instanceof', 'typeof', 'case', 'else', 'new', 'var',
		'catch', 'finally', 'return', 'void', 'continue', 'for', 'switch', 'while',
		'debugger', 'function', 'this', 'with', 'default', 'if', 'throw',
		'delete', 'in', 'try',

		'class', 'enum', 'extends', 'super', 'const', 'export', 'import',

		'implements', 'let', 'private', 'public', 'yield', 'interface',
		'package', 'protected', 'static'

	].contains(self) ? '_' + self : self }
