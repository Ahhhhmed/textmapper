##

class Grammar {
	Symbol symbols[1..*];
	Rule rules[1..*];
	Prio priorities[0..*];

	Lexem lexems[0..*];

	int terminals;
	Symbol* input[1..*];
	Symbol* eoi;
	Symbol* error;

	SourceElement templates;

# TODO:
#	Map<String, Object> getOptions();
#	boolean hasActions();
#	boolean hasLexemActions();
#	boolean hasErrors();
}

class SourceElement {
	string text;
	string resourceName;
	int line;
	int offset;
	int endOffset;
}

class Lexem extends SourceElement {
	Symbol* symbol;
	string regexp;

	int priority;
	int groups;

	SourceElement action;
}

class Rule extends SourceElement {
	int index;
	Symbol left[1];
	SymbolRef right[0..*];
	int priority;
	SourceElement action;
}

class Prio extends SourceElement {
	int prio;
	Symbol* symbols[1..*];
}

class Symbol extends SourceElement {
	int index;
	string id;
	string name;
	string type;
	bool term;
}

class SymbolRef extends SourceElement {
	Symbol* target;
	string alias;
}

class Parser {
	Symbol* sym[1..*];
	int rules;
	int nsyms;
	int nterms;
	int nstates;
	int errorn;
	int rleft[0..*];
	int rright[0..*];
	int nactions;

# TODO
#	public int[] rindex, rprio;
#	public short[] sym_goto, sym_from, sym_to, action_table;
#	public int[] action_index;

}

class Lexer {
	int nstates;
	int nchars;
	int nterms;
	int lnum[0..*];
	int char2no[0..*];
	int groupset[0..*];

# TODO
#	public final int[][] change;
}

class List {
    int length;

# first(), last(), toSet(), size(), contains(x), indexOf(x), union(c)
}

class Options {
	string lang[identifier] = "";
}
