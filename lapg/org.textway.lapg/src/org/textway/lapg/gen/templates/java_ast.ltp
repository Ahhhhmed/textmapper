${template unit-}
${call astBaseInterface-}
${call astBaseClass-}
${call astVisitor-}
${foreach cl in self->ast.astModel().elements-}
${self->('ast_' + cl.kind)(cl)} 
${end-}
${if opts.genastdef-}
${file opts.prefix+'Ast.last'}${call ast_text.unit}${end-}
${end-}
${end}


${cached query interfaceName() =
	util.uniqueId('I' + context.opts.astprefix + util.toCamelCase(self.name, true)->java.escapeJavaReserved(), '__classes__')}

${cached query className() =
	util.uniqueId(context.opts.astprefix + util.toCamelCase(self.name, true)->java.escapeJavaReserved(), '__classes__')}

${cached query enumLiteralName(enumname) =
	util.uniqueId((alias ? alias : target.id).toUpperCase()->java.escapeJavaReserved(), '__classes__'+enumname)}

${cached query enumpropertyName(prop) =
	util.uniqueId(self.target.id.toUpperCase()->java.escapeJavaReserved(), '__prop__' + prop.container.name)}

${cached query propertyName() =
	util.uniqueId(util.toCamelCase(self.name, false)->java.escapeJavaReserved(), '__prop__' + self.container.name)}

${query propertyType() =
	self.kind == 'enumproperty'
		? 'int' :
	self.kind == 'flagproperty'
		? 'boolean' :
	context->convertType(self.type)
}

${query getType(q) =
	self->convertType(q is ast.AstType ? q : context->ast.getType(q))}

${query convertType(asttype) =
	asttype is ast.AstList ? 'java.util.@List<' + self->convertType(asttype.target) + '>' :
	asttype is ast.AstBool ? 'Boolean' :
	asttype is ast.AstObject ? 'Object' :
	asttype is ast.AstUserType ? asttype.text :
	self->astPackage() + '.@' + (
		asttype.kind == 'interface'
			? asttype->interfaceName()
			: asttype->className()
	)}


${template implementedInterfaces(cl, prefix)-}
${if cl.implements.length > 0-}
 ${prefix} ${foreach impl in cl.implements separator ', '}${impl->interfaceName()}${end-}
${else if prefix == 'extends'-}
 extends I${opts.astprefix}Node${end-}
${end}





${template ast_interface(cl)-}
${file self->astPath() + cl->interfaceName() + '.java'-}
package ${self->astPackage()};

public interface ${cl->interfaceName()}${call implementedInterfaces(cl,'extends')} {
}
${end-}
${end}



${template ast_class(cl)-}
${file self->astPath() + cl->className() + '.java'-}
package ${self->astPackage()};

public class ${cl->className()} extends ${opts.astprefix}Node${call implementedInterfaces(cl,'implements')} {

${foreach prop in cl.properties.select(x|x.kind=='enumproperty')-}
${foreach enumliteral in prop.refs-}
	public static final int ${enumliteral->enumpropertyName(prop)} = ${index+1};
${end-}

${end-}
${foreach prop in cl.properties-}
	private ${prop->propertyType()} ${prop->propertyName()};
${end-}

	public ${cl->className()}(${foreach prop in cl.properties}${prop->propertyType()} ${prop->propertyName()}, ${end}${call java.package}.${opts.prefix}Tree.@TextSource input, int start, int end) {
		super(input, start, end);
${foreach prop in cl.properties-}
		this.${prop->propertyName()} = ${prop->propertyName()};
${end-}
	}

${foreach prop in cl.properties-}
	public ${prop->propertyType()} get${util.toCamelCase(prop->propertyName(), true)}() {
		return ${prop->propertyName()};
	}
${end-}
${if true-}
	public void accept(${opts.astprefix}Visitor v) {
		if (!v.visit(this)) {
			return;
		}

${foreach prop in cl.properties.select(p|p.kind == 'property')-}
${if prop.type is ast.AstList && prop.type.target is ast.AstInterface -}
		if (${prop->propertyName()} != null) {
			for (${self->convertType(prop.type.target)} it : ${prop->propertyName()}) {
				it.accept(v);
			}
		}
${else if prop.type is ast.AstInterface -}
		if (${prop->propertyName()} != null) {
			${prop->propertyName()}.accept(v);
		}
${else-}
		// TODO for ${prop->propertyName()}
${end-}
${end-}
	}
${end-}
}
${end-}
${end}



${template ast_enum(cl)-}
${file self->astPath() + cl->className() + '.java'-}
package ${self->astPackage()};

public enum ${cl->className()} {
${foreach const in cl.literals-}
	${const->enumLiteralName(cl->className())},
${end-}
}
${end-}
${end}



${template astBaseInterface-}
${file self->astPath() + 'I' + opts.astprefix + 'Node.java'-}
package ${self->astPackage()};

public interface I${opts.astprefix}Node {
	int getOffset();
	int getEndOffset();
	${call java.package}.${opts.prefix}Tree.@TextSource getInput();
	void accept(${opts.astprefix}Visitor v);
}
${end-}
${end}


${template astVisitor-}
${file self->astPath() + opts.astprefix + 'Visitor.java'-}
package ${self->astPackage()};

public abstract class ${opts.astprefix}Visitor {
${foreach cl in self->ast.astModel().classes}
	protected boolean visit(${cl->className()} n) {
		return true;
	}
${end-}
}
${end-}
${end}


${template astBaseClass-}
${file self->astPath() + opts.astprefix + 'Node.java'-}
package ${self->astPackage()};

public abstract class ${opts.astprefix}Node implements I${opts.astprefix}Node {
	
	protected ${call java.package}.${opts.prefix}Tree.@TextSource fInput;
	protected int fStart;
	protected int fEnd;

	public ${opts.astprefix}Node(${call java.package}.${opts.prefix}Tree.@TextSource input, int start, int end) {
		this.fStart = start;
		this.fEnd = end;
		this.fInput = input;
	}

	public int getOffset() {
		return fStart;
	}

	public int getEndOffset() {
		return fEnd;
	}

	public ${call java.package}.${opts.prefix}Tree.@TextSource getInput() {
		return fInput;
	}

	public String toString() {
		return fInput == null ? "" : fInput.getText(fStart, fEnd);
	}

	//public abstract void accept(Visitor v);
}

${end-}
${end}


${query propValue(prop) for ast.AstRule =
	pind = prop.indexInRule(rule),
	prop.kind == 'enumproperty' ? ( pind >= 0
			? self->astPackage() + '.@' + ruleclass->className() + '.' + rule.getRight()[pind]->enumpropertyName(prop)
			: 0
		) :
	prop.kind == 'flagproperty' ? ( pind >= 0
			? 'true'
			: 'false'
		) :
	pind >= 0
		? '$'+ pind + ' /* ' + prop->propertyName() + ' */'
		: 'null /* ' + prop->propertyName() + ' */' }


${template createObject for ast.AstRule-}
new ${self->astPackage()}.@${ruleclass->className()}(
${foreach prop in ruleclass.properties -}
		${self->propValue(prop)},
${end-}
		${call astSource()}, ${if rule.getRight().length == 0}${'$'}{left().offset}, ${'$'}{left().endoffset}${else}${'$'}{first().offset}, ${'$'}{last().endoffset}${end-}
)${end}


${template codeForEnum for ast.AstEnumRule -}
${'$$'} = ${self->astPackage()}.@${ruleclass->className()}.${literal->enumLiteralName(ruleclass->className())};
${end}


${query codeForClass for ast.AstRule =
	'$$ = ' + self->createObject() + ';\n' }


${query codeForList for ast.AstListRule =
	newexpr =
		ruleclass ? self->createObject() :
		listitem ? (
			index = rule.getRight().indexOf(listitem),
			index >= 0
				? '$' + index
				: null
		) : null,
	!newexpr ? null :
	listkind == 'left'	 ? '$0.add(' + newexpr + ');\n' :
	listkind == 'right'	 ? '$'+(rule.getRight().size()-1)+'.add(0, ' + newexpr + ');\n' :
	listkind == 'normal' ? '$$ = new java.util.@ArrayList();\n${left()}.add(' + newexpr + ');\n' :
	null
}

${query codeToPassData for ast.AstPassDataRule =
	index = data ? rule.getRight().indexOf(data) : -1,
	index > 0
		? '$$ = $' + index + ';\n'
		: null
}

${query codeForOptional for ast.AstOptionalRule =
	requiresTrue
		? '$$ = Boolean.TRUE;\n'
		: null
}

${cached query astcode(rule) =
	astRule = rule->ast.astRule(),
	!astRule ? null :
	astRule.kind == 'enum' ? astRule->codeForEnum() :
	astRule.kind == 'optional' ? astRule->codeForOptional() :
 	astRule.kind == 'list' ? astRule->codeForList() :
	astRule.kind == 'class' ? astRule->codeForClass() :
	astRule.kind == 'pass' ? astRule->codeToPassData() :
	null
}

${query astPackage() = context->java.package() + (context.opts.astsubpackage ? '.' + context.opts.astsubpackage : '')}

${query astPath() = context.opts.astsubpackage ? context.opts.astsubpackage.replaceAll('\\.','/') + '/' : ''}

${query astSource() = 'null /* input */'}
