${template unit-}
${call java.header-}
package ${call java.package};

public ${if opts.lexerInput == 'custom'}abstract ${end}class ${opts.prefix}Lexer {

${call innerDeclarations-}

	public static final int TOKEN_SIZE = ${opts.maxtoken};

	private java.io.@Reader stream;
	final private ErrorReporter reporter;

${if opts.lexerInput == 'buffered'-}
	final private char[] data = new char[2048];
	private int datalen, l, tokenStart;
${end-}
	private char chr;

	private int group;

	final private StringBuilder token = new StringBuilder(TOKEN_SIZE);

	private int tokenLine = 1;
	private int currLine = 1;
${if opts.positions.contains('column') || opts.endpositions.contains('column')-}
	private int currColumn = 1;
${end-}
${if opts.positions.contains('offset') || opts.endpositions.contains('offset')-}
	private int currOffset = 0;
${end-}
${util.shiftRight(self->lexercode(), 1)-}

	public ${opts.prefix}Lexer(${if opts.lexerInput != 'custom'}java.io.@Reader stream, ${end}ErrorReporter reporter) throws java.io.@IOException {
		this.reporter = reporter;
		reset(${if opts.lexerInput != 'custom'}stream${end});
	}

	public void reset(${if opts.lexerInput != 'custom'}java.io.@Reader stream${end}) throws java.io.@IOException {
${if opts.lexerInput != 'custom'-}
		this.stream = stream;
${end-}
		this.group = 0;
${if opts.lexerInput == 'buffered'-}
		datalen = stream.read(data);
		l = tokenStart = 0;
		chr = l < datalen ? data[l++] : 0;
${else if opts.lexerInput == 'char'-}
		int c = stream.read();
		if(c == -1) {
			c = 0;
		}
		chr = (char) c;
${else if opts.lexerInput == 'custom'-}
		chr = nextChar();
${end-}
	}

${if opts.lexerInput == 'char'-}
	protected void advance() throws java.io.@IOException {
		if (chr == 0) return;
		token.append(chr);
		int c = stream.read();
		if(c == -1) {
			c = 0;
		}
		chr = (char) c;
	}

${else if opts.lexerInput == 'custom'-}
	protected abstract char nextChar() throws java.io.@IOException;

	protected void advance() throws java.io.@IOException {
		if (chr == 0) return;
		token.append(chr);
		chr = nextChar();
	}

${else if opts.lexerInput == 'buffered'-}
	protected void advance() throws java.io.@IOException {
		if (l >= datalen) {
			if (tokenStart >= 0) {
				token.append(data, tokenStart, l - tokenStart);
				tokenStart = 0;
			}
			datalen = stream.read(data);
			l = 0;
		}
		chr = l < datalen ? data[l++] : 0;
	}

${end-}
	public int getState() {
		return group;
	}

	public void setState(int state) {
		this.group = state;
	}

	public int getTokenLine() {
		return tokenLine;
	}

	public int getLine() {
		return currLine;
	}

	public void setLine(int currLine) {
		this.currLine = currLine;
	}

${if opts.positions.contains('column') || opts.endpositions.contains('column')-}
	public int getColumn() {
		return currColumn;
	}

	public void setColumn(int currColumn) {
		this.currColumn = currColumn;
	}

${end-}
${if opts.positions.contains('offset') || opts.endpositions.contains('offset')-}
	public int getOffset() {
		return currOffset;
	}

	public void setOffset(int currOffset) {
		this.currOffset = currOffset;
	}

${end-}
	public String current() {
		return token.toString();
	}

${self->lexerTables()-}

	private static int mapCharacter(int chr) {
		if (chr >= 0 && chr < ${lex.char2no.length}) {
			return lapg_char2no[chr];
		}
		return 1;
	}

	public LapgSymbol next() throws java.io.@IOException {
		LapgSymbol lapg_n = new LapgSymbol();
		int state;

		do {
${if opts.positions.contains('offset')-}
			lapg_n.offset = currOffset;
${end-}
			tokenLine =${if opts.positions.contains('line')} lapg_n.line =${end} currLine;
${if opts.positions.contains('column')-}
			lapg_n.column = currColumn;
${end-}
			if (token.length() > TOKEN_SIZE) {
				token.setLength(TOKEN_SIZE);
				token.trimToSize();
			}
			token.setLength(0);
${if opts.lexerInput == 'buffered'-}
			tokenStart = l - 1;
${end-}

			for (state = group; state >= 0;) {
				state = lapg_lexem[state][mapCharacter(chr)];
				if (state == -1 && chr == 0) {
${if opts.endpositions.contains('offset')-}
					lapg_n.endoffset = currOffset;
${end-}
${if opts.endpositions.contains('line')-}
					lapg_n.endline = currLine;
${end-}
${if opts.endpositions.contains('column')-}
					lapg_n.endcolumn = currColumn;
${end-}
					lapg_n.lexem = 0;
					lapg_n.sym = null;
					reporter.error(${call java.err_location('lapg_n', 'this') }"Unexpected end of input reached");
${if opts.lexerInput == 'buffered'-}
					tokenStart = -1;
${end-}
					return lapg_n;
				}
				if (state >= -1 && chr != 0) {
${if opts.positions.contains('offset') || opts.endpositions.contains('offset')-}
					currOffset++;
${end-}
${if opts.positions.contains('column') || opts.endpositions.contains('column')-}
					currColumn++;
${end-}
					if (chr == '\n') {
${if opts.positions.contains('column') || opts.endpositions.contains('column')-}
						currColumn = 1;
${end-}
						currLine++;
					}
${if opts.lexerInput == 'buffered'-}
					if (l >= datalen) {
						token.append(data, tokenStart, l - tokenStart);
						datalen = stream.read(data);
						tokenStart = l = 0;
					}
					chr = l < datalen ? data[l++] : 0;
${else-}
					advance();
${end-}
				}
			}
${if opts.endpositions.contains('offset')-}
			lapg_n.endoffset = currOffset;
${end-}
${if opts.endpositions.contains('line')-}
			lapg_n.endline = currLine;
${end-}
${if opts.endpositions.contains('column')-}
			lapg_n.endcolumn = currColumn;
${end-}

			if (state == -1) {
${if opts.lexerInput == 'buffered'-}
				if (l - 1 > tokenStart) {
					token.append(data, tokenStart, l - 1 - tokenStart);
				}
${end-}
				reporter.error(${call java.err_location('lapg_n', 'this') }java.text.@MessageFormat.format("invalid lexem at line {0}: `{1}`, skipped", currLine, current()));
				lapg_n.lexem = -1;
				continue;
			}

			if (state == -2) {
				lapg_n.lexem = 0;
				lapg_n.sym = null;
${if opts.lexerInput == 'buffered'-}
				tokenStart = -1;
${end-}
				return lapg_n;
			}

${if opts.lexerInput == 'buffered'-}
			if (l - 1 > tokenStart) {
				token.append(data, tokenStart, l - 1 - tokenStart);
			}

${end-}
			lapg_n.lexem = lapg_lexemnum[-state - 3];
			lapg_n.sym = null;

		} while (lapg_n.lexem == -1 || !createToken(lapg_n, -state - 3));
${if opts.lexerInput == 'buffered'-}
		tokenStart = -1;
${end-}
		return lapg_n;
	}

	protected boolean createToken(LapgSymbol lapg_n, int lexemIndex) throws java.io.@IOException {
${if self->hasLexemActions()-}
		switch (lexemIndex) {
${foreach lexem in syntax.lexems-}
${if lexem.kindAsText == 'class'-}
			case ${lexem.index}:
				return create${lexem->classLexemName()}Token(lapg_n, lexemIndex);
${else if lexem.action && !lexem.classLexem-}
			case ${lexem.index}:
				${call lexerAction('lapg_n.sym') for lexem-}
${end-}
${end-}
		}
${end-}
		return true;
	}
${foreach lexem in self->classLexems()-}
${if lexem->classHasInstances()-}

	private static java.util.@Map<String,Integer> subTokensOf${lexem->classLexemName()} = new java.util.@HashMap<String,Integer>();
	static {
${foreach instance in lexem->classInstances()-}
		subTokensOf${lexem->classLexemName()}.put("${util.escape(instance.parsedRegexp.constantValue)}", ${instance.index});
${end-}
	}
${end-}

	protected boolean create${lexem->classLexemName()}Token(LapgSymbol lapg_n, int lexemIndex) {
${if lexem->classHasInstances()-}
		Integer replacement = subTokensOf${lexem->classLexemName()}.get(current());
		if(replacement != null) {
			lexemIndex = replacement;
			lapg_n.lexem = lapg_lexemnum[lexemIndex];
		}
${end-}
${if lexem->classInstances().exists(x|x.action) || lexem.action-}
		switch(lexemIndex) {
${foreach instance in lexem->classInstances().select(x|x.action)-}
			case ${instance.index}:	// ${instance.parsedRegexp.constantValue}
				${call lexerAction('lapg_n.sym') for instance-}
${end-}
${if lexem.action-}
${foreach instance in lexem->classInstances().select(x|!x.action && x.kindAsText == 'soft')-}
			case ${instance.index}:	// ${instance.parsedRegexp.constantValue} (soft)
${end-}
			case ${lexem.index}:	// <default>
				${call lexerAction('lapg_n.sym') for lexem-}
${end-}
		}
${end-}
		return true;
	}
${end-}
}
${end}


${template lexerAction(lexem)-}
${eval action}
${end}


${template lexerTables-}
${call java.parserTable(lex.char2no, 'short', 'lapg_char2no', 'LapgCharMap')-}

${call java.parserTable(lex.lnum, 'short', 'lapg_lexemnum', 'LapgLexemToSymbol')-}

${if !opts.packLexems-}
	private static final short[][] lapg_lexem = new short[][] {
		${util.format(lex.change, 2, '{', '}')}
	};
${else-}
	private int lapg_lexem[][] = unpackFromString(${util.packIntInt(lex.change, 2)});

${call java_pack.unpackIntInt-}		
${end-}
${end}


${template innerDeclarations-}
	public static class LapgSymbol {
		public Object sym;
		public int lexem;
		public int state;
${if opts.positions.contains('line')-}
		public int line;
${end-}
${if opts.positions.contains('column')-}
		public int column;
${end-}
${if opts.positions.contains('offset')-}
		public int offset;
${end-}
${if opts.endpositions.contains('line')-}
		public int endline;
${end-}
${if opts.endpositions.contains('column')-}
		public int endcolumn;
${end-}
${if opts.endpositions.contains('offset')-}
		public int endoffset;
${end-}
	}

	public interface Lexems {
${for i in [0, syntax.terminals - 1]-}
		public static final int ${syntax.symbols[i].id->java.escapeJavaReserved()} = ${i};
${end-}
	}

	public interface ErrorReporter {
		void error(${call java.err_parameters()}String s);
	}
${end}

${template lexercode-}
${end}

${cached query hasLexemActions() =
	syntax.lexems.exists(l|l.action || l.kindAsText == 'class')}

${cached query classLexems() = syntax.lexems.select(x|x.kindAsText == 'class')}

${cached query classHasInstances() = self->classInstances().size() > 0 }

${cached query classInstances() = context.syntax.lexems.select(x|x.classLexem && x.classLexem == self)}

${cached query classLexemName() = util.uniqueId(util.toFirstUpper(self.symbol.id), '__classlexem__')}