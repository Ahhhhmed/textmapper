${template main-}
${if parser-}
${file opts.prefix+'Parser.java'}${call unit}${end-}
${end-}
${file opts.prefix+'Lexer.java'}${call java_lexer.unit}${end-}
${if opts.gentree-}
${file opts.prefix+'Tree.java'}${call java_tree.unit}${end-}
${end-}
${if opts.genast-}
${call java_ast.unit-}
${end-}
${end}

${template options-}
${call java_options.options-}
${end}

${template unit-}
${call header-}
package ${call package};

${call imports-}
import ${call package}.${opts.prefix}Lexer.${self->symbolClassName()};

public class ${opts.prefix}Parser {

${call parseException-}

	private final ${call package}.${opts.prefix}Lexer.@ErrorReporter reporter;

${call parserCtor-}

${util.shiftRight(self->classcode(), 1)-}
${call parserTables-}
	protected final int lapg_next(int state) ${if self->lazyNext()}throws java.io.@IOException ${end}{
${if self->needActionsTable()-}
		int p;
		if (lapg_action[state] < -2) {
${if self->lazyNext()-}
			if (lapg_n == null) {
				lapg_n = lapg_lexer.next();
			}
${end-}
			for (p = -lapg_action[state] - 3; lapg_lalr[p] >= 0; p += 2) {
				if (lapg_lalr[p] == lapg_n.lexem) {
					break;
				}
			}
			return lapg_lalr[p + 1];
		}
${end-}
		return lapg_action[state];
	}

	protected final int lapg_state_sym(int state, int symbol) {
		int min = lapg_sym_goto[symbol], max = lapg_sym_goto[symbol + 1] - 1;
		int i, e;

		while (min <= max) {
			e = (min + max) >> 1;
			i = lapg_sym_from[e];
			if (i == state) {
				return lapg_sym_to[e];
			} else if (i < state) {
				min = e + 1;
			} else {
				max = e - 1;
			}
		}
		return -1;
	}

	protected int lapg_head;
	protected ${self->symbolClassName()}[] lapg_m;
	protected ${self->symbolClassName()} lapg_n;
	protected ${opts.prefix}Lexer lapg_lexer;

	${self->mainParseVisibility()} ${self->mainParseReturnType()} parse(${opts.prefix}Lexer lexer${if self->needInitialState()
		}, int initialState${end}${if self->needFinalState()}, int finalState${end
		}${if self->hasNoEoiInputs() && self->hasEoiInputs()}, boolean noEoi${end}) throws java.io.@IOException, ParseException {

		lapg_lexer = lexer;
		lapg_m = new ${self->symbolClassName()}[${opts.stack}];
		lapg_head = 0;
${if self->hasRecovering()}		int lapg_symbols_ok = 4;
${end-}

		lapg_m[0] = new ${self->symbolClassName()}();
		lapg_m[0].state = ${self->needInitialState() ? 'initialState' : 0};
		lapg_n = lapg_lexer.next();

		while (lapg_m[lapg_head].state != ${self->needFinalState() ? 'finalState' : parser.statesCount-1}) {
			int lapg_i = lapg_next(lapg_m[lapg_head].state);

			if (lapg_i >= 0) {
				reduce(lapg_i);
			} else if (lapg_i == -1) {
				shift(${if self->hasNoEoiInputs() && self->hasEoiInputs()}noEoi${end});
${if self->hasRecovering()}				lapg_symbols_ok++;
${end-}
			}

			if (lapg_i == -2 || lapg_m[lapg_head].state == -1) {
${if self->hasRecovering()-}
${call dynamicRecoveringCheck-}
				if (restore()) {
					if (lapg_symbols_ok >= 4) {
						reporter.error(${self->err_location('lapg_n', 'lapg_lexer').trim()}
								java.text.@MessageFormat.format("syntax error before line {0}${if opts.positions.contains('column')}, column {1}",
								lapg_lexer.getTokenLine(), lapg_n.column)${else}", lapg_lexer.getTokenLine())${end});
					}
					if (lapg_symbols_ok <= 1) {
						lapg_n = lapg_lexer.next();
					}
					lapg_symbols_ok = 0;
					continue;
				}
				if (lapg_head < 0) {
					lapg_head = 0;
					lapg_m[0] = new ${self->symbolClassName()}();
					lapg_m[0].state = ${self->needInitialState() ? 'initialState' : 0};
				}
${end-}
				break;
			}
		}

		if (lapg_m[lapg_head].state != ${self->needFinalState() ? 'finalState' : parser.statesCount-1}) {
${if self->hasRecovering()-}
			if (lapg_symbols_ok >= 4) {
	${else-}
${end}			reporter.error(${(self->lazyNext() ? self->err_location_safe('lapg_n', 'lapg_lexer') : self->err_location('lapg_n', 'lapg_lexer')).trim()}
						java.text.@MessageFormat.format("syntax error before line {0}${if opts.positions.contains('column')}, column {1}${end}",
								lapg_lexer.getTokenLine()${if opts.positions.contains('column')}, ${if self->lazyNext()}lapg_n == null ? lapg_lexer.getColumn() : ${end}lapg_n.column${end}));
${if self->hasRecovering()-}
			}
${end-}
			throw new ParseException();
		}
		return ${if !self->needInitialState() && syntax.input.first().target->type()}(${syntax.input.first().target->type()})${end
			}lapg_m[${
				self->hasNoEoiInputs() && self->hasEoiInputs()
					? 'noEoi ? lapg_head : lapg_head - 1' :
				self->hasNoEoiInputs()
				 	? 'lapg_head'
				 	: 'lapg_head - 1'
			}].sym;
	}
${if self->hasRecovering()}
	protected boolean restore() ${if self->lazyNext()}throws java.io.@IOException ${end}{
${if self->lazyNext()-}
		if (lapg_n == null) {
			lapg_n = lapg_lexer.next();
		}
${end-}
		if (lapg_n.lexem == 0) {
			return false;
		}
		while (lapg_head >= 0 && lapg_state_sym(lapg_m[lapg_head].state, ${self->errorLexem()}) == -1) {
			dispose(lapg_m[lapg_head]);
			lapg_m[lapg_head] = null;
			lapg_head--;
		}
		if (lapg_head >= 0) {
			lapg_m[++lapg_head] = new ${self->symbolClassName()}();
			lapg_m[lapg_head].lexem = ${self->errorLexem()};
			lapg_m[lapg_head].sym = null;
			lapg_m[lapg_head].state = lapg_state_sym(lapg_m[lapg_head - 1].state, ${self->errorLexem()});
${if opts.positions.contains('line')-}
			lapg_m[lapg_head].line = lapg_n.line;
${end-}
${if opts.positions.contains('column')-}
			lapg_m[lapg_head].column = lapg_n.column;
${end-}
${if opts.positions.contains('offset')-}
			lapg_m[lapg_head].offset = lapg_n.offset;
${end-}
${if opts.endpositions.contains('line')-}
			lapg_m[lapg_head].endline = lapg_n.endline;
${end-}
${if opts.endpositions.contains('column')-}
			lapg_m[lapg_head].endcolumn = lapg_n.endcolumn;
${end-}
${if opts.endpositions.contains('offset')-}
			lapg_m[lapg_head].endoffset = lapg_n.endoffset;
${end-}
			return true;
		}
		return false;
	}
${end-}

	protected void shift(${if self->hasNoEoiInputs() && self->hasEoiInputs()}boolean lazy${end}) throws java.io.@IOException {
${if self->lazyNext()-}
		if (lapg_n == null) {
			lapg_n = lapg_lexer.next();
		}
${end-}
		lapg_m[++lapg_head] = lapg_n;
		lapg_m[lapg_head].state = lapg_state_sym(lapg_m[lapg_head - 1].state, lapg_n.lexem);
${call debugShift-}
		if (lapg_m[lapg_head].state != -1 && lapg_n.lexem != 0) {
			lapg_n = ${
				self->hasNoEoiInputs() && self->hasEoiInputs()
					? 'lazy ? null : lapg_lexer.next()' :
				self->hasNoEoiInputs()
				 	? 'null'
				 	: 'lapg_lexer.next()'
			};
		}
	}

	protected void reduce(int rule) {
		${self->symbolClassName()} lapg_gg = new ${self->symbolClassName()}();
		lapg_gg.sym = (lapg_rlen[rule] != 0) ? lapg_m[lapg_head + 1 - lapg_rlen[rule]].sym : null;
		lapg_gg.lexem = lapg_rlex[rule];
		lapg_gg.state = 0;
${call debugReduce-}
${if opts.positions.contains('line') || opts.positions.contains('offset') || opts.positions.contains('column')-}
		${self->symbolClassName()} startsym = (lapg_rlen[rule] != 0) ? lapg_m[lapg_head + 1 - lapg_rlen[rule]] : lapg_n;
${if opts.positions.contains('line')-}
		lapg_gg.line = ${if self->lazyNext()}startsym == null ? lapg_lexer.getLine() : ${end}startsym.line;
${end-}
${if opts.positions.contains('column')-}
		lapg_gg.column = ${if self->lazyNext()}startsym == null ? lapg_lexer.getColumn() : ${end}startsym.column;
${end-}
${if opts.positions.contains('offset')-}
		lapg_gg.offset = ${if self->lazyNext()}startsym == null ? lapg_lexer.getOffset() : ${end}startsym.offset;
${end-}
${end-}
${if opts.endpositions.contains('line')-}
		lapg_gg.endline = (lapg_rlen[rule] != 0) ? lapg_m[lapg_head].endline : ${if self->lazyNext()}lapg_n == null ? lapg_lexer.getLine() : ${end}lapg_n.line;
${end-}
${if opts.endpositions.contains('column')-}
		lapg_gg.endcolumn = (lapg_rlen[rule] != 0) ? lapg_m[lapg_head].endcolumn : ${if self->lazyNext()}lapg_n == null ? lapg_lexer.getColumn() : ${end}lapg_n.column;
${end-}
${if opts.endpositions.contains('offset')-}
		lapg_gg.endoffset = (lapg_rlen[rule] != 0) ? lapg_m[lapg_head].endoffset : ${if self->lazyNext()}lapg_n == null ? lapg_lexer.getOffset() : ${end}lapg_n.offset;
${end-}
		applyRule(lapg_gg, rule, lapg_rlen[rule]);
		for (int e = lapg_rlen[rule]; e > 0; e--) {
${if opts.genCleanup-}
			cleanup(lapg_m[lapg_head]);
${end-}
			lapg_m[lapg_head--] = null;
		}
		lapg_m[++lapg_head] = lapg_gg;
		lapg_m[lapg_head].state = lapg_state_sym(lapg_m[lapg_head - 1].state, lapg_gg.lexem);
	}

${call applyRule-}
${if self->hasRecovering()}
	/**
	 * disposes symbol dropped by error recovery mechanism
	 */
	protected void dispose(${self->symbolClassName()} sym) {
	}
${end-}
${if opts.genCleanup}
	/**
	 * cleans node removed from the stack
	 */
	protected void cleanup(${self->symbolClassName()} sym) {
	}
${end-}
${if self->needFinalState()-}
${call customParseRoutines-}
${end-}
}
${end}


${template parserCtor-}
	public ${opts.prefix}Parser(${call package}.${opts.prefix}Lexer.@ErrorReporter reporter) {
		this.reporter = reporter;
	}
${end}

${template applyRule-}
	@SuppressWarnings("unchecked")
	protected void applyRule(${self->symbolClassName()} lapg_gg, int rule, int ruleLength) {
${if syntax.rules.exists(r|r.getAction()) || opts.genast -}
		switch (rule) {
${foreach rule in syntax.rules-}
${if rule.getAction() || opts.genast && self->java_ast.astcode(rule)-}
			case ${rule.getIndex()}:  // ${rule}
${if rule.getAction()-}
				${call parserAction for rule-}
${if opts.breaks }				break;$/
${else-}
${util.shiftRight(rule->astAction(self->java_ast.astcode(rule)), 4)-}
				break;
${end-}
${end-}
${end-}
		}
${end-}
	}
${end}

${template customParseRoutines-}
${foreach inp in syntax.input}
	public ${if inp.target->type()}${inp.target->type()}${else}Object${end} parse${util.toFirstUpper(inp.target.id)}(${opts.prefix}Lexer lexer) throws java.io.@IOException, ParseException {
		return ${if inp.target->type()}(${inp.target->type()}) ${end}parse(lexer${if self->needInitialState()}, ${index}${end}, ${parser.finalStates[index]}${if self->hasNoEoiInputs() && self->hasEoiInputs()
				}, ${inp.hasEoi() ? 'false' : 'true'}${end});
	}
${end-}
${end}

${template debugShift-}
		if (DEBUG_SYNTAX) {
			System.out.println(java.text.@MessageFormat.format("shift: {0} ({1})", lapg_syms[lapg_n.lexem], lapg_lexer.current()));
		}
${end}

${template debugReduce-}
		if (DEBUG_SYNTAX) {
			System.out.println("reduce to " + lapg_syms[lapg_rlex[rule]]);
		}
${end}

${query needActionsTable() = parser.lalr.size() > 0}

${template parserTables-}
	private static final int[] lapg_action = ${opts.prefix}Lexer.${parser.action->java_pack.packInt()};

${if self->needActionsTable()-}
	private static final short[] lapg_lalr = ${opts.prefix}Lexer.${parser.lalr->java_pack.packShort()};

${end-}
	private static final short[] lapg_sym_goto = ${opts.prefix}Lexer.${parser.symGoto->java_pack.packShort()};

	private static final short[] lapg_sym_from = ${opts.prefix}Lexer.${parser.symFrom->java_pack.packShort()};

	private static final short[] lapg_sym_to = ${opts.prefix}Lexer.${parser.symTo->java_pack.packShort()};

	private static final short[] lapg_rlen = ${opts.prefix}Lexer.${parser.ruleLength->java_pack.packShort()};

	private static final short[] lapg_rlex = ${opts.prefix}Lexer.${parser.left->java_pack.packShort()};

	protected static final String[] lapg_syms = new String[] {
${foreach s in parser.symbols-}
		"${s.name}",
${end-}
	};

	public interface Tokens extends ${call package}.${opts.prefix}Lexer.@Lexems {
		// non-terminals
${for i in [parser.nterms, parser.nsyms-1]-}
		public static final int ${parser.symbols[i].id->escapeJavaReserved()} = ${i};
${end-}
	}
${if syntax.rules.exists(x|x.getAlias())}
	public interface Rules {
${foreach rule in syntax.rules-}
${if rule.getAlias()-}
		public static final int ${util.uniqueId(rule.getLeft().id + '_' + rule.getAlias(), '__rules__')} = ${rule.getIndex()};  // ${rule}
${end-}
${end-}
	}
${end-}

${end}


${template parserAction-}
${eval getAction()}
${end}

${template astAction(code)-}
${eval code, '#[generated action for '+self+']'-}
${end}

${query symText(property) =
	(self.isLeft ? 'lapg_gg' : 'lapg_m[lapg_head' + (self.rightOffset > 0 ? ' - ' + self.rightOffset : '') + ']')
	  + '.' + property }

${template symAccess(property)-}
${assert ['sym', 'line', 'column', 'offset', 'endline', 'endcolumn', 'endoffset'].contains(property)-}
${if property == 'sym'-}
${symbol->type() ? '((' + symbol->type() + ')' + self->symText(property) + ')' : self->symText(property) -}
${else-}
${self->symText(property)-}
${end-}
${end}

${template err_location(symvar,lexervar)-}
${if opts.positions.contains('offset')}${symvar}.offset, ${end-}
${if opts.endpositions.contains('offset')}${symvar}.endoffset, ${end-}
${if opts.positions.contains('line')}${symvar}.line${else}${lexervar}.getTokenLine()${end}, ${end}

${template err_location_safe(symvar,lexervar)-}
${if opts.positions.contains('offset')}${symvar} == null ? ${lexervar}.getOffset() : ${symvar}.offset, ${end-}
${if opts.endpositions.contains('offset')}${symvar} == null ? ${lexervar}.getOffset() : ${symvar}.endoffset, ${end-}
${symvar} == null ? ${lexervar}.getLine() : ${if opts.positions.contains('line')}${symvar}.line${else}${lexervar}.getTokenLine()${end}, ${end}

${template err_parameters()-}
${if opts.positions.contains('offset')}int start, ${end-}
${if opts.endpositions.contains('offset')}int end, ${end-}
int line, ${end}

${template imports-}
${end}

${template classcode-}
private static final boolean DEBUG_SYNTAX = false;
${end}

${template parseException-}
	public static class ParseException extends Exception {
		private static final long serialVersionUID = 1L;

		public ParseException() {
		}
	}
${end}

${query package() = opts.package ? opts.package : 'com.test' }

${cached query hasRecovering() = syntax.error}
${cached query errorLexem() = syntax.error.index}

${template dynamicRecoveringCheck-}
${end}

${query mainParseVisibility() = self->needFinalState() ? 'private' : 'public'}
${query mainParseReturnType() = !self->needFinalState() && syntax.input.first().target->type() ? syntax.input.first().target->type() : 'Object'}

${cached query needInitialState() = syntax.input.length > 1}
${cached query needFinalState() = self->needInitialState() || !syntax.input[0].hasEoi() && parser.finalStates[0] != parser.statesCount - 1 }

${cached query hasNoEoiInputs() = syntax.input.exists(x|!x.hasEoi()) }
${cached query hasEoiInputs() = syntax.input.exists(x|x.hasEoi()) }

${cached query lazyNext() = self->hasNoEoiInputs() }

${cached query type() = context.opts.genast ? context->java_ast.getType(self) : self.type }


${query escapeJavaReserved() =
	[
		'String', 'Integer', 'Long', 'Boolean', 'LinkedHashMap', 'HashMap', 'Map',
		'List', 'ArrayList', 'LinkedList', 'TextSource',

		'abstract', 'assert', 'boolean', 'break', 'byte', 'case', 'catch', 'char', 'class', 'continue', 'const',
		'default', 'do', 'double', 'else', 'enum', 'extends', 'false', 'final', 'finally', 'float', 'for',
		'goto', 'if', 'implements', 'import', 'instanceof', 'int', 'interface', 'long', 'native', 'new',
		'null', 'package', 'private', 'protected', 'public', 'return', 'short', 'static', 'strictfp',
		'super', 'switch', 'synchronized', 'this', 'throw', 'throws', 'transient', 'true', 'try', 'void',
		'volatile', 'while'
	].contains(self) ? '_' + self : self }


${template header-}
${if opts.genCopyright && syntax.copyrightHeader-}
/**
${foreach line in util.shiftRightWithSpaces(syntax.copyrightHeader, 1).split('\n')-}
 *${line}
${end-}
 */
${end-}
${end}

${query symbolClassName() = 'LapgSymbol'}
