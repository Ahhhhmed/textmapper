${cached query astModel() =
	new AstModel(
        classes => self->allClasses()
	)
}

${cached query allClasses() =
	syntax.symbols.select(x|!x.isTerm() && !self->isOptional(x))
	.collect(x|self->getClasses(x)) }

${cached query getClasses(sym) =
	kind = self->symbolKind(sym),
	kind == 'enum' ?
		new AstEnum(
			kind => 'enum',
			name => sym.id,
			sym => sym,
			literals => syntax.rules[sym].collect(rule|rule.getRight().first())
		) :
	kind == 'interface' ?
		new AstInterface(
			kind => 'interface',
			name => sym.id,
			sym => sym,
			implementedSyms => self->getImplements(sym),
			implements => {this => this.implementedSyms.collect(x|self->getClasses(x)) }
		) :
	kind == 'class' ?
		new AstClass(
			kind => 'class',
			name => sym.id,
			sym => sym,
			implementedSyms => self->getImplements(sym),
			implements => {this => this.implementedSyms.collect(x|self->getClasses(x)) },
			containedRefs => syntax.rules[sym].collect(x|[
				x.getRight()
			]),
			properties => { cached this => self->propertiesInternal(this) }
		) :
	(kind == 'leftlist' || kind == 'rightlist') && self->hasItemClass(sym) ?
		new AstClass(
			kind => 'class',
			name => sym.id + '_item',
			sym => sym,
			implements => { this => [] },
			containedRefs => syntax.rules[sym].collect(x|[
				x.getRight().select(y|y.target != x.getLeft())
			]),
			properties => { cached this => self->propertiesInternal(this) }
		) :
	null }

${query getPropertyKind() =
	self.size() > 1 && self.forAll(x|x.target->isSimpleTerm())
		? ( self.collectUnique(x|x.target).size() == 1
			? 'flagproperty'
			: 'enumproperty') :
	self.size() == 1 && self.first().target->isSimpleTerm()
		? 'flagproperty' :
	'property'}

${cached query propertiesInternal(cl) =
	withAlias = cl.containedRefs.collect(x|x.select(y|y.alias)).groupBy(x|x.alias).collect(x|
		allrefs = (x is GroupList ? x : [x]),
		new AstProperty(
			kind => allrefs->getPropertyKind(),
			name => util.uniqueId(x is GroupList ? x.first().alias : x.alias, 'prop#' + cl.name),
			container => cl,
			refs => allrefs.toSet(),
			indexInRule => { this,rule => self->propertyIndex(this, rule, this.container) }
		)
	),
	withoutAlias = cl.containedRefs.collect(rule|
				rule.select(x|!x.alias && !x.target->isSimpleTerm()).groupBy(x|x.target).collect(x|
					x is GroupList
					? x.collect(y|[ name: util.uniqueId(y.target.id, util.objectId(rule)), ref: y ])
								: [ name : x.target.id, ref: x ])
		).groupBy(x|x.name).collect(x|
			allrefs = (x is GroupList ? x.collect(y|y.ref) : [x.ref]),
			new AstProperty(
				kind => 'property',
				name => util.uniqueId(x is GroupList ? x.first().name : x.name, 'prop#' + cl.name),
				container => cl,
				refs => allrefs.toSet(),
				type => self->getType(allrefs.first().target),
				indexInRule => { this,rule => self->propertyIndex(this, rule, this.container) }
			)),
	withAlias.union(withoutAlias)
}

${cached query propertyIndex(prop,rule,cl) =
		list = rule.getRight().select(x|prop.refs.contains(x)),
		list.first() ? rule.getRight().indexOf(list.first()) : -1 }


${cached query symbolKind(sym) =
	self->isEnum(sym) ? 'enum' :
	self->isLeftList(sym) ? 'leftlist' :
	self->isRightList(sym) ? 'rightlist' :
	self->isData(sym) ? 'data' :
	self->isInterface(sym) ? 'interface' : 'class'}

${query isSimpleTerm() = self.isTerm() && !self.type}

${cached query isEnum(sym) = syntax.rules[sym].
	forAll(x|x.getRight().length == 1 && x.getRight().first().target->isSimpleTerm())}

${cached query isInterface(sym) = syntax.rules[sym].
	forAll(x|x.getRight().length == 1 
					&& self->supportsExtending(x.getRight().first().target)
		  || (
		   		nonterm = x->getRuleDataRef(),
		   		nonterm && self->supportsExtending(nonterm.target)
		   	 )
	)}

${cached query getRuleDataRef() =
	self.getRight().length > 1 ? (
		nonterm = self.getRight().select(y|!y.target->isSimpleTerm()),
		nonterm.size() == 1 && nonterm.first()['pass'] ? nonterm.first() : null
	) : null }

${cached query isData(sym) = syntax.rules[sym].length == 1 &&
	syntax.rules[sym].first()->getRuleDataRef() ? true : false }

${query supportsExtending(sym) = 
	!sym.isTerm() &&
	!self->isEnum(sym) &&
	!self->isList(sym) &&
	!self->isData(sym) &&
	(!self->isOptional(sym) || self->supportsExtending(self->getOptionalTarget(sym)))}

${cached query getImplements(sym) = syntax.rules.with(sym).select(x|
				self->symbolKind(x.getLeft()) == 'interface' || 
				self->isOptional(x.getLeft()) && x.getRight().first().target == sym
			).collectUnique(x|self->isOptional(x.getLeft()) ? self->getImplements(x.getLeft()) : x.getLeft())}

${cached query isOptional(sym) = syntax.rules[sym].size() == 2 &&
	syntax.rules[sym].collect(x|x.getRight().length)->containsBothOnly(0,1)}
	
${cached query getOptionalTarget(sym) = syntax.rules[sym].collect(x|x.getRight()).first().target}

${cached query isList(sym) = self->isLeftList(sym) || self->isRightList(sym)} 

${cached query isLeftList(sym) = syntax.rules[sym].
	collect(x|self->intListRuleKind(x))->containsBothOnly('leftrec', 'normal')}

${cached query isRightList(sym) = syntax.rules[sym].
	collect(x|self->intListRuleKind(x))->containsBothOnly('rightrec', 'normal')}

${query containsBothOnly(x,y) = 
	self.contains(x) && self.contains(y) && self.forAll(q|q==x || q==y)}

${cached query intListRuleKind(rule) = 
	rule.getRight().length == 0 
		? 'empty'
		: (rule.getRight().select(x|x.target == rule.getLeft()).size() == 1
			? (rule.getRight().first().target == rule.getLeft() 
				? 'leftrec'
				: (rule.getRight().last().target == rule.getLeft()
					? 'rightrec'
					: 'unknown'
				  )
			  )
			: (rule.getRight().select(x|x.target == rule.getLeft()).size() == 0
				? 'normal'
				: 'unknown'
			  )	
		  )
}

${cached query getListItems(sym) = syntax.rules[sym].collect(x|x.getRight()).collectUnique(x|x.target).reject(x|x == sym || x->isSimpleTerm())}

${query hasItemClass(sym) = self->getListItems(sym).length > 1}

${query hasListItem(sym) = self->getListItems(sym).length == 1}

${query getListItem(sym) = self->getListItems(sym).first()}


${cached query getType(sym) =
 	sym.type ? new AstUserType(text => sym.type) :
 	sym.isTerm() ? new AstBool() :
 	self->isOptional(sym) ? self->getOptionalType(sym) :
 	self->isList(sym) ? new AstList(target => self->getListItemType(sym)) :
 	self->isData(sym) ? self->getType(syntax.rules[sym].first()->getRuleDataRef().target) :
 	self->getObjectType(sym) 
}

${query getOptionalType(sym) =
	target = self->getOptionalTarget(sym),
	self->getType(target)
}

${query getObjectType(sym) = 
	classes = [self->getClasses(sym)].collect(x|x),
	classes.first()
		? classes.first()
		: null
}

${query getListItemType(sym) =
	self->hasItemClass(sym) ? self->getObjectType(sym) :
	self->hasListItem(sym) ? self->getType(self->getListItem(sym)) :
	new AstObject()
}
