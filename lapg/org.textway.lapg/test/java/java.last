
// Ast


interface input {
}


class Literal {
	property integerLiteral : String;
	property floatingPointLiteral : String;
	property characterLiteral : String;
	property stringLiteral : String;
	property booleanLiteral : BooleanLiteral;
}


enum BooleanLiteral {
	BOOLTRUE,
	BOOLFALSE,
}


interface Type {
}


class PrimitiveType : Type {
	property numericType : NumericType;
}


class NumericType {
	property integralType : IntegralType;
	property floatingPointType : FloatingPointType;
}


enum IntegralType {
	BYTE,
	SHORT,
	INT,
	LONG,
	CHAR,
}


enum FloatingPointType {
	FLOAT,
	DOUBLE,
}


interface ReferenceType : Type, TypeArgument {
}


interface ClassOrInterfaceType : ReferenceType, ClassType, InterfaceType {
}


class ClassOrInterface : ClassOrInterfaceType {
	property name : Name;
	property genericType : GenericType;
}


class GenericType : ClassOrInterfaceType {
	property classOrInterface : ClassOrInterface;
	property typeArguments : TypeArguments;
}


class ArrayTypeWithTypeArgumentsName {
	property genericType : GenericType;
	property name : Name;
}


class ArrayType : ReferenceType {
	property primitiveType : PrimitiveType;
	property dims : Dims;
	property name : Name;
	property arrayTypeWithTypeArgumentsName : ArrayTypeWithTypeArgumentsName;
	property genericType : GenericType;
}


interface ClassType : ClassTypeElt {
}


interface Name : PostfixExpression, MemberValue {
}


class SimpleName : Name {
	property identifier : String;
}


class QualifiedName : Name {
	property name : Name;
	property simpleName : SimpleName;
}


interface CompilationUnit : input {
}


class InternalCompilationUnit : CompilationUnit {
	property packageDeclaration : PackageDeclaration;
	property importDeclarations : list[ImportDeclaration];
	property typeDeclarations : list[TypeDeclaration];
}


interface Header : Header1, Header2 {
}


interface Header1 {
}


interface Header2 {
}


class CatchHeader {
	property formalParameter : FormalParameter;
}


class PackageDeclaration : Header {
	property packageDeclarationName : PackageDeclarationName;
}


class PackageDeclarationName {
	property modifiers : list[Modifier];
	property name : Name;
}


interface ImportDeclaration : Header {
}


class SingleTypeImportDeclaration : ImportDeclaration {
	property singleTypeImportDeclarationName : SingleTypeImportDeclarationName;
}


class SingleTypeImportDeclarationName {
	property name : Name;
}


class TypeImportOnDemandDeclaration : ImportDeclaration {
	property typeImportOnDemandDeclarationName : TypeImportOnDemandDeclarationName;
}


class TypeImportOnDemandDeclarationName {
	property name : Name;
}


class TypeDeclaration {
	property classDeclaration : ClassDeclaration;
	property interfaceDeclaration : InterfaceDeclaration;
	property enumDeclaration : EnumDeclaration;
	property annotationTypeDeclaration : AnnotationTypeDeclaration;
}


class Modifier {
	property annotation : Annotation;
}


class ClassDeclaration : BlockStatement {
	property classHeader : ClassHeader;
	property classBody : ClassBody;
}


class ClassHeader : Header {
	property classHeaderName : ClassHeaderName;
	property classHeaderExtendsopt : ClassHeaderExtends;
	property classHeaderImplementsopt : ClassHeaderImplements;
}


class ClassHeaderName {
	property classHeaderName1 : ClassHeaderName1;
	property typeParameters : TypeParameters;
}


class ClassHeaderName1 {
	property modifiersopt : list[Modifier];
	property identifier : String;
}


class ClassHeaderExtends {
	property classType : ClassType;
}


class ClassHeaderImplements {
	property interfaceTypeList : list[InterfaceType];
}


interface InterfaceType {
}


class ClassBody {
	property classBodyDeclarationsopt : list[ClassBodyDeclaration];
}


interface ClassBodyDeclaration {
}


interface Initializer {
}


class ClassMemberDeclaration : ClassBodyDeclaration {
	property fieldDeclaration : FieldDeclaration;
	property methodDeclaration : MethodDeclaration;
	property classDeclaration : ClassDeclaration;
	property interfaceDeclaration : InterfaceDeclaration;
	property enumDeclaration : EnumDeclaration;
	property annotationTypeDeclaration : AnnotationTypeDeclaration;
}


interface GenericMethodDeclaration {
}


class FieldDeclaration : Header, ConstantDeclaration {
	property modifiersopt : list[Modifier];
	property type : Type;
	property variableDeclarators : list[VariableDeclarator];
}


class VariableDeclarator {
	property variableDeclaratorId : VariableDeclaratorId;
	property variableInitializer : VariableInitializer;
}


class VariableDeclaratorId {
	property identifier : String;
	property dimsopt : Dims;
}


interface VariableInitializer {
}


class MethodDeclaration : GenericMethodDeclaration {
	property abstractMethodDeclaration : AbstractMethodDeclaration;
	property methodHeader : MethodHeader;
	property methodBody : MethodBody;
}


class AbstractMethodDeclaration {
	property methodHeader : MethodHeader;
}


class MethodHeader {
	property methodHeaderName : MethodHeaderName;
	property formalParameterListopt : list[FormalParameter];
	property methodHeaderExtendedDims : MethodHeaderExtendedDims;
	property methodHeaderThrowsClauseopt : MethodHeaderThrowsClause;
}


class MethodHeaderName {
	property modifiersopt : list[Modifier];
	property typeParameters : TypeParameters;
	property type : Type;
	property identifier : String;
}


interface MethodHeaderExtendedDims {
}


class MethodHeaderThrowsClause {
	property classTypeList : list[ClassTypeElt];
}


class ConstructorHeader : Header1 {
	property constructorHeaderName : ConstructorHeaderName;
	property formalParameterListopt : list[FormalParameter];
	property methodHeaderThrowsClauseopt : MethodHeaderThrowsClause;
}


class ConstructorHeaderName {
	property modifiersopt : list[Modifier];
	property typeParameters : TypeParameters;
	property identifier : String;
}


class FormalParameter {
	property modifiersopt : list[Modifier];
	property type : Type;
	property variableDeclaratorId : VariableDeclaratorId;
}


interface ClassTypeElt {
}


class MethodBody {
	property blockStatementsopt : list[BlockStatement];
}


class StaticInitializer : Header, ClassBodyDeclaration {
	property staticOnly : StaticOnly;
	property block : Block;
}


enum StaticOnly {
	STATIC,
}


class ConstructorDeclaration : ClassBodyDeclaration, GenericMethodDeclaration {
	property constructorHeader : ConstructorHeader;
	property methodBody : MethodBody;
}


class ExplicitConstructorInvocation {
	property argumentListopt : list[Expression];
	property onlyTypeArguments : OnlyTypeArguments;
	property primary : Primary;
	property name : Name;
}


class InterfaceDeclaration : BlockStatement {
	property interfaceHeader : InterfaceHeader;
	property interfaceBody : InterfaceBody;
}


class InterfaceHeader : Header {
	property interfaceHeaderName : InterfaceHeaderName;
	property interfaceHeaderExtendsopt : InterfaceHeaderExtends;
}


class InterfaceHeaderName {
	property interfaceHeaderName1 : InterfaceHeaderName1;
	property typeParameters : TypeParameters;
}


class InterfaceHeaderName1 {
	property modifiersopt : list[Modifier];
	property identifier : String;
}


class InterfaceHeaderExtends {
	property interfaceTypeList : list[InterfaceType];
}


class InterfaceBody {
	property interfaceMemberDeclarationsopt : list[InterfaceMemberDeclaration];
}


class InterfaceMemberDeclaration {
	property constantDeclaration : ConstantDeclaration;
	property methodHeader : MethodHeader;
	property methodBody : MethodBody;
	property abstractMethodDeclaration : AbstractMethodDeclaration;
	property invalidConstructorDeclaration : InvalidConstructorDeclaration;
	property classDeclaration : ClassDeclaration;
	property interfaceDeclaration : InterfaceDeclaration;
	property enumDeclaration : EnumDeclaration;
	property annotationTypeDeclaration : AnnotationTypeDeclaration;
}


class InvalidConstructorDeclaration {
	property constructorHeader : ConstructorHeader;
	property methodBody : MethodBody;
}


interface ConstantDeclaration {
}


class ArrayInitializer : VariableInitializer {
	property commaopt : boolean;
	property variableInitializers : list[VariableInitializer];
}


class Block : ClassBodyDeclaration, Initializer, TryBlock {
	property blockStatementsopt : list[BlockStatement];
}


interface BlockStatement {
}


class LocalVariableDeclarationStatement : BlockStatement {
	property localVariableDeclaration : LocalVariableDeclaration;
}


class LocalVariableDeclaration {
	property type : Type;
	property variableDeclarators : list[VariableDeclarator];
	property modifiers : list[Modifier];
}


interface Statement : BlockStatement {
}


interface StatementNoShortIf {
}


class StatementWithoutTrailingSubstatement : Statement, StatementNoShortIf {
	property assertStatement : AssertStatement;
	property block : Block;
	property expressionStatement : ExpressionStatement;
	property switchStatement : SwitchStatement;
	property doStatement : DoStatement;
	property breakStatement : BreakStatement;
	property continueStatement : ContinueStatement;
	property returnStatement : ReturnStatement;
	property synchronizedStatement : SynchronizedStatement;
	property throwStatement : ThrowStatement;
	property tryStatement : TryStatement;
}


class LabeledStatement : Statement {
	property label : Label;
	property statement : Statement;
}


class LabeledStatementNoShortIf : StatementNoShortIf {
	property label : Label;
	property statementNoShortIf : StatementNoShortIf;
}


class Label {
	property identifier : String;
}


class ExpressionStatement {
	property statementExpression : StatementExpression;
	property explicitConstructorInvocation : ExplicitConstructorInvocation;
}


interface StatementExpression {
}


class IfThenStatement : Statement {
	property expression : Expression;
	property statement : Statement;
}


class IfThenElseStatement : Statement {
	property expression : Expression;
	property statementNoShortIf : StatementNoShortIf;
	property statement : Statement;
}


class IfThenElseStatementNoShortIf : StatementNoShortIf {
	property expression : Expression;
	property statementNoShortIf : StatementNoShortIf;
	property statementNoShortIf2 : StatementNoShortIf;
}


class SwitchStatement {
	property expression : Expression;
	property switchBlock : SwitchBlock;
}


class SwitchBlock {
	property switchBlockStatements : list[SwitchBlockStatement];
	property switchLabels : list[SwitchLabel];
}


class SwitchBlockStatement {
	property switchLabels : list[SwitchLabel];
	property blockStatements : list[BlockStatement];
}


class SwitchLabel {
	property constantExpression : ConstantExpression;
}


class WhileStatement : Statement {
	property expression : Expression;
	property statement : Statement;
}


class WhileStatementNoShortIf : StatementNoShortIf {
	property expression : Expression;
	property statementNoShortIf : StatementNoShortIf;
}


class DoStatement {
	property statement : Statement;
	property expression : Expression;
}


class ForStatement : Statement {
	property forInitopt : ForInit;
	property expressionopt : Expression;
	property forUpdateopt : ForUpdate;
	property statement : Statement;
}


class ForStatementNoShortIf : StatementNoShortIf {
	property forInitopt : ForInit;
	property expressionopt : Expression;
	property forUpdateopt : ForUpdate;
	property statementNoShortIf : StatementNoShortIf;
}


class ForInit {
	property statementExpressionList : list[StatementExpression];
	property localVariableDeclaration : LocalVariableDeclaration;
}


class ForUpdate {
	property statementExpressionList : list[StatementExpression];
}


class AssertStatement {
	property expression : Expression;
	property expression2 : Expression;
}


class BreakStatement {
	property identifier : String;
}


class ContinueStatement {
	property identifier : String;
}


class ReturnStatement {
	property expressionopt : Expression;
}


class ThrowStatement {
	property expression : Expression;
}


class SynchronizedStatement {
	property onlySynchronized : OnlySynchronized;
	property expression : Expression;
	property block : Block;
}


enum OnlySynchronized {
	SYNCHRONIZED,
}


class TryStatement {
	property tryBlock : TryBlock;
	property catches : list[CatchClause];
	property catchesopt : list[CatchClause];
	property finally : Finally;
}


interface TryBlock {
}


class CatchClause {
	property formalParameter : FormalParameter;
	property block : Block;
}


class Finally {
	property block : Block;
}


interface Primary : PostfixExpression, PostfixExpression_NotName {
}


class PrimaryNoNewArray : Primary {
	property literal : Literal;
	property expression_NotName : Expression_NotName;
	property name : Name;
	property classInstanceCreationExpression : ClassInstanceCreationExpression;
	property fieldAccess : FieldAccess;
	property dims : Dims;
	property primitiveType : PrimitiveType;
	property methodInvocation : MethodInvocation;
	property arrayAccess : ArrayAccess;
}


class AllocationHeader : Header {
	property classType : ClassType;
	property argumentListopt : list[Expression];
}


class ClassInstanceCreationExpression : StatementExpression {
	property onlyTypeArguments : OnlyTypeArguments;
	property classType : ClassType;
	property argumentListopt : list[Expression];
	property classBodyopt : ClassBody;
	property primary : Primary;
	property classInstanceCreationExpressionName : ClassInstanceCreationExpressionName;
}


class ClassInstanceCreationExpressionName {
	property name : Name;
}


class ArrayCreationHeader : Header {
	property primitiveType : PrimitiveType;
	property dimWithOrWithOutExprs : list[DimWithOrWithOutExpr];
	property classOrInterfaceType : ClassOrInterfaceType;
}


class ArrayCreationWithoutArrayInitializer : Primary {
	property primitiveType : PrimitiveType;
	property dimWithOrWithOutExprs : list[DimWithOrWithOutExpr];
	property classOrInterfaceType : ClassOrInterfaceType;
}


class ArrayCreationWithArrayInitializer : Primary {
	property primitiveType : PrimitiveType;
	property dimWithOrWithOutExprs : list[DimWithOrWithOutExpr];
	property arrayInitializer : ArrayInitializer;
	property classOrInterfaceType : ClassOrInterfaceType;
}


class DimWithOrWithOutExpr {
	property expression : Expression;
}


class Dims : MethodHeaderExtendedDims {
	property dimsLoop : list[OneDimLoop];
}


class OneDimLoop {
}


class FieldAccess {
	property primary : Primary;
	property identifier : String;
}


class MethodInvocation : StatementExpression {
	property name : Name;
	property argumentListopt : list[Expression];
	property onlyTypeArguments : OnlyTypeArguments;
	property identifier : String;
	property primary : Primary;
}


class ArrayAccess {
	property name : Name;
	property expression : Expression;
	property primaryNoNewArray : PrimaryNoNewArray;
	property arrayCreationWithArrayInitializer : ArrayCreationWithArrayInitializer;
}


interface PostfixExpression {
}


class PostIncrementExpression : StatementExpression, PostfixExpression, PostfixExpression_NotName {
	property postfixExpression : PostfixExpression;
}


class PostDecrementExpression : StatementExpression, PostfixExpression, PostfixExpression_NotName {
	property postfixExpression : PostfixExpression;
}


class UnaryExpression_item {
	property preIncrementExpression : PreIncrementExpression;
	property preDecrementExpression : PreDecrementExpression;
	property unaryExpressionNotPlusMinus : UnaryExpressionNotPlusMinus;
}


class PreIncrementExpression : StatementExpression {
	property unaryExpression : list[UnaryExpression_item];
}


class PreDecrementExpression : StatementExpression {
	property unaryExpression : list[UnaryExpression_item];
}


class UnaryExpressionNotPlusMinus {
	property postfixExpression : PostfixExpression;
	property unaryExpression : list[UnaryExpression_item];
	property castExpression : CastExpression;
}


class CastExpression {
	property primitiveType : PrimitiveType;
	property dimsopt : Dims;
	property unaryExpression : list[UnaryExpression_item];
	property name : Name;
	property onlyTypeArgumentsForCastExpression : OnlyTypeArgumentsForCastExpression;
	property unaryExpressionNotPlusMinus : UnaryExpressionNotPlusMinus;
	property classOrInterfaceType : ClassOrInterfaceType;
	property dims : Dims;
}


interface OnlyTypeArgumentsForCastExpression {
}


class InstanceofExpression_item {
	property relationalExpression : list[list[list[list[list[UnaryExpression_item]]]]];
	property referenceType : ReferenceType;
}


class ConditionalExpression_item {
	property conditionalOrExpression : list[list[list[list[list[list[list[InstanceofExpression_item]]]]]]];
	property expression : Expression;
}


class AssignmentExpression : Expression {
	property conditionalExpression : list[ConditionalExpression_item];
	property assignment : Assignment;
}


class Assignment : StatementExpression, AssignmentExpression_NotName {
	property postfixExpression : PostfixExpression;
	property assignmentOperator : AssignmentOperator;
	property assignmentExpression : AssignmentExpression;
	property invalidArrayInitializerAssignement : InvalidArrayInitializerAssignement;
}


class InvalidArrayInitializerAssignement {
	property postfixExpression : PostfixExpression;
	property assignmentOperator : AssignmentOperator;
	property arrayInitializer : ArrayInitializer;
}


enum AssignmentOperator {
	EQUAL,
	MULTEQUAL,
	SLASHEQUAL,
	PERCENTEQUAL,
	PLUSEQUAL,
	MINUSEQUAL,
	LESSLESSEQUAL,
	GREATERGREATEREQUAL,
	GREATERGREATERGREATEREQUAL,
	AMPERSANDEQUAL,
	XOREQUAL,
	OREQUAL,
}


interface Expression : VariableInitializer, ConstantExpression {
}


interface ConstantExpression {
}


class EnumDeclaration : BlockStatement {
	property enumHeader : EnumHeader;
	property enumBody : EnumBody;
}


class EnumHeader : Header {
	property enumHeaderName : EnumHeaderName;
	property classHeaderImplementsopt : ClassHeaderImplements;
}


class EnumHeaderName {
	property modifiersopt : list[Modifier];
	property identifier : String;
	property typeParameters : TypeParameters;
}


class EnumBody {
	property enumDeclarationsopt : EnumDeclarations;
	property enumConstants : list[EnumConstant];
}


class EnumConstantHeaderName {
	property modifiersopt : list[Modifier];
	property identifier : String;
}


class EnumConstantHeader : Header2 {
	property enumConstantHeaderName : EnumConstantHeaderName;
	property argumentsopt : Arguments;
}


class EnumConstant {
	property enumConstantHeader : EnumConstantHeader;
	property classBody : ClassBody;
}


class Arguments {
	property argumentListopt : list[Expression];
}


class EnumDeclarations {
	property classBodyDeclarationsopt : list[ClassBodyDeclaration];
}


class EnhancedForStatement : Statement {
	property enhancedForStatementHeader : EnhancedForStatementHeader;
	property statement : Statement;
}


class EnhancedForStatementNoShortIf : StatementNoShortIf {
	property enhancedForStatementHeader : EnhancedForStatementHeader;
	property statementNoShortIf : StatementNoShortIf;
}


class EnhancedForStatementHeaderInit {
	property type : Type;
	property identifier : String;
	property dimsopt : Dims;
	property modifiers : list[Modifier];
}


class EnhancedForStatementHeader {
	property enhancedForStatementHeaderInit : EnhancedForStatementHeaderInit;
	property expression : Expression;
}


class SingleStaticImportDeclaration : ImportDeclaration {
	property singleStaticImportDeclarationName : SingleStaticImportDeclarationName;
}


class SingleStaticImportDeclarationName {
	property name : Name;
}


class StaticImportOnDemandDeclaration : ImportDeclaration {
	property staticImportOnDemandDeclarationName : StaticImportOnDemandDeclarationName;
}


class StaticImportOnDemandDeclarationName {
	property name : Name;
}


class TypeArguments {
	property typeArgumentList1 : TypeArgumentList1;
}


class OnlyTypeArguments : OnlyTypeArgumentsForCastExpression {
	property typeArgumentList1 : TypeArgumentList1;
}


class TypeArgumentList1 {
	property typeArgument1 : TypeArgument1;
	property typeArgumentList : list[TypeArgument];
}


interface TypeArgument {
}


interface TypeArgument1 {
}


class ReferenceType1 : TypeArgument1 {
	property referenceType : ReferenceType;
	property classOrInterface : ClassOrInterface;
	property typeArgumentList2 : TypeArgumentList2;
}


class TypeArgumentList2 {
	property typeArgument2 : TypeArgument2;
	property typeArgumentList : list[TypeArgument];
}


interface TypeArgument2 {
}


class ReferenceType2 : TypeArgument2 {
	property referenceType : ReferenceType;
	property classOrInterface : ClassOrInterface;
	property typeArgumentList3 : TypeArgumentList3;
}


class TypeArgumentList3 {
	property typeArgument3 : TypeArgument3;
	property typeArgumentList : list[TypeArgument];
}


interface TypeArgument3 {
}


class ReferenceType3 : TypeArgument3 {
	property referenceType : ReferenceType;
}


class Wildcard : TypeArgument {
	property wildcardBounds : WildcardBounds;
}


class WildcardBounds {
	property referenceType : ReferenceType;
}


class Wildcard1 : TypeArgument1 {
	property wildcardBounds1 : WildcardBounds1;
}


class WildcardBounds1 {
	property referenceType1 : ReferenceType1;
}


class Wildcard2 : TypeArgument2 {
	property wildcardBounds2 : WildcardBounds2;
}


class WildcardBounds2 {
	property referenceType2 : ReferenceType2;
}


class Wildcard3 : TypeArgument3 {
	property wildcardBounds3 : WildcardBounds3;
}


class WildcardBounds3 {
	property referenceType3 : ReferenceType3;
}


class TypeParameterHeader {
	property identifier : String;
}


class TypeParameters {
	property typeParameterList1 : TypeParameterList1;
}


class TypeParameter {
	property typeParameterHeader : TypeParameterHeader;
	property referenceType : ReferenceType;
	property additionalBoundList : list[AdditionalBound];
}


class AdditionalBound {
	property referenceType : ReferenceType;
}


class TypeParameterList1 {
	property typeParameter1 : TypeParameter1;
	property typeParameterList : list[TypeParameter];
}


class TypeParameter1 {
	property typeParameterHeader : TypeParameterHeader;
	property referenceType1 : ReferenceType1;
	property referenceType : ReferenceType;
	property additionalBoundList1 : AdditionalBoundList1;
}


class AdditionalBoundList1 {
	property additionalBound1 : AdditionalBound1;
	property additionalBoundList : list[AdditionalBound];
}


class AdditionalBound1 {
	property referenceType1 : ReferenceType1;
}


interface PostfixExpression_NotName {
}


class UnaryExpression_NotName {
	property preIncrementExpression : PreIncrementExpression;
	property preDecrementExpression : PreDecrementExpression;
	property unaryExpression : list[UnaryExpression_item];
	property unaryExpressionNotPlusMinus_NotName : UnaryExpressionNotPlusMinus_NotName;
}


class UnaryExpressionNotPlusMinus_NotName {
	property postfixExpression_NotName : PostfixExpression_NotName;
	property unaryExpression : list[UnaryExpression_item];
	property castExpression : CastExpression;
}


class MultiplicativeExpression_NotName_item {
	property unaryExpression_NotName : UnaryExpression_NotName;
	property unaryExpression : list[UnaryExpression_item];
	property name : Name;
}


class AdditiveExpression_NotName_item {
	property multiplicativeExpression_NotName : list[MultiplicativeExpression_NotName_item];
	property multiplicativeExpression : list[list[UnaryExpression_item]];
	property name : Name;
}


class ShiftExpression_NotName_item {
	property additiveExpression_NotName : list[AdditiveExpression_NotName_item];
	property additiveExpression : list[list[list[UnaryExpression_item]]];
	property name : Name;
}


class RelationalExpression_NotName_item {
	property shiftExpression_NotName : list[ShiftExpression_NotName_item];
	property shiftExpression : list[list[list[list[UnaryExpression_item]]]];
	property name : Name;
}


class InstanceofExpression_NotName_item {
	property relationalExpression_NotName : list[RelationalExpression_NotName_item];
	property name : Name;
	property referenceType : ReferenceType;
}


class EqualityExpression_NotName_item {
	property instanceofExpression_NotName : list[InstanceofExpression_NotName_item];
	property instanceofExpression : list[InstanceofExpression_item];
	property name : Name;
}


class AndExpression_NotName_item {
	property equalityExpression_NotName : list[EqualityExpression_NotName_item];
	property equalityExpression : list[list[InstanceofExpression_item]];
	property name : Name;
}


class ExclusiveOrExpression_NotName_item {
	property andExpression_NotName : list[AndExpression_NotName_item];
	property andExpression : list[list[list[InstanceofExpression_item]]];
	property name : Name;
}


class InclusiveOrExpression_NotName_item {
	property exclusiveOrExpression_NotName : list[ExclusiveOrExpression_NotName_item];
	property exclusiveOrExpression : list[list[list[list[InstanceofExpression_item]]]];
	property name : Name;
}


class ConditionalAndExpression_NotName_item {
	property inclusiveOrExpression_NotName : list[InclusiveOrExpression_NotName_item];
	property inclusiveOrExpression : list[list[list[list[list[InstanceofExpression_item]]]]];
	property name : Name;
}


class ConditionalOrExpression_NotName_item {
	property conditionalAndExpression_NotName : list[ConditionalAndExpression_NotName_item];
	property conditionalAndExpression : list[list[list[list[list[list[InstanceofExpression_item]]]]]];
	property name : Name;
}


class ConditionalExpression_NotName : AssignmentExpression_NotName, MemberValue {
	property conditionalOrExpression_NotName : list[ConditionalOrExpression_NotName_item];
	property expression : Expression;
	property conditionalExpression : list[ConditionalExpression_item];
	property name : Name;
}


interface AssignmentExpression_NotName : Expression_NotName {
}


interface Expression_NotName {
}


class AnnotationTypeDeclarationHeaderName {
	property modifiers : list[Modifier];
	property identifier : String;
	property typeParameters : TypeParameters;
}


class AnnotationTypeDeclarationHeader : Header {
	property annotationTypeDeclarationHeaderName : AnnotationTypeDeclarationHeaderName;
	property classHeaderExtendsopt : ClassHeaderExtends;
	property classHeaderImplementsopt : ClassHeaderImplements;
}


class AnnotationTypeDeclaration : BlockStatement {
	property annotationTypeDeclarationHeader : AnnotationTypeDeclarationHeader;
	property annotationTypeBody : AnnotationTypeBody;
}


class AnnotationTypeBody {
	property annotationTypeMemberDeclarationsopt : list[AnnotationTypeMemberDeclaration];
}


class AnnotationMethodHeaderName {
	property modifiersopt : list[Modifier];
	property typeParameters : TypeParameters;
	property type : Type;
	property identifier : String;
}


class AnnotationMethodHeader {
	property annotationMethodHeaderName : AnnotationMethodHeaderName;
	property formalParameterListopt : list[FormalParameter];
	property methodHeaderExtendedDims : MethodHeaderExtendedDims;
	property defaultValueopt : DefaultValue;
}


class AnnotationTypeMemberDeclaration {
	property annotationMethodHeader : AnnotationMethodHeader;
	property constantDeclaration : ConstantDeclaration;
	property constructorDeclaration : ConstructorDeclaration;
	property typeDeclaration : TypeDeclaration;
}


class DefaultValue {
	property memberValue : MemberValue;
}


interface Annotation : MemberValue {
}


class AnnotationName : MarkerAnnotation {
	property name : Name;
}


class NormalAnnotation : Annotation {
	property annotationName : AnnotationName;
	property memberValuePairsopt : list[MemberValuePair];
}


class MemberValuePair {
	property simpleName : SimpleName;
	property memberValue : MemberValue;
}


interface MemberValue : SingleMemberAnnotationMemberValue {
}


class MemberValueArrayInitializer : MemberValue {
	property memberValues : list[MemberValue];
}


interface MarkerAnnotation : Annotation {
}


interface SingleMemberAnnotationMemberValue {
}


class SingleMemberAnnotation : Annotation {
	property annotationName : AnnotationName;
	property singleMemberAnnotationMemberValue : SingleMemberAnnotationMemberValue;
}


class RecoveryMethodHeaderName {
	property modifiersopt : list[Modifier];
	property typeParameters : TypeParameters;
	property type : Type;
	property identifier : String;
}


class RecoveryMethodHeader : Header {
	property recoveryMethodHeaderName : RecoveryMethodHeaderName;
	property formalParameterListopt : list[FormalParameter];
	property methodHeaderExtendedDims : MethodHeaderExtendedDims;
	property defaultValueopt : DefaultValue;
	property methodHeaderThrowsClause : MethodHeaderThrowsClause;
}

