${template unit-}
${opts.prefix}.Lexems = {
${for i in [0, parser.nterms - 1]-}
	${parser.sym[i].id->js.escapeJsReserved()}: ${i},
${end-}
};

${opts.prefix}.Lexer = function(text,errorHandler) {
	this.text = text;
	this.errorHandler = errorHandler;
}

${opts.prefix}.Lexer.prototype = {

	final private char[] data = new char[2048];
	private int datalen, l;
	private char chr;

	private int group;

	final private StringBuilder token = new StringBuilder(TOKEN_SIZE);

	private int tokenLine = 1;
	private int currLine = 1;
${if opts.positions.contains('column') || opts.endpositions.contains('column')-}
	private int currColumn = 1;
${end-}
${if opts.positions.contains('offset') || opts.endpositions.contains('offset')-}
	private int currOffset = 0;
${end-}

	reset: function(stream) {
		this.stream = stream;
		this.datalen = stream.read(data);
		this.l = 0;
		this.group = 0;
		chr = l < datalen ? data[l++] : 0;
	},

	getState: function() {
		return group;
	},

	setState: function(state) {
		this.group = state;
	},

	getTokenLine: function() {
		return tokenLine;
	},

	setLine: function(int currLine) {
		this.currLine = currLine;
	},

${if opts.positions.contains('column') || opts.endpositions.contains('column')-}
	setColumn: function(currColumn) {
		this.currColumn = currColumn;
	},

${end-}
${if opts.positions.contains('offset') || opts.endpositions.contains('offset')-}
	setOffset: function(currOffset) {
		this.currOffset = currOffset;
	},

${end-}
	current: function() {
		return token.toString();
	}

${self->lexerTables()-}

	mapCharacter: function(chr) {
		if (chr >= 0 && chr < ${lex.char2no.length}) {
			return lapg_char2no[chr];
		}
		return 1;
	},

	next: function() {
		var lapg_n = {};
		var state;

		do {
${if opts.positions.contains('offset')-}
			lapg_n.offset = this.currOffset;
${end-}
			this.tokenLine =${if opts.positions.contains('line')} lapg_n.line =${end} this.currLine;
${if opts.positions.contains('column')-}
			lapg_n.column = this.currColumn;
${end-}
			this.token = "";
			int tokenStart = l - 1;

			for (state = group; state >= 0;) {
				state = lapg_lexem[state][mapCharacter(chr)];
				if (state >= -1 && chr != 0) {
${if opts.positions.contains('offset') || opts.endpositions.contains('offset')-}
					currOffset++;
${end-}
${if opts.positions.contains('column') || opts.endpositions.contains('column')-}
					currColumn++;
${end-}
					if (chr == '\n') {
${if opts.positions.contains('column') || opts.endpositions.contains('column')-}
						currColumn = 1;
${end-}
						currLine++;
					}
					if (l >= datalen) {
						token.append(data, tokenStart, l - tokenStart);
						datalen = stream.read(data);
						tokenStart = l = 0;
					}
					chr = l < datalen ? data[l++] : 0;
				}
			}
${if opts.endpositions.contains('offset')-}
			lapg_n.endoffset = currOffset;
${end-}
${if opts.endpositions.contains('line')-}
			lapg_n.endline = currLine;
${end-}
${if opts.endpositions.contains('column')-}
			lapg_n.endcolumn = currColumn;
${end-}

			if (state == -1) {
				if (chr == 0) {
					reporter.error(${call js.err_location('lapg_n')}currLine, "Unexpected end of file reached");
					break;
				}
				reporter.error(${call js.err_location('lapg_n')}currLine, java.text.@MessageFormat.format("invalid lexem at line {0}: `{1}`, skipped", currLine, current()));
				lapg_n.lexem = -1;
				continue;
			}

			if (l - 1 > tokenStart) {
				token.append(data, tokenStart, l - 1 - tokenStart);
			}

			lapg_n.lexem = - state - 2;
			lapg_n.sym = null;

${if syntax.hasLexemActions()-}
		} while (lapg_n.lexem == -1 || !createToken(lapg_n));
${else-}
		} while (lapg_n.lexem == -1);
${end-}
		return lapg_n;
	},
${if syntax.hasLexemActions()}
	createToken: function(lapg_n) {
		switch (lapg_n.lexem) {
${foreach lexem in syntax.lexems-}
${if lexem.action-}
			case ${lexem.symbol.index}:
				${call lexerAction('lapg_n.sym') for lexem-}
${end-}
${end-}
		}
		return true;
	},
${end-}
}
${end}


${template lexerAction(lexem)-}
${eval action.contents, '[lexem action in '+getAction().getLocation()+']'}
${end}


${template lexerTables-}
${call js.parserTable(lex.char2no, 'short', 'lapg_char2no', 'LapgCharMap')-}

	private static final short[][] lapg_lexem = new short[][] {
		${util.format(lex.change, 2, '{', '}')}
	};
${end}